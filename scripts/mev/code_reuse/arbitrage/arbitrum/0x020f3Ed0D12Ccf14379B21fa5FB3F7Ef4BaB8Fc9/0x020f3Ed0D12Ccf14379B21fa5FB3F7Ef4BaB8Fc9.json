{
    "SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize/address.code.length, which returns 0\r\n    // for contracts in construction, since the code is only stored at the end\r\n    // of the constructor execution.\r\n\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n    (bool success, bytes memory returndata) = target.call(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint value\r\n  ) internal {\r\n    uint newAllowance = token.allowance(address(this), spender) + value;\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n  }\r\n\r\n  /**\r\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n    // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n  }\r\n\r\n}\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IPair {\r\n\r\n  // Structure to capture time period obervations every 30 minutes, used for local oracles\r\n  struct Observation {\r\n    uint timestamp;\r\n    uint reserve0Cumulative;\r\n    uint reserve1Cumulative;\r\n  }\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n\r\n  function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n\r\n  function getAmountOut(uint, address) external view returns (uint);\r\n\r\n  function claimFees() external returns (uint, uint);\r\n\r\n  function tokens() external view returns (address, address);\r\n\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function stable() external view returns (bool);\r\n\r\n  function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\r\n}\r\ninterface IWAVAX {\r\n  function name() external view returns (string memory);\r\n\r\n  function approve(address guy, uint256 wad) external returns (bool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function transferFrom(\r\n    address src,\r\n    address dst,\r\n    uint256 wad\r\n  ) external returns (bool);\r\n\r\n  function withdraw(uint256 wad) external;\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address) external view returns (uint256);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function transfer(address dst, uint256 wad) external returns (bool);\r\n\r\n  function deposit() external payable;\r\n\r\n  function allowance(address, address) external view returns (uint256);\r\n\r\n}\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\ncontract AMMRouter{\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint;\r\n\r\n  struct Route {\r\n    address pair;\r\n    bool AMM;\r\n  }\r\n\r\n  IWAVAX public immutable wavax;\r\n \r\n  modifier ensure(uint deadline) {\r\n    require(deadline >= block.timestamp, 'AMMRouter: EXPIRED');\r\n    _;\r\n  }\r\n\r\n  constructor(address _wavax) {\r\n    wavax = IWAVAX(_wavax);\r\n  }\r\n\r\n  receive() external payable {\r\n    // only accept AVAX via fallback from the WAVAX contract\r\n    require(msg.sender == address(wavax), \"AMMRouter: NOT_WAVAX\");\r\n  }\r\n\r\n  function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1) {\r\n    return _sortTokens(tokenA, tokenB);\r\n  }\r\n\r\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n    require(tokenA != tokenB, 'AMMRouter: IDENTICAL_ADDRESSES');\r\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n    require(token0 != address(0), 'AMMRouter: ZERO_ADDRESS');\r\n  }\r\n\r\n  function getOtherToken(address pair, address token) internal view returns (address otherToken) {\r\n    address token0 = IPair(pair).token0();\r\n    address token1 = IPair(pair).token1();\r\n    otherToken = token0 == token ? token1 : token0;\r\n  }\r\n\r\n  \r\n\r\n  /// @dev Performs chained getAmountOut calculations on any number of pairs.\r\n  function getAmountOut(uint amountIn, address tokenIn, address pair, bool AMM) external view returns (uint amount) {\r\n    _getAmountOut(amountIn, tokenIn, pair, AMM);\r\n  }\r\n  function _getAmountOut(uint amountIn, address tokenIn, address pair, bool AMM) internal view returns (uint amount) {\r\n    if (AMM) {\r\n      amount = IPair(pair).getAmountOut(amountIn, tokenIn);\r\n    }else{\r\n      amount = _getAmountOut0(amountIn, tokenIn, pair);\r\n    }\r\n  }\r\n  function _getAmountOut0(uint amountIn, address tokenIn, address pair) internal view returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        (uint reserve0, uint reserve1,) = IPair(pair).getReserves();\r\n        require(reserve0 > 0 && reserve1 > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        address token0 = IPair(pair).token0();\r\n        (uint reserveIn, uint reserveOut) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n  \r\n\r\n  /// @dev Performs chained getAmountOut calculations on any number of pairs.\r\n  function getAmountsOut(uint amountIn, address tokenIn, Route[] memory routes) external view returns (uint[] memory amounts) {\r\n    return _getAmountsOut(amountIn, tokenIn, routes);\r\n  }\r\n\r\n  function _getAmountsOut(uint amountIn, address _tokenIn, Route[] memory routes) internal view returns (uint[] memory amounts) {\r\n    require(routes.length >= 1, 'AMMRouter: INVALID_PATH');\r\n    amounts = new uint[](routes.length + 1);\r\n    amounts[0] = amountIn;\r\n    address tokenIn = _tokenIn;\r\n    for (uint i = 0; i < routes.length; i++) {\r\n      address pair = routes[i].pair;\r\n      amounts[i + 1] = _getAmountOut(amounts[i], tokenIn, pair, routes[i].AMM);\r\n      tokenIn = getOtherToken(pair, tokenIn);\r\n    }\r\n  }\r\n\r\n\r\n  // **** SWAP ****\r\n  // requires the initial amount to have already been sent to the first pair\r\n  function _swap(uint[] memory amounts, address _tokenIn, Route[] memory routes, address _to) internal virtual {\r\n    address tokenIn = _tokenIn;\r\n    for (uint i = 0; i < routes.length; i++) {\r\n      address token0 = IPair(routes[i].pair).token0();\r\n      uint amountOut = amounts[i + 1];\r\n      (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n      address to = i < routes.length - 1 ? routes[i + 1].pair : _to;\r\n      IPair(routes[i].pair).swap(\r\n        amount0Out, amount1Out, to, new bytes(0)\r\n      );\r\n      tokenIn = getOtherToken(routes[i].pair, tokenIn);\r\n    }\r\n  }\r\n\r\n  function _swapSupportingFeeOnTransferTokens(address _tokenIn, Route[] memory routes, address _to) internal virtual {\r\n    address input = _tokenIn;\r\n    for (uint i = 0; i < routes.length; i++) {\r\n      //(address input, address output) = (routes[i].from, routes[i].to);\r\n      IPair pair = IPair(routes[i].pair);\r\n      address token0 = pair.token0();\r\n      uint amountInput;\r\n      uint amountOutput;\r\n      {// scope to avoid stack too deep errors\r\n        (uint reserve0, uint reserve1,) = pair.getReserves();\r\n        uint reserveInput = input == token0 ? reserve0 : reserve1;\r\n        amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\r\n        //(amountOutput,) = getAmountOut(amountInput, input, output, stable);\r\n        amountOutput = _getAmountOut(amountInput, input, address(pair), routes[i].AMM);\r\n      }\r\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n      address to = i < routes.length - 1 ? routes[i + 1].pair : _to;\r\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n      input = getOtherToken(address(pair),input);\r\n    }\r\n  }\r\n\r\n  function swapExactTokensForTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address tokenIn,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint deadline\r\n  ) external ensure(deadline) returns (uint[] memory amounts) {\r\n    amounts = _getAmountsOut(amountIn, tokenIn, routes);\r\n    require(amounts[amounts.length - 1] >= amountOutMin, 'AMMRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    IERC20(tokenIn).safeTransferFrom(\r\n      msg.sender, routes[0].pair, amounts[0]\r\n    );\r\n    _swap(amounts, tokenIn, routes, to);\r\n  }\r\n\r\n  function swapExactAVAXForTokens(uint amountOutMin, address tokenIn, Route[] calldata routes, address to, uint deadline)\r\n  external\r\n  payable\r\n  ensure(deadline)\r\n  returns (uint[] memory amounts)\r\n  {\r\n    require(tokenIn == address(wavax), 'AMMRouter: INVALID_PATH');\r\n    amounts = _getAmountsOut(msg.value, tokenIn, routes);\r\n    require(amounts[amounts.length - 1] >= amountOutMin, 'AMMRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    wavax.deposit{value : amounts[0]}();\r\n    assert(wavax.transfer(routes[0].pair, amounts[0]));\r\n    _swap(amounts, tokenIn, routes, to);\r\n  }\r\n\r\n  function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address tokenIn, Route[] calldata routes, address to, uint deadline)\r\n  external\r\n  ensure(deadline)\r\n  returns (uint[] memory amounts)\r\n  {\r\n    require(IPair(routes[routes.length - 1].pair).token0() == address(wavax)\r\n    || IPair(routes[routes.length - 1].pair).token1() == address(wavax), 'AMMRouter: INVALID_PATH');\r\n    amounts = _getAmountsOut(amountIn, tokenIn, routes);\r\n    require(amounts[amounts.length - 1] >= amountOutMin, 'AMMRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    IERC20(tokenIn).safeTransferFrom(\r\n      msg.sender, routes[0].pair, amounts[0]\r\n    );\r\n    _swap(amounts, tokenIn, routes, address(this));\r\n    wavax.withdraw(amounts[amounts.length - 1]);\r\n    _safeTransferAVAX(to, amounts[amounts.length - 1]);\r\n  }\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address tokenIn,\r\n    address tokenOut,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint deadline\r\n  ) external ensure(deadline) {\r\n    IERC20(tokenIn).safeTransferFrom(\r\n      msg.sender,\r\n      routes[0].pair,\r\n      amountIn\r\n    );\r\n    uint balanceBefore = IERC20(tokenOut).balanceOf(to);\r\n    _swapSupportingFeeOnTransferTokens(tokenIn, routes, to);\r\n    require(\r\n      IERC20(tokenOut).balanceOf(to) - balanceBefore >= amountOutMin,\r\n      'AMMRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n    );\r\n  }\r\n\r\n  function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\r\n    uint amountOutMin,\r\n    address tokenIn,\r\n    address tokenOut,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint deadline\r\n  )\r\n  external\r\n  payable\r\n  ensure(deadline)\r\n  {\r\n    require(tokenIn == address(wavax), 'AMMRouter: INVALID_PATH');\r\n    uint amountIn = msg.value;\r\n    wavax.deposit{value : amountIn}();\r\n    assert(wavax.transfer(routes[0].pair, amountIn));\r\n    uint balanceBefore = IERC20(tokenOut).balanceOf(to);\r\n    _swapSupportingFeeOnTransferTokens(tokenIn, routes, to);\r\n    require(\r\n      IERC20(tokenOut).balanceOf(to) - balanceBefore >= amountOutMin,\r\n      'AMMRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n    );\r\n  }\r\n\r\n  function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address tokenIn,\r\n    address tokenOut,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint deadline\r\n  )\r\n  external\r\n  ensure(deadline)\r\n  {\r\n    require(tokenOut == address(wavax), 'AMMRouter: INVALID_PATH');\r\n    IERC20(tokenIn).safeTransferFrom(\r\n      msg.sender, routes[0].pair, amountIn\r\n    );\r\n    _swapSupportingFeeOnTransferTokens(tokenIn, routes, address(this));\r\n    uint amountOut = IERC20(address(wavax)).balanceOf(address(this));\r\n    require(amountOut >= amountOutMin, 'AMMRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    wavax.withdraw(amountOut);\r\n    _safeTransferAVAX(to, amountOut);\r\n  }\r\n\r\n\r\n  function _safeTransferAVAX(address to, uint value) internal {\r\n    (bool success,) = to.call{value : value}(new bytes(0));\r\n    require(success, 'AMMRouter: AVAX_TRANSFER_FAILED');\r\n  }\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wavax\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"sortTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactAVAXForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactAVAXForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForAVAX\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForAVAXSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AMM\",\"type\":\"bool\"}],\"internalType\":\"struct AMMRouter.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wavax\",\"outputs\":[{\"internalType\":\"contract IWAVAX\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "AMMRouter",
    "CompilerVersion": "v0.8.18+commit.87f61d96",
    "OptimizationUsed": "0",
    "Runs": "200",
    "ConstructorArguments": "00000000000000000000000082af49447d8a07e3bd95bd0d56f35241523fbab1",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://2f895b5c6a536b3793c3acd1ca0a1b61a249085b11a08faf03a89949669f2322"
}