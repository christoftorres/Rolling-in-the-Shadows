{
    "SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract Multicall {\r\n    uint private am;\r\n    address private v3Factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\r\n\r\n    struct RouteParams {\r\n        uint amIn;\r\n        uint amOut;\r\n        address tIn;\r\n        address tOut;\r\n        bytes[] callPath;\r\n    }\r\n\r\n    function uniswapV3FlashCallback(uint256 fee0,uint256 fee1,bytes calldata data) external {\r\n        fee0 += am; fee1 += am;\r\n        multicall(abi.decode(data, (bytes[])));\r\n        if(fee0 > fee1){\r\n            address token=IV3Pool(msg.sender).token0();\r\n            IERC20(token).transfer(msg.sender,fee0);\r\n            IERC20(token).transfer(tx.origin,am-fee0);\r\n        }\r\n        else{\r\n            address token=IV3Pool(msg.sender).token1();\r\n            IERC20(token).transfer(msg.sender,fee1);\r\n            IERC20(token).transfer(tx.origin,am-fee1);\r\n        }\r\n    }\r\n\r\n    function flashCallback(uint256 fee0,uint256 fee1,bytes calldata data) external {\r\n        fee0 += am; fee1 += am;\r\n        multicall(abi.decode(data, (bytes[])));\r\n        if(fee0 > fee1){\r\n            address token=IV3Pool(msg.sender).token0();\r\n            IERC20(token).transfer(msg.sender,fee0);\r\n            IERC20(token).transfer(tx.origin,am-fee0);\r\n        }\r\n        else{\r\n            address token=IV3Pool(msg.sender).token1();\r\n            IERC20(token).transfer(msg.sender,fee1);\r\n            IERC20(token).transfer(tx.origin,am-fee1);\r\n        }\r\n    }\r\n\r\n    function algebraFlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external{\r\n        fee0 += am; fee1 += am;\r\n        multicall(abi.decode(data, (bytes[])));\r\n        if(fee0 > fee1){\r\n            address token=IV3Pool(msg.sender).token0();\r\n            IERC20(token).transfer(msg.sender,fee0);\r\n            IERC20(token).transfer(tx.origin,am-fee0);\r\n        }\r\n        else{\r\n            address token=IV3Pool(msg.sender).token1();\r\n            IERC20(token).transfer(msg.sender,fee1);\r\n            IERC20(token).transfer(tx.origin,am-fee1);\r\n        }\r\n    }\r\n\r\n    function uniswapV3SwapCallback(int256 am0,int256 am1,bytes calldata) external {\r\n        if (am0 > am1) {\r\n            IERC20(IV3Pool(msg.sender).token0()).transfer(msg.sender,uint(am0));\r\n            am = uint(-am1);\r\n        } else {\r\n            IERC20(IV3Pool(msg.sender).token1()).transfer(msg.sender,uint(am1));\r\n            am = uint(-am0);\r\n        }\r\n    }\r\n\r\n    function algebraSwapCallback(int256 am0,int256 am1,bytes calldata) external {\r\n        if (am0 > am1) {\r\n            IERC20(IV3Pool(msg.sender).token0()).transfer(msg.sender,uint(am0));\r\n            am = uint(-am1);\r\n        } else {\r\n            IERC20(IV3Pool(msg.sender).token1()).transfer(msg.sender,uint(am1));\r\n            am = uint(-am0);\r\n        }\r\n    }\r\n\r\n    function swapCallback(int256 am0, int256 am1, bytes calldata) external {\r\n        if (am0 > am1) {\r\n            IERC20(IV3Pool(msg.sender).token0()).transfer(msg.sender,uint(am0));\r\n            am = uint(-am1);\r\n        } else {\r\n            IERC20(IV3Pool(msg.sender).token1()).transfer(msg.sender,uint(am1));\r\n            am = uint(-am0);\r\n        }\r\n    }\r\n\r\n    function uniV2(address pool, bool direc) public {\r\n        IERC20(direc ? IUniV2Pool(pool).token0() : IUniV2Pool(pool).token1()).transfer(pool, am);\r\n        (uint112 reserve0, uint112 reserve1, ) = IUniV2Pool(pool).getReserves();\r\n        am = (am * 997) / 1000;\r\n        am = direc ? (am * reserve1) / (reserve0 + am) : (am * reserve0) / (reserve1 + am);\r\n        IUniV2Pool(pool).swap(direc ? 0 : am,direc ? am : 0,address(this),\"\");\r\n    }\r\n\r\n    function uniV3(address pool, bool direc) public {\r\n        IUniV3Pool(pool).swap(address(this),direc,int(am),direc ? 4295128740 : 1461446703485210103287273052203988822378723970341,\"\");\r\n    }\r\n\r\n    function algebraV3(address pool, bool direc) public {\r\n        IAlgebraV3Pool(pool).swap(address(this),direc,int(am),direc ? 4295128740 : 1461446703485210103287273052203988822378723970341,\"\");\r\n    }\r\n\r\n    function kyberV3(address pool, bool direc) public {\r\n        IKyberV3Pool(pool).swap(address(this),int(am),direc,direc ? 4295128740 : 1461446703485210103287273052203988822378723970341,\"\");\r\n    }\r\n\r\n    function flashRoute(RouteParams calldata route,address flashPool) public returns(uint amOut){\r\n        am = route.amIn;\r\n        bool tIn_t0=IV3Pool(flashPool).token0()==route.tIn;\r\n        IV3Pool(flashPool).flash(address(this),tIn_t0 ? am : 0,tIn_t0 ? 0 : am,abi.encode(route.callPath));\r\n        amOut=am;\r\n        delete am;\r\n    }\r\n\r\n    function fundsRoute(RouteParams calldata route)public returns(uint amOut){\r\n        IERC20(route.tIn).transferFrom(msg.sender, address(this), route.amIn);\r\n        am = route.amIn;\r\n        multicall(route.callPath);\r\n        require(am>=amOut,\"amOut\");\r\n        IERC20(route.tIn).transfer(msg.sender, am);\r\n        amOut=am;\r\n        delete am;\r\n    }\r\n\r\n    function multicall(bytes[] memory callPath) public {\r\n        for (uint8 i = 0; i < callPath.length; i++) {\r\n            (bool success, ) = address(this).call(callPath[i]);\r\n            require(success, \"err\");\r\n        }\r\n    }\r\n\r\n    function getPools(address tokenA,address tokenB) public view returns (address[] memory pools){\r\n        uint16[4] memory fees=[100,500,3000,10000];\r\n        pools = new address[](0);\r\n        for (uint8 i=0 ; i<fees.length ; i++) {\r\n            address pool = IV3Factory(v3Factory).getPool(tokenA, tokenB, fees[i]);\r\n            if (pool != address(0))\r\n                pools=addAddress(pools,pool);\r\n        }\r\n    }\r\n\r\n    function poolQuote(address pool, bool direc, uint256 amIn) public view returns (uint256 amOut) {\r\n        uint256 poolIn = amIn - (amIn * IUniV3Pool(pool).fee()) / 1e6;\r\n        (uint160 sqrtPriceX96, int24 tick, , , , , ) = IUniV3Pool(pool).slot0();\r\n        int24 spacing = IUniV3Pool(pool).tickSpacing();\r\n        int24 tickL = (tick / spacing) * spacing;\r\n        int24 tickU = tickL + spacing;\r\n        uint128 liquidity = IUniV3Pool(pool).liquidity();\r\n        uint256 token0VirtualReserves = liquidity / (sqrtPriceX96 * sqrtPriceX96);\r\n        uint256 token1VirtualReserves = liquidity * (sqrtPriceX96 * sqrtPriceX96);\r\n        uint256 token1RealReserves = (liquidity * ((10001 ** uint256(int256(tickL))) / 10000)) - token1VirtualReserves;\r\n        uint256 token0RealReserves = (liquidity / ((10001 ** uint256(int256(tickU))) / 10000)) - token0VirtualReserves;\r\n        amOut = (poolIn * (direc ? token1VirtualReserves : token0VirtualReserves)) / ((direc ? token0VirtualReserves : token1VirtualReserves) + poolIn);\r\n        if ((direc ? token1RealReserves : token0RealReserves) < amOut)\r\n            amOut = (direc ? token1RealReserves : token0RealReserves);\r\n    }\r\n\r\n    function addAddress(address[] memory myArray, address newItem) private pure returns (address[] memory newArray) {\r\n        newArray = new address[](myArray.length + 1);\r\n        for (uint i = 0; i < myArray.length; i++) \r\n            newArray[i] = myArray[i];\r\n        newArray[myArray.length - 1] = newItem;\r\n    }\r\n\r\n    function addCall(bytes[] memory myArray, bytes memory newItem) private pure returns (bytes[] memory newArray) {\r\n        newArray = new bytes[](myArray.length + 1);\r\n        for (uint i = 0; i < myArray.length; i++)\r\n            newArray[i] = myArray[i];\r\n        newArray[myArray.length - 1] = newItem;\r\n    }\r\n\r\n    function poolCall(address pool,bool direc) public pure returns (bytes memory){\r\n        return abi.encodeWithSignature(\"uniV3(address,bool)\", pool,direc);\r\n    }\r\n\r\n    function getRoute(RouteParams memory route,uint8 d,address[] calldata tokens) public view returns (RouteParams memory) {\r\n        route.amOut = route.amIn * ((route.tIn == route.tOut) ? 1 : 0);\r\n        while (d-- > 0) {\r\n            for (uint256 i = 0; i < tokens.length; i++) {\r\n                RouteParams memory rCon = getRoute(RouteParams(route.amIn,route.amOut,route.tIn,tokens[i],route.callPath), d , tokens);\r\n                if(rCon.amOut > 0){\r\n                    address[] memory poolsConOut=getPools(rCon.tOut,route.tOut);\r\n                    for (uint256 j = 0; j < poolsConOut.length; j++) {\r\n                        uint256 amOut = poolQuote(poolsConOut[j], rCon.tOut<route.tOut, rCon.amOut);\r\n                        if (amOut > route.amOut) {\r\n                            route.amOut = amOut;\r\n                            route.callPath=addCall(rCon.callPath,poolCall(poolsConOut[j],rCon.tOut<route.tOut));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return route;\r\n    }\r\n}\r\n\r\ninterface IV3Factory {\r\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\r\n}\r\n\r\ninterface IPool {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface IV3Pool is IPool {\r\n    function flash(address recipient,uint256 amount0,uint256 amount1,bytes calldata data) external;\r\n    function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked);\r\n    function tickSpacing(\r\n  ) external view returns (int24);\r\n  function liquidity(\r\n  ) external view returns (uint128);\r\n}\r\n\r\ninterface IUniV2Pool is IPool {\r\n    function swap(uint amount0Out,uint amount1Out,address to,bytes calldata data) external;\r\n    function getReserves()external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IUniV3Pool is IV3Pool {\r\n    function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n    function fee() external view returns (uint24);\r\n}\r\n\r\ninterface IAlgebraV3Pool is IV3Pool {\r\n    function globalState() external view returns (uint160 price, int24 tick, uint16 feeZtO, uint16 feeOtZ, uint16 timepointIndex, uint8 communityFee, bool unlocked);\r\n    function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n}\r\n\r\ninterface IKyberV3Pool is IV3Pool {\r\n    function swap(address recipient,int256 swapQty,bool isToken0,uint160 limitSqrtP,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n    function swapFeeUnits() external view returns (uint24);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient,uint256 amount) external returns (bool);\r\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"algebraFlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"am0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"am1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"algebraSwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"algebraV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Multicall.RouteParams\",\"name\":\"route\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"flashPool\",\"type\":\"address\"}],\"name\":\"flashRoute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Multicall.RouteParams\",\"name\":\"route\",\"type\":\"tuple\"}],\"name\":\"fundsRoute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Multicall.RouteParams\",\"name\":\"route\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"d\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getRoute\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Multicall.RouteParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"kyberV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"poolCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"}],\"name\":\"poolQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"am0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"am1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"swapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"uniV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"uniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"am0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"am1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "Multicall",
    "CompilerVersion": "v0.8.20+commit.a1b79de6",
    "OptimizationUsed": "1",
    "Runs": "800",
    "ConstructorArguments": "",
    "EVMVersion": "istanbul",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://8cc62db8984f90b762722070d0779b596defc83962baa2332395118929ba4139"
}