{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/antfarm/AntfarmOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nimport \\\"../libraries/fixedpoint/FixedPoint.sol\\\";\\n\\nerror InvalidToken();\\n\\n/// @title Antfarm Oracle for AntfarmPair\\n/// @notice Fixed window oracle that recomputes the average price for the entire period once every period\\ncontract AntfarmOracle {\\n    using FixedPoint for *;\\n\\n    uint256 public constant PERIOD = 1 hours;\\n\\n    address public token1;\\n    address public pair;\\n\\n    uint256 public price1CumulativeLast;\\n    uint32 public blockTimestampLast;\\n    FixedPoint.uq112x112 public price1Average;\\n\\n    bool public firstUpdateCall;\\n\\n    constructor(\\n        address _token1,\\n        uint256 _price1CumulativeLast,\\n        uint32 _blockTimestampLast\\n    ) {\\n        token1 = _token1;\\n        pair = msg.sender;\\n        price1CumulativeLast = _price1CumulativeLast; // fetch the current accumulated price value (1 / 0)\\n        blockTimestampLast = _blockTimestampLast;\\n        firstUpdateCall = true;\\n    }\\n\\n    /// @notice Average price update\\n    /// @param price1Cumulative Price cumulative for the associated AntfarmPair's token1\\n    /// @param blockTimestamp Last block timestamp for the associated AntfarmPair\\n    /// @dev Only usable by the associated AntfarmPair\\n    function update(uint256 price1Cumulative, uint32 blockTimestamp) external {\\n        require(msg.sender == pair);\\n        unchecked {\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n            // ensure that at least one full period has passed since the last update\\n            if (timeElapsed >= PERIOD || firstUpdateCall) {\\n                // overflow is desired, casting never truncates\\n                // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n                price1Average = FixedPoint.uq112x112(\\n                    uint224(\\n                        (price1Cumulative - price1CumulativeLast) / timeElapsed\\n                    )\\n                );\\n                price1CumulativeLast = price1Cumulative;\\n                blockTimestampLast = blockTimestamp;\\n                if (firstUpdateCall) {\\n                    firstUpdateCall = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Consult the average price for a given token\\n    /// @param token Price cumulative for the associated AntfarmPair's token\\n    /// @param amountIn The amount to get the value of\\n    /// @return amountOut Return the calculated amount (always return 0 before update has been called successfully for the first time)\\n    function consult(address token, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut)\\n    {\\n        if (token == token1) {\\n            amountOut = price1Average.mul(amountIn).decode144();\\n        } else {\\n            revert InvalidToken();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/antfarm/AntfarmRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nimport \\\"../interfaces/IAntfarmRouter.sol\\\";\\nimport \\\"../interfaces/IAntfarmPair.sol\\\";\\nimport \\\"../interfaces/IAntfarmFactory.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/TransferHelper.sol\\\";\\nimport \\\"./AntfarmOracle.sol\\\";\\nimport \\\"../utils/AntfarmRouterErrors.sol\\\";\\n\\n/// @title Antfarm Router for AntFarmPair\\n/// @notice High-level contract that serves as the entrypoint for swapping\\ncontract AntfarmRouter is IAntfarmRouter {\\n    address public immutable factory;\\n    address public immutable WETH;\\n    address public immutable antfarmToken;\\n\\n    modifier ensure(uint256 deadline) {\\n        if (deadline < block.timestamp) revert Expired();\\n        _;\\n    }\\n\\n    constructor(\\n        address _factory,\\n        address _WETH,\\n        address _antfarmToken\\n    ) {\\n        require(_factory != address(0), \\\"NULL_FACTORY_ADDRESS\\\");\\n        require(_WETH != address(0), \\\"NULL_WETH_ADDRESS\\\");\\n        require(_antfarmToken != address(0), \\\"NULL_ATF_ADDRESS\\\");\\n        factory = _factory;\\n        WETH = _WETH;\\n        antfarmToken = _antfarmToken;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    /// @notice Swaps an exact amount of input tokens for as many output tokens as possible\\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForTokensParams` in calldata\\n    // @param amountIn The amount of input tokens to send\\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\\n    // @param maxFee Maximum fees to be paid\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    /// @return amounts The input token amount and all subsequent output token amounts\\n    function swapExactTokensForTokens(\\n        swapExactTokensForTokensParams calldata params\\n    )\\n        external\\n        virtual\\n        ensure(params.deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        uint256 amountIn = params.path[0] == antfarmToken\\n            ? (params.amountIn * (1000 + params.fees[0])) / 1000\\n            : params.amountIn;\\n        amounts = getAmountsOut(amountIn, params.path, params.fees);\\n        if (amounts[amounts.length - 1] < params.amountOutMin) {\\n            revert InsufficientOutputAmount();\\n        }\\n        TransferHelper.safeTransferFrom(\\n            params.path[0],\\n            msg.sender,\\n            pairFor(params.path[0], params.path[1], params.fees[0]),\\n            amounts[0]\\n        );\\n        if (\\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\\n        ) {\\n            revert InsufficientMaxFee();\\n        }\\n    }\\n\\n    /// @notice Receive an exact amount of output tokens for as few input tokens as possible\\n    /// @param params The parameters necessary for the swap, encoded as `swapTokensForExactTokensParams` in calldata\\n    // @param amountOut The amount of output tokens to receive\\n    // @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts\\n    // @param maxFee Maximum fees to be paid\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    /// @return amounts The input token amount and all subsequent output token amounts\\n    function swapTokensForExactTokens(\\n        swapTokensForExactTokensParams calldata params\\n    )\\n        external\\n        virtual\\n        ensure(params.deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        uint256 amountInMax = params.path[0] == antfarmToken\\n            ? (params.amountInMax * (1000 + params.fees[0])) / 1000\\n            : params.amountInMax;\\n        amounts = getAmountsIn(params.amountOut, params.path, params.fees);\\n        if (amounts[0] > amountInMax) revert ExcessiveInputAmount();\\n        TransferHelper.safeTransferFrom(\\n            params.path[0],\\n            msg.sender,\\n            pairFor(params.path[0], params.path[1], params.fees[0]),\\n            amounts[0]\\n        );\\n        if (\\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\\n        ) {\\n            revert InsufficientMaxFee();\\n        }\\n    }\\n\\n    /// @notice Swaps an exact amount of ETH for as many output tokens as possible\\n    /// @param params The parameters necessary for the swap, encoded as `swapExactETHForTokensParams` in calldata\\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\\n    // @param maxFee Maximum fees to be paid\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    /// @return amounts The input token amount and all subsequent output token amounts\\n    function swapExactETHForTokens(swapExactETHForTokensParams calldata params)\\n        external\\n        payable\\n        virtual\\n        ensure(params.deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        if (params.path[0] != WETH) revert InvalidPath();\\n        amounts = getAmountsOut(msg.value, params.path, params.fees);\\n        if (amounts[amounts.length - 1] < params.amountOutMin) {\\n            revert InsufficientOutputAmount();\\n        }\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(\\n            IWETH(WETH).transfer(\\n                pairFor(params.path[0], params.path[1], params.fees[0]),\\n                amounts[0]\\n            )\\n        );\\n        if (\\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\\n        ) {\\n            revert InsufficientMaxFee();\\n        }\\n    }\\n\\n    /// @notice Receive an exact amount of ETH for as few input tokens as possible\\n    /// @param params The parameters necessary for the swap, encoded as `swapTokensForExactETHParams` in calldata\\n    // @param amountOut The amount of ETH to receive\\n    // @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts\\n    // @param maxFee Maximum fees to be paid\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    /// @return amounts The input token amount and all subsequent output token amounts\\n    function swapTokensForExactETH(swapTokensForExactETHParams calldata params)\\n        external\\n        virtual\\n        ensure(params.deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        if (params.path[params.path.length - 1] != WETH) revert InvalidPath();\\n        uint256 amountInMax = params.path[0] == antfarmToken\\n            ? (params.amountInMax * (1000 + params.fees[0])) / 1000\\n            : params.amountInMax;\\n        amounts = getAmountsIn(params.amountOut, params.path, params.fees);\\n        if (amounts[0] > amountInMax) revert ExcessiveInputAmount();\\n        TransferHelper.safeTransferFrom(\\n            params.path[0],\\n            msg.sender,\\n            pairFor(params.path[0], params.path[1], params.fees[0]),\\n            amounts[0]\\n        );\\n        if (\\n            _swap(amounts, params.path, params.fees, address(this)) >\\n            params.maxFee\\n        ) {\\n            revert InsufficientMaxFee();\\n        }\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(params.to, amounts[amounts.length - 1]);\\n    }\\n\\n    /// @notice Swaps an exact amount of tokens for as much ETH as possible\\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForETHParams` in calldata\\n    // @param amountIn The amount of input tokens to send\\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\\n    // @param maxFee Maximum fees to be paid\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    /// @return amounts The input token amount and all subsequent output token amounts\\n    function swapExactTokensForETH(swapExactTokensForETHParams calldata params)\\n        external\\n        virtual\\n        ensure(params.deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        uint256 amountIn = params.path[0] == antfarmToken\\n            ? (params.amountIn * (1000 + params.fees[0])) / 1000\\n            : params.amountIn;\\n        if (params.path[params.path.length - 1] != WETH) revert InvalidPath();\\n        amounts = getAmountsOut(amountIn, params.path, params.fees);\\n        if (amounts[amounts.length - 1] < params.amountOutMin) {\\n            revert InsufficientOutputAmount();\\n        }\\n        TransferHelper.safeTransferFrom(\\n            params.path[0],\\n            msg.sender,\\n            pairFor(params.path[0], params.path[1], params.fees[0]),\\n            amounts[0]\\n        );\\n        if (\\n            _swap(amounts, params.path, params.fees, address(this)) >\\n            params.maxFee\\n        ) {\\n            revert InsufficientMaxFee();\\n        }\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(params.to, amounts[amounts.length - 1]);\\n    }\\n\\n    /// @notice Receive an exact amount of tokens for as little ETH as possible\\n    /// @param params The parameters necessary for the swap, encoded as `swapETHForExactTokensParams` in calldata\\n    // @param amountOut The amount of tokens to receive\\n    // @param maxFee Maximum fees to be paid\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    /// @return amounts The input token amount and all subsequent output token amounts\\n    function swapETHForExactTokens(swapETHForExactTokensParams calldata params)\\n        external\\n        payable\\n        virtual\\n        ensure(params.deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        if (params.path[0] != WETH) revert InvalidPath();\\n        amounts = getAmountsIn(params.amountOut, params.path, params.fees);\\n        if (amounts[0] > msg.value) revert ExcessiveInputAmount();\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(\\n            IWETH(WETH).transfer(\\n                pairFor(params.path[0], params.path[1], params.fees[0]),\\n                amounts[0]\\n            )\\n        );\\n        if (\\n            _swap(amounts, params.path, params.fees, params.to) > params.maxFee\\n        ) {\\n            revert InsufficientMaxFee();\\n        }\\n        // refund dust ETH if any\\n        if (msg.value > amounts[0])\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    /// @notice Identical to swapExactTokensForTokens, but succeeds for tokens that take a fee on transfer\\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForTokensParams` in calldata\\n    // @param amountIn The amount of input tokens to send\\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        swapExactTokensForTokensParams calldata params\\n    ) external virtual ensure(params.deadline) {\\n        TransferHelper.safeTransferFrom(\\n            params.path[0],\\n            msg.sender,\\n            pairFor(params.path[0], params.path[1], params.fees[0]),\\n            params.amountIn\\n        );\\n        uint256 balanceBefore = IERC20(params.path[params.path.length - 1])\\n            .balanceOf(params.to);\\n        swapParams memory sParams = swapParams(\\n            params.path,\\n            params.fees,\\n            params.to\\n        );\\n        if (_swapSupportingFeeOnTransferTokens(sParams) > params.maxFee) {\\n            revert InsufficientMaxFee();\\n        }\\n        if (\\n            IERC20(params.path[params.path.length - 1]).balanceOf(params.to) -\\n                balanceBefore <\\n            params.amountOutMin\\n        ) {\\n            revert InsufficientOutputAmount();\\n        }\\n    }\\n\\n    /// @notice Identical to swapExactETHForTokens, but succeeds for tokens that take a fee on transfer\\n    /// @param params The parameters necessary for the swap, encoded as `swapExactETHForTokensParams` in calldata\\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        swapExactETHForTokensParams calldata params\\n    ) external payable virtual ensure(params.deadline) {\\n        if (params.path[0] != WETH) revert InvalidPath();\\n        uint256 amountIn = msg.value;\\n        IWETH(WETH).deposit{value: amountIn}();\\n        assert(\\n            IWETH(WETH).transfer(\\n                pairFor(params.path[0], params.path[1], params.fees[0]),\\n                amountIn\\n            )\\n        );\\n        uint256 balanceBefore = IERC20(params.path[params.path.length - 1])\\n            .balanceOf(params.to);\\n        swapParams memory sParams = swapParams(\\n            params.path,\\n            params.fees,\\n            params.to\\n        );\\n        if (_swapSupportingFeeOnTransferTokens(sParams) > params.maxFee) {\\n            revert InsufficientMaxFee();\\n        }\\n        if (\\n            IERC20(params.path[params.path.length - 1]).balanceOf(params.to) -\\n                balanceBefore <\\n            params.amountOutMin\\n        ) {\\n            revert InsufficientOutputAmount();\\n        }\\n    }\\n\\n    /// @notice Identical to swapExactTokensForETH, but succeeds for tokens that take a fee on transfer\\n    /// @param params The parameters necessary for the swap, encoded as `swapExactTokensForETHParams` in calldata\\n    // @param amountIn The amount of input tokens to send\\n    // @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\\n    // @param path An array of token addresses\\n    // @param fees Associated fee for each two token addresses within the path\\n    // @param to Recipient of the output tokens\\n    // @param deadline Unix timestamp after which the transaction will revert\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        swapExactTokensForETHParams calldata params\\n    ) external virtual ensure(params.deadline) {\\n        if (params.path[params.path.length - 1] != WETH) revert InvalidPath();\\n        TransferHelper.safeTransferFrom(\\n            params.path[0],\\n            msg.sender,\\n            pairFor(params.path[0], params.path[1], params.fees[0]),\\n            params.amountIn\\n        );\\n        swapParams memory sParams = swapParams(\\n            params.path,\\n            params.fees,\\n            address(this)\\n        );\\n        if (_swapSupportingFeeOnTransferTokens(sParams) > params.maxFee) {\\n            revert InsufficientMaxFee();\\n        }\\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\\n        if (amountOut < params.amountOutMin) revert InsufficientOutputAmount();\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(params.to, amountOut);\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address tokenA,\\n        address tokenB,\\n        uint16 fee\\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IAntfarmPair(\\n            pairFor(tokenA, tokenB, fee)\\n        ).getReserves();\\n        (reserveA, reserveB) = tokenA == token0\\n            ? (reserve0, reserve1)\\n            : (reserve1, reserve0);\\n    }\\n\\n    // SWAP\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory path,\\n        uint16[] memory fees,\\n        address _to\\n    ) internal virtual returns (uint256 totalFee) {\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            uint16 fee = fees[i];\\n            IAntfarmPair antfarmPair = IAntfarmPair(\\n                pairFor(input, output, fee)\\n            );\\n\\n            (address token0, ) = sortTokens(input, output);\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint256(0), amounts[i + 1])\\n                : (amounts[i + 1], uint256(0));\\n\\n            {\\n                uint256 amountIn = amounts[i];\\n\\n                if (input == antfarmToken) {\\n                    totalFee = totalFee + ((amountIn * fee) / (1000 + fee));\\n                } else if (output == antfarmToken) {\\n                    totalFee =\\n                        totalFee +\\n                        ((amounts[i + 1] * fee) / (1000 - fee));\\n                } else {\\n                    uint256 feeToPay = antfarmPair.getFees(\\n                        amount0Out,\\n                        input == token0 ? amountIn : uint256(0),\\n                        amount1Out,\\n                        input == token0 ? uint256(0) : amountIn\\n                    );\\n\\n                    TransferHelper.safeTransferFrom(\\n                        antfarmToken,\\n                        msg.sender,\\n                        address(antfarmPair),\\n                        feeToPay\\n                    );\\n\\n                    totalFee = totalFee + feeToPay;\\n                }\\n            }\\n\\n            address to = i < path.length - 2\\n                ? pairFor(output, path[i + 2], fees[i + 1])\\n                : _to;\\n            antfarmPair.swap(amount0Out, amount1Out, to);\\n        }\\n    }\\n\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\n    function _swapSupportingFeeOnTransferTokens(swapParams memory sParams)\\n        internal\\n        virtual\\n        returns (uint256 totalFee)\\n    {\\n        for (uint256 i; i < sParams.path.length - 1; i++) {\\n            (address input, address output) = (\\n                sParams.path[i],\\n                sParams.path[i + 1]\\n            );\\n            uint16 fee = sParams.fees[i];\\n            IAntfarmPair antfarmPair = IAntfarmPair(\\n                pairFor(input, output, fee)\\n            );\\n\\n            (address token0, ) = sortTokens(input, output);\\n\\n            uint256 amountIn;\\n            uint256 amountOut;\\n            {\\n                (uint256 reserve0, uint256 reserve1, ) = antfarmPair\\n                    .getReserves();\\n                (uint256 reserveIn, uint256 reserveOut) = input == token0\\n                    ? (reserve0, reserve1)\\n                    : (reserve1, reserve0);\\n\\n                amountIn =\\n                    IERC20(input).balanceOf(address(antfarmPair)) -\\n                    reserveIn;\\n\\n                if (input == antfarmToken) {\\n                    amountOut = getAmountOut(\\n                        (amountIn * 1000) / (1000 + fee),\\n                        reserveIn,\\n                        reserveOut\\n                    );\\n                } else if (output == antfarmToken) {\\n                    amountOut =\\n                        (getAmountOut(amountIn, reserveIn, reserveOut) *\\n                            (1000 - fee)) /\\n                        1000;\\n                } else {\\n                    amountOut = getAmountOut(amountIn, reserveIn, reserveOut);\\n                }\\n            }\\n\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint256(0), amountOut)\\n                : (amountOut, uint256(0));\\n\\n            if (input == antfarmToken) {\\n                totalFee = totalFee + ((amountIn * fee) / (1000 + fee));\\n            } else if (output == antfarmToken) {\\n                totalFee = totalFee + ((amountIn * fee) / 1000);\\n            } else {\\n                uint256 feeToPay = antfarmPair.getFees(\\n                    amount0Out,\\n                    input == token0 ? amountIn : uint256(0),\\n                    amount1Out,\\n                    input == token0 ? uint256(0) : amountIn\\n                );\\n\\n                TransferHelper.safeTransferFrom(\\n                    antfarmToken,\\n                    msg.sender,\\n                    address(antfarmPair),\\n                    feeToPay\\n                );\\n\\n                totalFee = totalFee + feeToPay;\\n            }\\n\\n            address to = i < sParams.path.length - 2\\n                ? pairFor(output, sParams.path[i + 2], sParams.fees[i + 1])\\n                : sParams.to;\\n            antfarmPair.swap(amount0Out, amount1Out, to);\\n        }\\n    }\\n\\n    // **** LIBRARY FUNCTIONS ADDED INTO THE CONTRACT ****\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB)\\n        internal\\n        view\\n        returns (address token0, address token1)\\n    {\\n        if (tokenA == tokenB) revert IdenticalAddresses();\\n        if (tokenA == antfarmToken || tokenB == antfarmToken) {\\n            (token0, token1) = tokenA == antfarmToken\\n                ? (antfarmToken, tokenB)\\n                : (antfarmToken, tokenA);\\n            if (token1 == address(0)) revert ZeroAddress();\\n        } else {\\n            (token0, token1) = tokenA < tokenB\\n                ? (tokenA, tokenB)\\n                : (tokenB, tokenA);\\n            if (token0 == address(0)) revert ZeroAddress();\\n        }\\n    }\\n\\n    /// @notice Calculates the CREATE2 address for a pair without making any external calls\\n    /// @param tokenA Token0 from the AntfarmPair\\n    /// @param tokenB Token1 from the AntfarmPair\\n    /// @param fee Associated fee to the AntfarmPair\\n    /// @return pair The CREATE2 address for the desired AntFarmPair\\n    function pairFor(\\n        address tokenA,\\n        address tokenB,\\n        uint16 fee\\n    ) public view returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            factory,\\n                            keccak256(\\n                                abi.encodePacked(\\n                                    token0,\\n                                    token1,\\n                                    fee,\\n                                    antfarmToken\\n                                )\\n                            ),\\n                            token0 == antfarmToken\\n                                ? hex\\\"99c189a5ef3d337612cf0ce2bd055546e23b91fea9e9e54201b23f14d763f333\\\" // AtfPair init code hash\\n                                : hex\\\"3b29ecd4cb06592a81cac4799fb24ef6a176fe95ecb50f304972882b150f3f3a\\\" // Pair init code hash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] memory path,\\n        uint16[] memory fees\\n    ) public view returns (uint256[] memory) {\\n        if (path.length < 2) revert InvalidPath();\\n        uint256[] memory amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\\n                path[i],\\n                path[i + 1],\\n                fees[i]\\n            );\\n            if (path[i] == antfarmToken) {\\n                amounts[i + 1] = getAmountOut(\\n                    (amounts[i] * 1000) / (1000 + fees[i]),\\n                    reserveIn,\\n                    reserveOut\\n                );\\n            } else if (path[i + 1] == antfarmToken) {\\n                amounts[i + 1] =\\n                    (getAmountOut(amounts[i], reserveIn, reserveOut) *\\n                        (1000 - fees[i])) /\\n                    1000;\\n            } else {\\n                amounts[i + 1] = getAmountOut(\\n                    amounts[i],\\n                    reserveIn,\\n                    reserveOut\\n                );\\n            }\\n        }\\n        return amounts;\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] memory path,\\n        uint16[] memory fees\\n    ) public view returns (uint256[] memory) {\\n        if (path.length < 2) revert InvalidPath();\\n        uint256[] memory amounts = new uint256[](path.length);\\n        amounts[path.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\\n                path[i - 1],\\n                path[i],\\n                fees[i - 1]\\n            );\\n            if (path[i - 1] == antfarmToken) {\\n                amounts[i - 1] =\\n                    (getAmountIn(amounts[i], reserveIn, reserveOut) *\\n                        (1000 + fees[i - 1])) /\\n                    1000;\\n            } else if (path[i] == antfarmToken) {\\n                amounts[i - 1] = getAmountIn(\\n                    (amounts[i] * 1000) / (1000 - fees[i - 1]),\\n                    reserveIn,\\n                    reserveOut\\n                );\\n            } else {\\n                amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n            }\\n        }\\n        return amounts;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256) {\\n        if (amountIn == 0) revert InsufficientInputAmount();\\n        if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\\n        uint256 numerator = amountIn * reserveOut;\\n        uint256 denominator = reserveIn + amountIn;\\n        return numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256) {\\n        if (amountOut == 0) revert InsufficientOutputAmount();\\n        if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\\n        uint256 numerator = reserveIn * amountOut;\\n        uint256 denominator = reserveOut - amountOut;\\n        return (numerator / denominator) + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntfarmBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nimport \\\"./pair/IAntfarmPairState.sol\\\";\\nimport \\\"./pair/IAntfarmPairEvents.sol\\\";\\nimport \\\"./pair/IAntfarmPairActions.sol\\\";\\nimport \\\"./pair/IAntfarmPairDerivedState.sol\\\";\\n\\ninterface IAntfarmBase is\\n    IAntfarmPairState,\\n    IAntfarmPairEvents,\\n    IAntfarmPairActions,\\n    IAntfarmPairDerivedState\\n{}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntfarmFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IAntfarmFactory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint16 fee,\\n        uint256 allPairsLength\\n    );\\n\\n    function possibleFees(uint256) external view returns (uint16);\\n\\n    function allPairs(uint256) external view returns (address);\\n\\n    function antfarmToken() external view returns (address);\\n\\n    function getPairs(uint256 startIndex, uint256 numOfPairs)\\n        external\\n        view\\n        returns (address[] memory, uint256);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB,\\n        uint16 fee\\n    ) external view returns (address pair);\\n\\n    function feesForPair(\\n        address tokenA,\\n        address tokenB,\\n        uint256\\n    ) external view returns (uint16);\\n\\n    function getFeesForPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (uint16[8] memory fees);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        uint16 fee\\n    ) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntfarmPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nimport \\\"./IAntfarmBase.sol\\\";\\n\\ninterface IAntfarmPair is IAntfarmBase {\\n    /// @notice Initialize the pair\\n    /// @dev Can only be called by the factory\\n    function initialize(\\n        address,\\n        address,\\n        uint16,\\n        address\\n    ) external;\\n\\n    /// @notice The Antfarm token address\\n    /// @return address Address\\n    function antfarmToken() external view returns (address);\\n\\n    /// @notice The Oracle instance used to compute swap's fees\\n    /// @return AntfarmOracle Oracle instance\\n    function antfarmOracle() external view returns (address);\\n\\n    /// @notice Calcul fee to pay\\n    /// @param amount0Out The token0 amount going out of the pool\\n    /// @param amount0In The token0 amount going in the pool\\n    /// @param amount1Out The token1 amount going out of the pool\\n    /// @param amount1In The token1 amount going in the pool\\n    /// @return feeToPay Calculated fee to be paid\\n    function getFees(\\n        uint256 amount0Out,\\n        uint256 amount0In,\\n        uint256 amount1Out,\\n        uint256 amount1In\\n    ) external view returns (uint256 feeToPay);\\n\\n    /// @notice Check for the best Oracle to use to perform fee calculation for a swap\\n    /// @dev Returns address(0) if no better oracle is found.\\n    /// @param maxReserve Actual oracle reserve0\\n    /// @return bestOracle Address from the best oracle found\\n    function scanOracles(uint112 maxReserve)\\n        external\\n        view\\n        returns (address bestOracle);\\n\\n    /// @notice Update oracle for token\\n    /// @custom:usability Update the current Oracle with a more suitable one. Revert if the current Oracle is already the more suitable\\n    function updateOracle() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntfarmRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IAntfarmRouter {\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function antfarmToken() external view returns (address);\\n\\n    struct swapParams {\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n    }\\n\\n    struct swapExactTokensForTokensParams {\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        uint256 maxFee;\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n        uint256 deadline;\\n    }\\n\\n    function swapExactTokensForTokens(\\n        swapExactTokensForTokensParams calldata params\\n    ) external returns (uint256[] memory amounts);\\n\\n    struct swapTokensForExactTokensParams {\\n        uint256 amountOut;\\n        uint256 amountInMax;\\n        uint256 maxFee;\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n        uint256 deadline;\\n    }\\n\\n    function swapTokensForExactTokens(\\n        swapTokensForExactTokensParams calldata params\\n    ) external returns (uint256[] memory amounts);\\n\\n    struct swapExactETHForTokensParams {\\n        uint256 amountOutMin;\\n        uint256 maxFee;\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n        uint256 deadline;\\n    }\\n\\n    function swapExactETHForTokens(swapExactETHForTokensParams calldata params)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    struct swapTokensForExactETHParams {\\n        uint256 amountOut;\\n        uint256 amountInMax;\\n        uint256 maxFee;\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n        uint256 deadline;\\n    }\\n\\n    function swapTokensForExactETH(swapTokensForExactETHParams calldata params)\\n        external\\n        returns (uint256[] memory amounts);\\n\\n    struct swapExactTokensForETHParams {\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        uint256 maxFee;\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n        uint256 deadline;\\n    }\\n\\n    function swapExactTokensForETH(swapExactTokensForETHParams calldata params)\\n        external\\n        returns (uint256[] memory amounts);\\n\\n    struct swapETHForExactTokensParams {\\n        uint256 amountOut;\\n        uint256 maxFee;\\n        address[] path;\\n        uint16[] fees;\\n        address to;\\n        uint256 deadline;\\n    }\\n\\n    function swapETHForExactTokens(swapETHForExactTokensParams calldata params)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        swapExactTokensForTokensParams calldata params\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        swapExactETHForTokensParams calldata params\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        swapExactTokensForETHParams calldata params\\n    ) external;\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address tokenA,\\n        address tokenB,\\n        uint16 fee\\n    ) external view returns (uint256 reserveA, uint256 reserveB);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntfarmToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IAntfarmToken {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function burn(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pair/IAntfarmPairActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IAntfarmPairActions {\\n    /// @notice Mint liquidity for a specific position\\n    /// @dev Low-level function. Should be called from another contract which performs all necessary checks\\n    /// @param to The address to mint liquidity\\n    /// @param positionId The ID to store the position to allow multiple positions for a single address\\n    /// @return liquidity Minted liquidity\\n    function mint(address to, uint256 positionId)\\n        external\\n        returns (uint256 liquidity);\\n\\n    /// @notice Burn liquidity from a specific position\\n    /// @dev Low-level function. Should be called from another contract which performs all necessary checks\\n    /// @param to The address to return the liquidity to\\n    /// @param positionId The ID of the position to burn liquidity from\\n    /// @param liquidity Liquidity amount to be burned\\n    /// @return amount0 The token0 amount received from the liquidity burn\\n    /// @return amount1 The token1 amount received from the liquidity burn\\n    function burn(\\n        address to,\\n        uint256 liquidity,\\n        uint256 positionId\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap tokens\\n    /// @dev Low-level function. Should be called from another contract which performs all necessary checks\\n    /// @param amount0Out token0 amount to be swapped\\n    /// @param amount1Out token1 amount to be swapped\\n    /// @param to The address to send the swapped tokens\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to\\n    ) external;\\n\\n    /// @notice Force balances to match reserves\\n    /// @param to The address to send excessive tokens\\n    function skim(address to) external;\\n\\n    /// @notice Force reserves to match balances\\n    function sync() external;\\n\\n    /// @notice Claim dividends for a specific position\\n    /// @param to The address to receive claimed dividends\\n    /// @param positionId The ID of the position to claim\\n    /// @return claimedAmount The amount claimed\\n    function claimDividend(address to, uint256 positionId)\\n        external\\n        returns (uint256 claimedAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pair/IAntfarmPairDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IAntfarmPairDerivedState {\\n    /// @notice Get position LP tokens\\n    /// @param operator Position owner\\n    /// @param positionId ID of the position\\n    /// @return uint128 LP tokens owned by the operator\\n    function getPositionLP(address operator, uint256 positionId)\\n        external\\n        view\\n        returns (uint128);\\n\\n    /// @notice Get pair reserves\\n    /// @return reserve0 Reserve for token0\\n    /// @return reserve1 Reserve for token1\\n    /// @return blockTimestampLast Last block proceeded\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    /// @notice Get Dividend from a specific position\\n    /// @param operator The address used to get dividends\\n    /// @param positionId Specific position\\n    /// @return amount Dividends owned by the address\\n    function claimableDividends(address operator, uint256 positionId)\\n        external\\n        view\\n        returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pair/IAntfarmPairEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\ninterface IAntfarmPairEvents {\\n    /// @notice Emitted when a position's liquidity is removed\\n    /// @param sender The address that initiated the burn call\\n    /// @param amount0 The amount of token0 withdrawn\\n    /// @param amount1 The amount of token1 withdrawn\\n    /// @param to The address to send token0 & token1\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n\\n    /// @notice Emitted when liquidity is minted for a given position\\n    /// @param sender The address that initiated the mint call\\n    /// @param amount0 Required token0 for the minted liquidity\\n    /// @param amount1 Required token1 for the minted liquidity\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n\\n    /// @notice Emitted by the pool for any swaps between token0 and token1\\n    /// @param sender The address that initiated the swap call\\n    /// @param amount0In Amount of token0 sent to the pair\\n    /// @param amount1In Amount of token1 sent to the pair\\n    /// @param amount0Out Amount of token0 going out of the pair\\n    /// @param amount1Out Amount of token1 going out of the pair\\n    /// @param to Address to transfer the swapped amount\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n\\n    /// @notice Emitted by the pool for any call to Sync function\\n    /// @param reserve0 reserve0 updated from the pair\\n    /// @param reserve1 reserve1 updated from the pair\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pair/IAntfarmPairState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\nimport \\\"../IAntfarmToken.sol\\\";\\n\\ninterface IAntfarmPairState {\\n    /// @notice The contract that deployed the AntfarmPair, which must adhere to the IAntfarmFactory interface\\n    /// @return address The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the AntfarmPair, sorted by address\\n    /// @return address The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the AntfarmPair, sorted by address\\n    /// @return address The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice Fee associated to the AntfarmPair instance\\n    /// @return uint16 Fee\\n    function fee() external view returns (uint16);\\n\\n    /// @notice The LP tokens total circulating supply\\n    /// @return uint Total LP tokens\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice The AntFarmPair AntFarm's tokens cumulated fees\\n    /// @return uint Total Antfarm tokens\\n    function antfarmTokenReserve() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/fixedpoint/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    // credit for this implementation goes to\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\n        // however that code costs significantly more gas\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/fixedpoint/BitMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\nlibrary BitMath {\\n    // returns the 0 indexed position of the most significant bit of the input x\\n    // s.t. x >= 2**msb and x < 2**(msb+1)\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, \\\"BitMath::mostSignificantBit: zero\\\");\\n\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            r += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            r += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            r += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            r += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            r += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            r += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            r += 2;\\n        }\\n        if (x >= 0x2) r += 1;\\n    }\\n\\n    // returns the 0 indexed position of the least significant bit of the input x\\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, \\\"BitMath::leastSignificantBit: zero\\\");\\n\\n        r = 255;\\n        if (x & type(uint128).max > 0) {\\n            r -= 128;\\n        } else {\\n            x >>= 128;\\n        }\\n        if (x & type(uint64).max > 0) {\\n            r -= 64;\\n        } else {\\n            x >>= 64;\\n        }\\n        if (x & type(uint32).max > 0) {\\n            r -= 32;\\n        } else {\\n            x >>= 32;\\n        }\\n        if (x & type(uint16).max > 0) {\\n            r -= 16;\\n        } else {\\n            x >>= 16;\\n        }\\n        if (x & type(uint16).max > 0) {\\n            r -= 8;\\n        } else {\\n            x >>= 8;\\n        }\\n        if (x & 0xf > 0) {\\n            r -= 4;\\n        } else {\\n            x >>= 4;\\n        }\\n        if (x & 0x3 > 0) {\\n            r -= 2;\\n        } else {\\n            x >>= 2;\\n        }\\n        if (x & 0x1 > 0) r -= 1;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/fixedpoint/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport \\\"./FullMath.sol\\\";\\nimport \\\"./Babylonian.sol\\\";\\nimport \\\"./BitMath.sol\\\";\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 public constant RESOLUTION = 112;\\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\n        uint256 z = 0;\\n        require(y == 0 || (z = self._x * y) / y == self._x, \\\"FixedPoint::mul: overflow\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // multiply a UQ112x112 by an int and decode, returning an int\\n    // reverts on overflow\\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\\n        require(z < 2**255, \\\"FixedPoint::muli: overflow\\\");\\n        return y < 0 ? -int256(z) : int256(z);\\n    }\\n\\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\\n    // lossy\\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\n        if (self._x == 0 || other._x == 0) {\\n            return uq112x112(0);\\n        }\\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\\n\\n        // partial products\\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\\n\\n        // so the bit shift does not overflow\\n        require(upper <= type(uint112).max, \\\"FixedPoint::muluq: upper overflow\\\");\\n\\n        // this cannot exceed 256 bits, all values are 224 bits\\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\\n\\n        // so the cast does not overflow\\n        require(sum <= type(uint224).max, \\\"FixedPoint::muluq: sum overflow\\\");\\n\\n        return uq112x112(uint224(sum));\\n    }\\n\\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\n        require(other._x > 0, \\\"FixedPoint::divuq: division by zero\\\");\\n        if (self._x == other._x) {\\n            return uq112x112(uint224(Q112));\\n        }\\n        if (self._x <= type(uint144).max) {\\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\\n            require(value <= type(uint224).max, \\\"FixedPoint::divuq: overflow\\\");\\n            return uq112x112(uint224(value));\\n        }\\n\\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\\n        require(result <= type(uint224).max, \\\"FixedPoint::divuq: overflow\\\");\\n        return uq112x112(uint224(result));\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // can be lossy\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint::fraction: division by zero\\\");\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= type(uint144).max) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    // reverts on overflow\\n    // lossy\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, \\\"FixedPoint::reciprocal: reciprocal of zero\\\");\\n        require(self._x != 1, \\\"FixedPoint::reciprocal: overflow\\\");\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    // lossy between 0/1 and 40 bits\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        if (self._x <= type(uint144).max) {\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\n        }\\n\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\n        safeShiftBits -= safeShiftBits % 2;\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/fixedpoint/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC-BY-4.0\\npragma solidity >=0.8.0;\\n\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\n// license is CC-BY-4.0\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, type(uint256).max);\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & (type(uint256).max - d + 1) & d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * (((type(uint256).max - pow2 + 1) & pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n\\n        if (h == 0) return l / d;\\n\\n        require(h < d, \\\"FullMath: FULLDIV_OVERFLOW\\\");\\n        return fullDiv(l, h, d);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AntfarmRouterErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nerror Expired();\\nerror InsufficientOutputAmount();\\nerror InsufficientInputAmount();\\nerror InsufficientLiquidity();\\nerror InsufficientMaxFee();\\nerror ExcessiveInputAmount();\\nerror InvalidPath();\\nerror IdenticalAddresses();\\nerror ZeroAddress();\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_antfarmToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExcessiveInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdenticalAddresses\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientMaxFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPath\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antfarmToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapETHForExactTokensParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapExactETHForTokensParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapExactETHForTokensParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapExactTokensForETHParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapExactTokensForETHParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapExactTokensForTokensParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapExactTokensForTokensParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapTokensForExactETHParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"fees\",\"type\":\"uint16[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAntfarmRouter.swapTokensForExactTokensParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "AntfarmRouter",
    "CompilerVersion": "v0.8.10+commit.fc410830",
    "OptimizationUsed": "1",
    "Runs": "1000",
    "ConstructorArguments": "00000000000000000000000061f4ecd130291e5d5d7809a112f9f9081b8ed3a500000000000000000000000082af49447d8a07e3bd95bd0d56f35241523fbab1000000000000000000000000fb9fbcb328317123f5275cda30b6589d5841216b",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}