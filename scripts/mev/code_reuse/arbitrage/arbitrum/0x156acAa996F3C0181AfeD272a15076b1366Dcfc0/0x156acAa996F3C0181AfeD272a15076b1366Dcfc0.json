{
    "SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\ncontract Multicall {\r\n    uint private am;\r\n    address[] private uniV2Factories;\r\n    address[] private uniV3Factories = \r\n    [\r\n        0x1F98431c8aD98523631AE4a59f267346ea31F984\r\n    ];\r\n    address[] private kyberV3Factories =\r\n    [\r\n        0xC7a590291e07B9fe9E64b86c58fD8fC764308C4A\r\n    ];\r\n    uint16[] private uniV3Fees=[100,500,3000,10000];\r\n    uint16[] private kyberV3Fees=[8,40,1000];\r\n\r\n    struct RouteParams {\r\n        address tIn;\r\n        address tOut;\r\n        uint amIn;\r\n        uint amOut;\r\n        bytes[] callPath;\r\n    }\r\n\r\n    function uniswapV3FlashCallback(uint256 fee0,uint256 fee1,bytes calldata data) external {\r\n        fee0 += am; fee1 += am;\r\n        multicall(abi.decode(data, (bytes[])));\r\n        if(fee0 > fee1){\r\n            address token=IV3Pool(msg.sender).token0();\r\n            IERC20(token).transfer(msg.sender,fee0);\r\n            IERC20(token).transfer(tx.origin,am-fee0);\r\n        }\r\n        else{\r\n            address token=IV3Pool(msg.sender).token1();\r\n            IERC20(token).transfer(msg.sender,fee1);\r\n            IERC20(token).transfer(tx.origin,am-fee1);\r\n        }\r\n    }\r\n\r\n    function flashCallback(uint256 fee0,uint256 fee1,bytes calldata data) external {\r\n        fee0 += am; fee1 += am;\r\n        multicall(abi.decode(data, (bytes[])));\r\n        if(fee0 > fee1){\r\n            address token=IV3Pool(msg.sender).token0();\r\n            IERC20(token).transfer(msg.sender,fee0);\r\n            IERC20(token).transfer(tx.origin,am-fee0);\r\n        }\r\n        else{\r\n            address token=IV3Pool(msg.sender).token1();\r\n            IERC20(token).transfer(msg.sender,fee1);\r\n            IERC20(token).transfer(tx.origin,am-fee1);\r\n        }\r\n    }\r\n\r\n    function algebraFlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external{\r\n        fee0 += am; fee1 += am;\r\n        multicall(abi.decode(data, (bytes[])));\r\n        if(fee0 > fee1){\r\n            address token=IV3Pool(msg.sender).token0();\r\n            IERC20(token).transfer(msg.sender,fee0);\r\n            IERC20(token).transfer(tx.origin,am-fee0);\r\n        }\r\n        else{\r\n            address token=IV3Pool(msg.sender).token1();\r\n            IERC20(token).transfer(msg.sender,fee1);\r\n            IERC20(token).transfer(tx.origin,am-fee1);\r\n        }\r\n    }\r\n\r\n    function uniswapV3SwapCallback(int256 am0,int256 am1,bytes calldata) external {\r\n        if (am0 > am1) {\r\n            IERC20(IV3Pool(msg.sender).token0()).transfer(msg.sender,uint(am0));\r\n            am = uint(-am1);\r\n        } else {\r\n            IERC20(IV3Pool(msg.sender).token1()).transfer(msg.sender,uint(am1));\r\n            am = uint(-am0);\r\n        }\r\n    }\r\n\r\n    function algebraSwapCallback(int256 am0,int256 am1,bytes calldata) external {\r\n        if (am0 > am1) {\r\n            IERC20(IV3Pool(msg.sender).token0()).transfer(msg.sender,uint(am0));\r\n            am = uint(-am1);\r\n        } else {\r\n            IERC20(IV3Pool(msg.sender).token1()).transfer(msg.sender,uint(am1));\r\n            am = uint(-am0);\r\n        }\r\n    }\r\n\r\n    function swapCallback(int256 am0, int256 am1, bytes calldata) external {\r\n        if (am0 > am1) {\r\n            IERC20(IV3Pool(msg.sender).token0()).transfer(msg.sender,uint(am0));\r\n            am = uint(-am1);\r\n        } else {\r\n            IERC20(IV3Pool(msg.sender).token1()).transfer(msg.sender,uint(am1));\r\n            am = uint(-am0);\r\n        }\r\n    }\r\n\r\n    function uniV2(address pool, bool direc) public {\r\n        IERC20(direc ? IUniV2Pool(pool).token0() : IUniV2Pool(pool).token1()).transfer(pool, am);\r\n        (uint112 reserve0, uint112 reserve1, ) = IUniV2Pool(pool).getReserves();\r\n        am = (am * 997) / 1000;\r\n        am = direc ? (am * reserve1) / (reserve0 + am) : (am * reserve0) / (reserve1 + am);\r\n        IUniV2Pool(pool).swap(direc ? 0 : am,direc ? am : 0,address(this),\"\");\r\n    }\r\n\r\n    function uniV3(address pool, bool direc) public {\r\n        IUniV3Pool(pool).swap(address(this),direc,int(am),direc ? 4295128740 : 1461446703485210103287273052203988822378723970341,\"\");\r\n    }\r\n\r\n    function algebraV3(address pool, bool direc) public {\r\n        IAlgebraV3Pool(pool).swap(address(this),direc,int(am),direc ? 4295128740 : 1461446703485210103287273052203988822378723970341,\"\");\r\n    }\r\n\r\n    function kyberV3(address pool, bool direc) public {\r\n        IKyberV3Pool(pool).swap(address(this),int(am),direc,direc ? 4295128740 : 1461446703485210103287273052203988822378723970341,\"\");\r\n    }\r\n\r\n    function flashRoute(RouteParams calldata route,address flashPool) public returns(uint amOut){\r\n        am = route.amIn;\r\n        bool tIn_t0=IV3Pool(flashPool).token0()==route.tIn;\r\n        IV3Pool(flashPool).flash(address(this),tIn_t0 ? am : 0,tIn_t0 ? 0 : am,abi.encode(route.callPath));\r\n        amOut=am;\r\n        delete am;\r\n    }\r\n\r\n    function fundsRoute(RouteParams calldata route)public returns(uint amOut){\r\n        IERC20(route.tIn).transferFrom(msg.sender, address(this), route.amIn);\r\n        am = route.amIn;\r\n        multicall(route.callPath);\r\n        require(am>=route.amOut,\"amOut\");\r\n        IERC20(route.tOut).transfer(msg.sender, am);\r\n        amOut=am;\r\n        delete am;\r\n    }\r\n\r\n    function multicall(bytes[] memory callPath) public {\r\n        for (uint8 i = 0; i < callPath.length; i++) {\r\n            (bool success, ) = address(this).call(callPath[i]);\r\n            require(success, \"err\");\r\n        }\r\n    }\r\n\r\n    function addAddress(address[] memory myArray, address newItem) private pure returns (address[] memory newArray) {\r\n        newArray = new address[](myArray.length + 1);\r\n        for (uint8 i = 0; i < myArray.length; i++) \r\n            newArray[i] = myArray[i];\r\n        newArray[myArray.length] = newItem;\r\n    }\r\n\r\n    function addCall(bytes[] memory myArray, bytes memory newItem) private pure returns (bytes[] memory newArray) {\r\n        newArray = new bytes[](myArray.length + 1);\r\n        for (uint8 i = 0; i < myArray.length; i++)\r\n            newArray[i] = myArray[i];\r\n        newArray[myArray.length] = newItem;\r\n    }\r\n\r\n    function poolCall(address pool,bool direc) public pure returns (bytes memory){\r\n        return abi.encodeWithSignature(\"uniV3(address,bool)\", pool,direc);\r\n    }\r\n\r\n    function kyberV3PoolQuote(address pool, bool direc, uint256 amIn) public view returns (uint256 amOut) {\r\n        (uint160 sqrtPriceX96, , , ) = IKyberV3Pool(pool).getPoolState();\r\n        (uint128 liquidity,,) = IKyberV3Pool(pool).getLiquidityState();\r\n        uint256 token0VirtualReserves = uint(liquidity)*uint(2**96) / uint(sqrtPriceX96);\r\n        uint256 token1VirtualReserves = (uint(liquidity)*uint(sqrtPriceX96)) / uint(2**96);\r\n        amIn = amIn - (amIn * 500) / 1e6;\r\n        amOut = (amIn * (direc ? token1VirtualReserves : token0VirtualReserves)) / ((direc ? token0VirtualReserves : token1VirtualReserves) + amIn);\r\n    }\r\n\r\n    function uniV3PoolQuote(address pool, bool direc, uint256 amIn) public view returns (uint256 amOut) {\r\n        (uint160 sqrtPriceX96, , , , , , ) = IUniV3Pool(pool).slot0();\r\n        uint128 liquidity = IUniV3Pool(pool).liquidity();\r\n        uint256 token0VirtualReserves = uint(liquidity)*uint(2**96) / uint(sqrtPriceX96);\r\n        uint256 token1VirtualReserves = (uint(liquidity)*uint(sqrtPriceX96)) / uint(2**96);\r\n        amIn = amIn - (amIn * 500) / 1e6;\r\n        amOut = (amIn * (direc ? token1VirtualReserves : token0VirtualReserves)) / ((direc ? token0VirtualReserves : token1VirtualReserves) + amIn);\r\n    } \r\n\r\n    function uniV2PoolQuote(address pool, bool direc, uint256 amIn) public view returns (uint256 amOut) {\r\n       (uint112 reserve0, uint112 reserve1, ) = IUniV2Pool(pool).getReserves();\r\n        amIn = (amIn * 997) / 1000;\r\n        amOut = direc ? (amIn * reserve1) / (reserve0 + amIn) : (amIn * reserve0) / (reserve1 + amIn);\r\n    }\r\n\r\n    function getUniV3Pools(address tokenA,address tokenB) public view returns (address[] memory pools){\r\n        for (uint8 f=0 ; f<uniV3Factories.length ; f++) {\r\n            for (uint8 i=0 ; i<uniV3Fees.length ; i++) {\r\n                address pool=IV3Factory(uniV3Factories[f]).getPool(tokenA, tokenB, uniV3Fees[i]);\r\n                if(pool!=address(0)) pools = addAddress(pools,pool);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getKyberV3Pools(address tokenA,address tokenB) public view returns (address[] memory pools){\r\n        for (uint8 f=0 ; f<kyberV3Factories.length ; f++) {\r\n            for (uint8 i=0 ; i<kyberV3Fees.length ; i++) {\r\n                address pool=IV3Factory(kyberV3Factories[f]).getPool(tokenA, tokenB, kyberV3Fees[i]);\r\n                if(pool!=address(0)) pools = addAddress(pools,pool);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUniV2Pools(address tokenA,address tokenB) public view returns (address[] memory pools){\r\n        for (uint8 f=0 ; f<uniV2Factories.length ; f++) {\r\n            address pool=IV2Factory(uniV2Factories[f]).getPair(tokenA, tokenB);\r\n            if(pool!=address(0)) pools = addAddress(pools,pool);\r\n        }\r\n    }\r\n\r\n    function findPool(address tIn, address tOut,uint amIn) public view returns (uint amOut, bytes memory call) {\r\n        bool direc=tIn < tOut;\r\n        //uniswapV3\r\n        address[] memory pools = getUniV3Pools(tIn,tOut);\r\n        for (uint8 p = 0; p < pools.length; p++) {\r\n            uint _amOut = uniV3PoolQuote(pools[p], direc, amIn);\r\n            if (_amOut > amOut)\r\n                (amOut,call) = (_amOut,abi.encodeWithSignature(\"uniV3(address,bool)\", pools[p],direc));\r\n        }\r\n        //kyberswapV3\r\n        pools = getKyberV3Pools(tIn, tOut);\r\n        for (uint8 p = 0; p < pools.length; p++) {\r\n            uint _amOut = kyberV3PoolQuote(pools[p], direc, amIn);\r\n            if (_amOut > amOut) \r\n                (amOut,call) = (_amOut,abi.encodeWithSignature(\"kyberV3(address,bool)\", pools[p],direc));\r\n        }\r\n        //uniswapV2\r\n        pools = getUniV2Pools(tIn, tOut);\r\n        for (uint8 p = 0; p < pools.length; p++) {\r\n            uint _amOut = uniV2PoolQuote(pools[p], direc, amIn);\r\n            if (_amOut > amOut) \r\n                (amOut,call) = (_amOut,abi.encodeWithSignature(\"uniV2(address,bool)\", pools[p],direc));\r\n        }\r\n    }\r\n\r\n    function findRoute(address tIn, address tOut, uint amIn, uint8 depth,address[] calldata tokens) public view returns (uint amOut, bytes[] memory callPath) {\r\n        amOut = amIn * ((tIn == tOut) ? 1 : 0);\r\n        if (depth > 0) {\r\n            depth--;\r\n            for (uint8 t = 0; t < tokens.length; t++) {\r\n                (uint amOutCon, bytes[] memory callPathCon) = findRoute(tIn, tokens[t], amIn, depth,tokens);\r\n                if (amOutCon > 0) {\r\n                    if(tokens[t] == tOut) (amOut,callPath)=(amOutCon,callPathCon);\r\n                    else{\r\n                        (uint _amOut,bytes memory call)=findPool(tokens[t], tOut,amOutCon);\r\n                        if (_amOut > amOut)\r\n                            (amOut,callPath) = (_amOut,addCall(callPathCon, call));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IV3Factory {\r\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\r\n}\r\n\r\ninterface IV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IPool {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface IV3Pool is IPool {\r\n    function flash(address recipient,uint256 amount0,uint256 amount1,bytes calldata data) external;\r\n}\r\n\r\ninterface IUniV2Pool is IPool {\r\n    function swap(uint amount0Out,uint amount1Out,address to,bytes calldata data) external;\r\n    function getReserves()external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IUniV3Pool is IV3Pool {\r\n    function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n    function fee() external view returns (uint24);\r\n    function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked);\r\n    function tickSpacing() external view returns (int24);\r\n    function liquidity() external view returns (uint128);\r\n}\r\n\r\ninterface IAlgebraV3Pool is IV3Pool {\r\n    function globalState() external view returns (uint160 price, int24 tick, uint16 feeZtO, uint16 feeOtZ, uint16 timepointIndex, uint8 communityFee, bool unlocked);\r\n    function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n}\r\n\r\ninterface IKyberV3Pool is IV3Pool {\r\n    function swap(address recipient,int256 swapQty,bool isToken0,uint160 limitSqrtP,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n    function swapFeeUnits() external view returns (uint24);\r\n    function getPoolState() external view returns (uint160 sqrtP,int24 currentTick,int24 nearestCurrentTick,bool locked);\r\n    function tickDistance() external view returns (int24);\r\n    function getLiquidityState() external view returns (uint128,uint128,uint128);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient,uint256 amount) external returns (bool);\r\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"algebraFlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"am0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"am1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"algebraSwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"algebraV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"}],\"name\":\"findPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"call\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"findRoute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Multicall.RouteParams\",\"name\":\"route\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"flashPool\",\"type\":\"address\"}],\"name\":\"flashRoute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Multicall.RouteParams\",\"name\":\"route\",\"type\":\"tuple\"}],\"name\":\"fundsRoute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getKyberV3Pools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getUniV2Pools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getUniV3Pools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"kyberV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"}],\"name\":\"kyberV3PoolQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"callPath\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"poolCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"am0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"am1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"swapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"uniV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"}],\"name\":\"uniV2PoolQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"}],\"name\":\"uniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direc\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amIn\",\"type\":\"uint256\"}],\"name\":\"uniV3PoolQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"am0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"am1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "Multicall",
    "CompilerVersion": "v0.8.18+commit.87f61d96",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://c6929f05fde0cb51c63dceadfe7143bf909f3bfe42c4d70b157f495822995e50"
}