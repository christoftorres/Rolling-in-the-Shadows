{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBalancerVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAsset.sol\\\";\\n\\n// https://docs.balancer.fi/reference/swaps/single-swap.html#swap-function\\n\\ninterface IBalancerVault {\\n    // function WETH() external view returns (address);\\n\\n    //BALANCER STRUCT\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    //BALANCER ENUM\\n    enum SwapKind {\\n        GIVEN_IN,\\n        GIVEN_OUT\\n    }\\n\\n    //BALANCER STRUCT\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    // function batchSwap(\\n    //     uint8 kind,\\n    //     SingleSwap[] swaps,\\n    //     address[] assets,\\n    //     FundManagement funds,\\n    //     int256[] limits,\\n    //     uint256 deadline\\n    // ) external returns (int256[] assetDeltas);\\n\\n    // function deregisterTokens(bytes32 poolId, address[] tokens) external;\\n\\n    // // function exitPool(\\n    // //     bytes32 poolId,\\n    // //     address sender,\\n    // //     address recipient,\\n    // //     tuple request\\n    // // ) external;\\n\\n    // function flashLoan(\\n    //     address recipient,\\n    //     address[] tokens,\\n    //     uint256[] amounts,\\n    //     bytes userData\\n    // ) external;\\n\\n    // function getActionId(bytes4 selector) external view returns (bytes32);\\n\\n    // function getAuthorizer() external view returns (address);\\n\\n    // function getDomainSeparator() external view returns (bytes32);\\n\\n    // function getInternalBalance(\\n    //     address user,\\n    //     address[] tokens\\n    // ) external view returns (uint256[] balances);\\n\\n    // function getNextNonce(address user) external view returns (uint256);\\n\\n    // function getPausedState()\\n    //     external\\n    //     view\\n    //     returns (\\n    //         bool paused,\\n    //         uint256 pauseWindowEndTime,\\n    //         uint256 bufferPeriodEndTime\\n    //     );\\n\\n    function getPool(bytes32 poolId) external view returns (address, uint8);\\n\\n    function getPoolTokenInfo(\\n        bytes32 poolId,\\n        address token\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        );\\n\\n    function getPoolTokens(\\n        bytes32 poolId\\n    )\\n        external\\n        view\\n        returns (\\n            address[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    // function getProtocolFeesCollector() external view returns (address);\\n\\n    // function hasApprovedRelayer(\\n    //     address user,\\n    //     address relayer\\n    // ) external view returns (bool);\\n\\n    // function joinPool(\\n    //     bytes32 poolId,\\n    //     address sender,\\n    //     address recipient,\\n    //     tuple request\\n    // ) external;\\n\\n    // function managePoolBalance(tuple[] ops) external;\\n\\n    // function manageUserBalance(tuple[] ops) external;\\n\\n    // function queryBatchSwap(\\n    //     uint8 kind,\\n    //     SingleSwap[] swaps,\\n    //     address[] assets,\\n    //     FundManagement funds\\n    // ) external returns (int256[]);\\n\\n    // function registerPool(uint8 specialization) external returns (bytes32);\\n\\n    // function registerTokens(\\n    //     bytes32 poolId,\\n    //     address[] tokens,\\n    //     address[] assetManagers\\n    // ) external;\\n\\n    // function setAuthorizer(address newAuthorizer) external;\\n\\n    // function setPaused(bool paused) external;\\n\\n    // function setRelayerApproval(\\n    //     address sender,\\n    //     address relayer,\\n    //     bool approved\\n    // ) external;\\n\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external returns (uint256 amountCalculated);\\n}\\n\\n//  {\\n//         pool: \\\"0x4e7f40cd37cee710f5e87ad72959d30ef8a01a5d00010000000000000000000b\\\",\\n//         tokenIn: \\\"0x2791bca1f2de4661ed88a30c99a7a9449aa84174\\\",\\n//         tokenOut: \\\"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\\\",\\n//         limitReturnAmount: \\\"0\\\",\\n//         swapAmount: \\\"12154711\\\",\\n//         amountOut: \\\"7396822524192005\\\",\\n//         exchange: \\\"balancer\\\",\\n//         poolLength: 4,\\n//         poolType: \\\"balancer-weighted\\\",\\n//         vault: \\\"0xba12222222228d8ba445958a75a0704d566bf2c8\\\",\\n//       },\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    // event Approval(\\n    //     address indexed owner,\\n    //     address indexed spender,\\n    //     uint256 value\\n    // );\\n    // event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    // function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    // function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLoanSimpleReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPoolAddressesProvider.sol\\\";\\nimport \\\"./IPool.sol\\\";\\n\\n// import {IPoolAddressesProvider} from \\\"../../interfaces/IPoolAddressesProvider.sol\\\";\\n// import {IPool} from \\\"../../interfaces/IPool.sol\\\";\\n\\n/**\\n * @title IFlashLoanSimpleReceiver\\n * @author Aave\\n * @notice Defines the basic interface of a flashloan-receiver contract.\\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n */\\ninterface IFlashLoanSimpleReceiver {\\n    /**\\n     * @notice Executes an operation after receiving the flash-borrowed asset\\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\\n     *      enough funds to repay and has approved the Pool to pull the total amount\\n     * @param asset The address of the flash-borrowed asset\\n     * @param amount The amount of the flash-borrowed asset\\n     * @param premium The fee of the flash-borrowed asset\\n     * @param initiator The address of the flashloan initiator\\n     * @param params The byte-encoded params passed when initiating the flashloan\\n     * @return True if the execution of the operation succeeds, false otherwise\\n     */\\n    function executeOperation(\\n        address asset,\\n        uint256 amount,\\n        uint256 premium,\\n        address initiator,\\n        bytes calldata params\\n    ) external returns (bool);\\n\\n    function ADDRESSES_PROVIDER()\\n        external\\n        view\\n        returns (IPoolAddressesProvider);\\n\\n    function POOL() external view returns (IPool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\nimport \\\"./IPoolAddressesProvider.sol\\\";\\nimport \\\"../libraries/DataTypes.sol\\\";\\n\\n// import {IPoolAddressesProvider} from \\\"./IPoolAddressesProvider.sol\\\";\\n// import {DataTypes} from \\\"../protocol/libraries/types/DataTypes.sol\\\";\\n\\n/**\\n * @title IPool\\n * @author Aave\\n * @notice Defines the basic interface for an Aave Pool.\\n */\\ninterface IPool {\\n    /**\\n     * @dev Emitted on mintUnbacked()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the supply\\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\\n     * @param amount The amount of supplied assets\\n     * @param referralCode The referral code used\\n     */\\n    event MintUnbacked(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted on backUnbacked()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param backer The address paying for the backing\\n     * @param amount The amount added as backing\\n     * @param fee The amount paid in fees\\n     */\\n    event BackUnbacked(\\n        address indexed reserve,\\n        address indexed backer,\\n        uint256 amount,\\n        uint256 fee\\n    );\\n\\n    /**\\n     * @dev Emitted on supply()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the supply\\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\\n     * @param amount The amount supplied\\n     * @param referralCode The referral code used\\n     */\\n    event Supply(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted on withdraw()\\n     * @param reserve The address of the underlying asset being withdrawn\\n     * @param user The address initiating the withdrawal, owner of aTokens\\n     * @param to The address that will receive the underlying\\n     * @param amount The amount to be withdrawn\\n     */\\n    event Withdraw(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n     * @param reserve The address of the underlying asset being borrowed\\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\n     * initiator of the transaction on flashLoan()\\n     * @param onBehalfOf The address that will be getting the debt\\n     * @param amount The amount borrowed out\\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\\n     * @param referralCode The referral code used\\n     */\\n    event Borrow(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        DataTypes.InterestRateMode interestRateMode,\\n        uint256 borrowRate,\\n        uint16 indexed referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted on repay()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The beneficiary of the repayment, getting his debt reduced\\n     * @param repayer The address of the user initiating the repay(), providing the funds\\n     * @param amount The amount repaid\\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\\n     */\\n    event Repay(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed repayer,\\n        uint256 amount,\\n        bool useATokens\\n    );\\n\\n    /**\\n     * @dev Emitted on swapBorrowRateMode()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user swapping his rate mode\\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\n     */\\n    event SwapBorrowRateMode(\\n        address indexed reserve,\\n        address indexed user,\\n        DataTypes.InterestRateMode interestRateMode\\n    );\\n\\n    /**\\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param totalDebt The total isolation mode debt for the reserve\\n     */\\n    event IsolationModeTotalDebtUpdated(\\n        address indexed asset,\\n        uint256 totalDebt\\n    );\\n\\n    /**\\n     * @dev Emitted when the user selects a certain asset category for eMode\\n     * @param user The address of the user\\n     * @param categoryId The category id\\n     */\\n    event UserEModeSet(address indexed user, uint8 categoryId);\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     */\\n    event ReserveUsedAsCollateralEnabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     */\\n    event ReserveUsedAsCollateralDisabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on rebalanceStableBorrowRate()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user for which the rebalance has been executed\\n     */\\n    event RebalanceStableBorrowRate(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on flashLoan()\\n     * @param target The address of the flash loan receiver contract\\n     * @param initiator The address initiating the flash loan\\n     * @param asset The address of the asset being flash borrowed\\n     * @param amount The amount flash borrowed\\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\\n     * @param premium The fee flash borrowed\\n     * @param referralCode The referral code used\\n     */\\n    event FlashLoan(\\n        address indexed target,\\n        address initiator,\\n        address indexed asset,\\n        uint256 amount,\\n        DataTypes.InterestRateMode interestRateMode,\\n        uint256 premium,\\n        uint16 indexed referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted when a borrower is liquidated.\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\\n     * @param liquidator The address of the liquidator\\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     */\\n    event LiquidationCall(\\n        address indexed collateralAsset,\\n        address indexed debtAsset,\\n        address indexed user,\\n        uint256 debtToCover,\\n        uint256 liquidatedCollateralAmount,\\n        address liquidator,\\n        bool receiveAToken\\n    );\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated.\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param liquidityRate The next liquidity rate\\n     * @param stableBorrowRate The next stable borrow rate\\n     * @param variableBorrowRate The next variable borrow rate\\n     * @param liquidityIndex The next liquidity index\\n     * @param variableBorrowIndex The next variable borrow index\\n     */\\n    event ReserveDataUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    /**\\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\\n     * @param reserve The address of the reserve\\n     * @param amountMinted The amount minted to the treasury\\n     */\\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\\n\\n    /**\\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\\n     * @param asset The address of the underlying asset to mint\\n     * @param amount The amount to mint\\n     * @param onBehalfOf The address that will receive the aTokens\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function mintUnbacked(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\\n     * @param asset The address of the underlying asset to back\\n     * @param amount The amount to back\\n     * @param fee The amount paid in fees\\n     * @return The backed amount\\n     */\\n    function backUnbacked(\\n        address asset,\\n        uint256 amount,\\n        uint256 fee\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to supply\\n     * @param amount The amount to be supplied\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function supply(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n     * @param asset The address of the underlying asset to supply\\n     * @param amount The amount to be supplied\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param deadline The deadline timestamp that the permit is valid\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param permitV The V parameter of ERC712 permit sig\\n     * @param permitR The R parameter of ERC712 permit sig\\n     * @param permitS The S parameter of ERC712 permit sig\\n     */\\n    function supplyWithPermit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external;\\n\\n    /**\\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to The address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     */\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n     * @param asset The address of the underlying asset to borrow\\n     * @param amount The amount to be borrowed\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n     * if he has been given credit delegation allowance\\n     */\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @return The final amount repaid\\n     */\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @param deadline The deadline timestamp that the permit is valid\\n     * @param permitV The V parameter of ERC712 permit sig\\n     * @param permitR The R parameter of ERC712 permit sig\\n     * @param permitS The S parameter of ERC712 permit sig\\n     * @return The final amount repaid\\n     */\\n    function repayWithPermit(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        address onBehalfOf,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\\n     * equivalent debt tokens\\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\\n     * balance is not enough to cover the whole debt\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @return The final amount repaid\\n     */\\n    function repayWithATokens(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\\n     * @param asset The address of the underlying asset borrowed\\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\n     */\\n    function swapBorrowRateMode(\\n        address asset,\\n        uint256 interestRateMode\\n    ) external;\\n\\n    /**\\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\n     * - Users can be rebalanced if the following conditions are satisfied:\\n     *     1. Usage ratio is above 95%\\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\\n     * @param asset The address of the underlying asset borrowed\\n     * @param user The address of the user to be rebalanced\\n     */\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n    /**\\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\\n     * @param asset The address of the underlying asset supplied\\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\\n     */\\n    function setUserUseReserveAsCollateral(\\n        address asset,\\n        bool useAsCollateral\\n    ) external;\\n\\n    /**\\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     */\\n    function liquidationCall(\\n        address collateralAsset,\\n        address debtAsset,\\n        address user,\\n        uint256 debtToCover,\\n        bool receiveAToken\\n    ) external;\\n\\n    /**\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n     * into consideration. For further details please visit https://docs.aave.com/developers/\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\\n     * @param assets The addresses of the assets being flash-borrowed\\n     * @param amounts The amounts of the assets being flash-borrowed\\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata interestRateModes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n     * into consideration. For further details please visit https://docs.aave.com/developers/\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\n     * @param asset The address of the asset being flash-borrowed\\n     * @param amount The amount of the asset being flash-borrowed\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function flashLoanSimple(\\n        address receiverAddress,\\n        address asset,\\n        uint256 amount,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @notice Returns the user account data across all the reserves\\n     * @param user The address of the user\\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\\n     * @return currentLiquidationThreshold The liquidation threshold of the user\\n     * @return ltv The loan to value of The user\\n     * @return healthFactor The current health factor of the user\\n     */\\n    function getUserAccountData(\\n        address user\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralBase,\\n            uint256 totalDebtBase,\\n            uint256 availableBorrowsBase,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    /**\\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\\n     * interest rate strategy\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\\n     */\\n    function initReserve(\\n        address asset,\\n        address aTokenAddress,\\n        address stableDebtAddress,\\n        address variableDebtAddress,\\n        address interestRateStrategyAddress\\n    ) external;\\n\\n    /**\\n     * @notice Drop a reserve\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     */\\n    function dropReserve(address asset) external;\\n\\n    /**\\n     * @notice Updates the address of the interest rate strategy contract\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param rateStrategyAddress The address of the interest rate strategy contract\\n     */\\n    function setReserveInterestRateStrategyAddress(\\n        address asset,\\n        address rateStrategyAddress\\n    ) external;\\n\\n    /**\\n     * @notice Sets the configuration bitmap of the reserve as a whole\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param asset The address of the underlying asset of the reserve\\n     * @param configuration The new configuration bitmap\\n     */\\n    function setConfiguration(\\n        address asset,\\n        DataTypes.ReserveConfigurationMap calldata configuration\\n    ) external;\\n\\n    /**\\n     * @notice Returns the configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The configuration of the reserve\\n     */\\n    function getConfiguration(\\n        address asset\\n    ) external view returns (DataTypes.ReserveConfigurationMap memory);\\n\\n    /**\\n     * @notice Returns the configuration of the user across all the reserves\\n     * @param user The user address\\n     * @return The configuration of the user\\n     */\\n    function getUserConfiguration(\\n        address user\\n    ) external view returns (DataTypes.UserConfigurationMap memory);\\n\\n    /**\\n     * @notice Returns the normalized income of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve's normalized income\\n     */\\n    function getReserveNormalizedIncome(\\n        address asset\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the normalized variable debt per unit of asset\\n     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\\n     * \\\"dynamic\\\" variable index based on time, current stored index and virtual rate at the current\\n     * moment (approx. a borrower would get if opening a position). This means that is always used in\\n     * combination with variable debt supply/balances.\\n     * If using this function externally, consider that is possible to have an increasing normalized\\n     * variable debt that is not equivalent to how the variable debt index would be updated in storage\\n     * (e.g. only updates with non-zero variable debt supply)\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve normalized variable debt\\n     */\\n    function getReserveNormalizedVariableDebt(\\n        address asset\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the state and configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The state and configuration data of the reserve\\n     */\\n    function getReserveData(\\n        address asset\\n    ) external view returns (DataTypes.ReserveData memory);\\n\\n    /**\\n     * @notice Validates and finalizes an aToken transfer\\n     * @dev Only callable by the overlying aToken of the `asset`\\n     * @param asset The address of the underlying asset of the aToken\\n     * @param from The user from which the aTokens are transferred\\n     * @param to The user receiving the aTokens\\n     * @param amount The amount being transferred/withdrawn\\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\\n     */\\n    function finalizeTransfer(\\n        address asset,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 balanceFromBefore,\\n        uint256 balanceToBefore\\n    ) external;\\n\\n    /**\\n     * @notice Returns the list of the underlying assets of all the initialized reserves\\n     * @dev It does not include dropped reserves\\n     * @return The addresses of the underlying assets of the initialized reserves\\n     */\\n    function getReservesList() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\\n     * @return The address of the reserve associated with id\\n     */\\n    function getReserveAddressById(uint16 id) external view returns (address);\\n\\n    /**\\n     * @notice Returns the PoolAddressesProvider connected to this contract\\n     * @return The address of the PoolAddressesProvider\\n     */\\n    function ADDRESSES_PROVIDER()\\n        external\\n        view\\n        returns (IPoolAddressesProvider);\\n\\n    /**\\n     * @notice Updates the protocol fee on the bridging\\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\\n     */\\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\\n\\n    /**\\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\\n     * - A part is sent to aToken holders as extra, one time accumulated interest\\n     * - A part is collected by the protocol treasury\\n     * @dev The total premium is calculated on the total borrowed amount\\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\\n     * @dev Only callable by the PoolConfigurator contract\\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\\n     */\\n    function updateFlashloanPremiums(\\n        uint128 flashLoanPremiumTotal,\\n        uint128 flashLoanPremiumToProtocol\\n    ) external;\\n\\n    /**\\n     * @notice Configures a new category for the eMode.\\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\\n     * The category 0 is reserved as it's the default for volatile assets\\n     * @param id The id of the category\\n     * @param config The configuration of the category\\n     */\\n    function configureEModeCategory(\\n        uint8 id,\\n        DataTypes.EModeCategory memory config\\n    ) external;\\n\\n    /**\\n     * @notice Returns the data of an eMode category\\n     * @param id The id of the category\\n     * @return The configuration data of the category\\n     */\\n    function getEModeCategoryData(\\n        uint8 id\\n    ) external view returns (DataTypes.EModeCategory memory);\\n\\n    /**\\n     * @notice Allows a user to use the protocol in eMode\\n     * @param categoryId The id of the category\\n     */\\n    function setUserEMode(uint8 categoryId) external;\\n\\n    /**\\n     * @notice Returns the eMode the user is using\\n     * @param user The address of the user\\n     * @return The eMode id\\n     */\\n    function getUserEMode(address user) external view returns (uint256);\\n\\n    /**\\n     * @notice Resets the isolation mode total debt of the given asset to zero\\n     * @dev It requires the given asset has zero debt ceiling\\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\\n     */\\n    function resetIsolationModeTotalDebt(address asset) external;\\n\\n    /**\\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\\n     * @return The percentage of available liquidity to borrow, expressed in bps\\n     */\\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the total fee on flash loans\\n     * @return The total fee on flashloans\\n     */\\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\\n\\n    /**\\n     * @notice Returns the part of the bridge fees sent to protocol\\n     * @return The bridge fee sent to the protocol treasury\\n     */\\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the part of the flashloan fees sent to protocol\\n     * @return The flashloan fee sent to the protocol treasury\\n     */\\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\\n\\n    /**\\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\\n     * @return The maximum number of reserves supported\\n     */\\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\\n\\n    /**\\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\\n     * @param assets The list of reserves for which the minting needs to be executed\\n     */\\n    function mintToTreasury(address[] calldata assets) external;\\n\\n    /**\\n     * @notice Rescue and transfer tokens locked in this contract\\n     * @param token The address of the token\\n     * @param to The address of the recipient\\n     * @param amount The amount of token to transfer\\n     */\\n    function rescueTokens(address token, address to, uint256 amount) external;\\n\\n    /**\\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n     * @dev Deprecated: Use the `supply` function instead\\n     * @param asset The address of the underlying asset to supply\\n     * @param amount The amount to be supplied\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPoolAddressesProvider\\n * @author Aave\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\n */\\ninterface IPoolAddressesProvider {\\n    // /**\\n    //  * @dev Emitted when the market identifier is updated.\\n    //  * @param oldMarketId The old id of the market\\n    //  * @param newMarketId The new id of the market\\n    //  */\\n    // event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n    // /**\\n    //  * @dev Emitted when the pool is updated.\\n    //  * @param oldAddress The old address of the Pool\\n    //  * @param newAddress The new address of the Pool\\n    //  */\\n    // event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n    // /**\\n    //  * @dev Emitted when the pool configurator is updated.\\n    //  * @param oldAddress The old address of the PoolConfigurator\\n    //  * @param newAddress The new address of the PoolConfigurator\\n    //  */\\n    // event PoolConfiguratorUpdated(\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when the price oracle is updated.\\n    //  * @param oldAddress The old address of the PriceOracle\\n    //  * @param newAddress The new address of the PriceOracle\\n    //  */\\n    // event PriceOracleUpdated(\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when the ACL manager is updated.\\n    //  * @param oldAddress The old address of the ACLManager\\n    //  * @param newAddress The new address of the ACLManager\\n    //  */\\n    // event ACLManagerUpdated(\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when the ACL admin is updated.\\n    //  * @param oldAddress The old address of the ACLAdmin\\n    //  * @param newAddress The new address of the ACLAdmin\\n    //  */\\n    // event ACLAdminUpdated(\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when the price oracle sentinel is updated.\\n    //  * @param oldAddress The old address of the PriceOracleSentinel\\n    //  * @param newAddress The new address of the PriceOracleSentinel\\n    //  */\\n    // event PriceOracleSentinelUpdated(\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when the pool data provider is updated.\\n    //  * @param oldAddress The old address of the PoolDataProvider\\n    //  * @param newAddress The new address of the PoolDataProvider\\n    //  */\\n    // event PoolDataProviderUpdated(\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when a new proxy is created.\\n    //  * @param id The identifier of the proxy\\n    //  * @param proxyAddress The address of the created proxy contract\\n    //  * @param implementationAddress The address of the implementation contract\\n    //  */\\n    // event ProxyCreated(\\n    //     bytes32 indexed id,\\n    //     address indexed proxyAddress,\\n    //     address indexed implementationAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when a new non-proxied contract address is registered.\\n    //  * @param id The identifier of the contract\\n    //  * @param oldAddress The address of the old contract\\n    //  * @param newAddress The address of the new contract\\n    //  */\\n    // event AddressSet(\\n    //     bytes32 indexed id,\\n    //     address indexed oldAddress,\\n    //     address indexed newAddress\\n    // );\\n    // /**\\n    //  * @dev Emitted when the implementation of the proxy registered with id is updated\\n    //  * @param id The identifier of the contract\\n    //  * @param proxyAddress The address of the proxy contract\\n    //  * @param oldImplementationAddress The address of the old implementation contract\\n    //  * @param newImplementationAddress The address of the new implementation contract\\n    //  */\\n    // event AddressSetAsProxy(\\n    //     bytes32 indexed id,\\n    //     address indexed proxyAddress,\\n    //     address oldImplementationAddress,\\n    //     address indexed newImplementationAddress\\n    // );\\n    // /**\\n    //  * @notice Returns the id of the Aave market to which this contract points to.\\n    //  * @return The market id\\n    //  */\\n    // function getMarketId() external view returns (string memory);\\n    // /**\\n    //  * @notice Associates an id with a specific PoolAddressesProvider.\\n    //  * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\n    //  * identify and validate multiple Aave markets.\\n    //  * @param newMarketId The market id\\n    //  */\\n    // function setMarketId(string calldata newMarketId) external;\\n    // /**\\n    //  * @notice Returns an address by its identifier.\\n    //  * @dev The returned address might be an EOA or a contract, potentially proxied\\n    //  * @dev It returns ZERO if there is no registered address with the given id\\n    //  * @param id The id\\n    //  * @return The address of the registered for the specified id\\n    //  */\\n    // function getAddress(bytes32 id) external view returns (address);\\n    // /**\\n    //  * @notice General function to update the implementation of a proxy registered with\\n    //  * certain `id`. If there is no proxy registered, it will instantiate one and\\n    //  * set as implementation the `newImplementationAddress`.\\n    //  * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\n    //  * setter function, in order to avoid unexpected consequences\\n    //  * @param id The id\\n    //  * @param newImplementationAddress The address of the new implementation\\n    //  */\\n    // function setAddressAsProxy(\\n    //     bytes32 id,\\n    //     address newImplementationAddress\\n    // ) external;\\n    // /**\\n    //  * @notice Sets an address for an id replacing the address saved in the addresses map.\\n    //  * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\n    //  * @param id The id\\n    //  * @param newAddress The address to set\\n    //  */\\n    // function setAddress(bytes32 id, address newAddress) external;\\n    // /**\\n    //  * @notice Returns the address of the Pool proxy.\\n    //  * @return The Pool proxy address\\n    //  */\\n    function getPool() external view returns (address);\\n\\n    // /**\\n    //  * @notice Updates the implementation of the Pool, or creates a proxy\\n    //  * setting the new `pool` implementation when the function is called for the first time.\\n    //  * @param newPoolImpl The new Pool implementation\\n    //  */\\n    // function setPoolImpl(address newPoolImpl) external;\\n    // /**\\n    //  * @notice Returns the address of the PoolConfigurator proxy.\\n    //  * @return The PoolConfigurator proxy address\\n    //  */\\n    // function getPoolConfigurator() external view returns (address);\\n    // /**\\n    //  * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\n    //  * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\n    //  * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\n    //  */\\n    // function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n    // /**\\n    //  * @notice Returns the address of the price oracle.\\n    //  * @return The address of the PriceOracle\\n    //  */\\n    // function getPriceOracle() external view returns (address);\\n    // /**\\n    //  * @notice Updates the address of the price oracle.\\n    //  * @param newPriceOracle The address of the new PriceOracle\\n    //  */\\n    // function setPriceOracle(address newPriceOracle) external;\\n    // /**\\n    //  * @notice Returns the address of the ACL manager.\\n    //  * @return The address of the ACLManager\\n    //  */\\n    // function getACLManager() external view returns (address);\\n    // /**\\n    //  * @notice Updates the address of the ACL manager.\\n    //  * @param newAclManager The address of the new ACLManager\\n    //  */\\n    // function setACLManager(address newAclManager) external;\\n    // /**\\n    //  * @notice Returns the address of the ACL admin.\\n    //  * @return The address of the ACL admin\\n    //  */\\n    // function getACLAdmin() external view returns (address);\\n    // /**\\n    //  * @notice Updates the address of the ACL admin.\\n    //  * @param newAclAdmin The address of the new ACL admin\\n    //  */\\n    // function setACLAdmin(address newAclAdmin) external;\\n    // /**\\n    //  * @notice Returns the address of the price oracle sentinel.\\n    //  * @return The address of the PriceOracleSentinel\\n    //  */\\n    // function getPriceOracleSentinel() external view returns (address);\\n    // /**\\n    //  * @notice Updates the address of the price oracle sentinel.\\n    //  * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\n    //  */\\n    // function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n    // /**\\n    //  * @notice Returns the address of the data provider.\\n    //  * @return The address of the DataProvider\\n    //  */\\n    function getPoolDataProvider() external view returns (address);\\n\\n    struct tokensAAVE {\\n        string symbol;\\n        address token;\\n    }\\n\\n    function getAllReservesTokens() external view returns (tokensAAVE[] memory);\\n    // /**\\n    //  * @notice Updates the address of the data provider.\\n    //  * @param newDataProvider The address of the new DataProvider\\n    //  */\\n    // function setPoolDataProvider(address newDataProvider) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolCamelot.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPoolCamelot {\\n    // function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    // function FEE_DENOMINATOR() external view returns (uint256);\\n\\n    // function MAX_FEE_PERCENT() external view returns (uint256);\\n\\n    // function MINIMUM_LIQUIDITY() external view returns (uint256);\\n\\n    // function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    // function allowance(address, address) external view returns (uint256);\\n\\n    // function approve(address spender, uint256 value) external returns (bool);\\n\\n    // function balanceOf(address) external view returns (uint256);\\n\\n    // function burn(\\n    //     address to\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    // function decimals() external view returns (uint8);\\n\\n    // function drainWrongToken(address token, address to) external;\\n\\n    // function factory() external view returns (address);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn\\n    ) external view returns (uint256);\\n\\n    // function getReserves()\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint112 _reserve0,\\n    //         uint112 _reserve1,\\n    //         uint16 _token0FeePercent,\\n    //         uint16 _token1FeePercent\\n    //     );\\n\\n    // function initialize(address _token0, address _token1) external;\\n\\n    // function initialized() external view returns (bool);\\n\\n    // function kLast() external view returns (uint256);\\n\\n    // function mint(address to) external returns (uint256 liquidity);\\n\\n    // function name() external view returns (string);\\n\\n    // function nonces(address) external view returns (uint256);\\n\\n    // function pairTypeImmutable() external view returns (bool);\\n\\n    // function permit(\\n    //     address owner,\\n    //     address spender,\\n    //     uint256 value,\\n    //     uint256 deadline,\\n    //     uint8 v,\\n    //     bytes32 r,\\n    //     bytes32 s\\n    // ) external;\\n\\n    // function precisionMultiplier0() external view returns (uint256);\\n\\n    // function precisionMultiplier1() external view returns (uint256);\\n\\n    // function setFeePercent(\\n    //     uint16 newToken0FeePercent,\\n    //     uint16 newToken1FeePercent\\n    // ) external;\\n\\n    // function setPairTypeImmutable() external;\\n\\n    // function setStableSwap(\\n    //     bool stable,\\n    //     uint112 expectedReserve0,\\n    //     uint112 expectedReserve1\\n    // ) external;\\n\\n    // function skim(address to) external;\\n\\n    // function stableSwap() external view returns (bool);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes memory data\\n    ) external;\\n\\n    // function swap(\\n    //     uint256 amount0Out,\\n    //     uint256 amount1Out,\\n    //     address to,\\n    //     bytes memory data,\\n    //     address referrer\\n    // ) external;\\n\\n    // function symbol() external view returns (string);\\n\\n    // function sync() external;\\n\\n    function token0() external view returns (address);\\n\\n    // function token0FeePercent() external view returns (uint16);\\n\\n    function token1() external view returns (address);\\n\\n    // function token1FeePercent() external view returns (uint16);\\n\\n    // function totalSupply() external view returns (uint256);\\n\\n    // function transfer(address to, uint256 value) external returns (bool);\\n\\n    // function transferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256 value\\n    // ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolCurve.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// https://bia.is/tools/abi2solidity/\\n\\n// https://curve.readthedocs.io/ref-addresses.html\\ninterface IPoolCurve {\\n    function get_dy(\\n        uint256 i,\\n        uint256 j,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    function exchange(\\n        uint256 i,\\n        uint256 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    //   function exchange ( uint256 i, uint256 j, uint256 dx, uint256 min_dy ) external;\\n    //   function exchange ( uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth ) external;\\n    function fee() external view returns (uint256);\\n\\n    function exchange(\\n        uint256 i,\\n        uint256 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        bool use_eth\\n    ) external returns (uint256);\\n\\n    function exchange(\\n        uint256 i,\\n        uint256 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        bool use_eth,\\n        address receiver\\n    ) external returns (uint256);\\n\\n    // @view\\n    // @external\\n    // def get_dy(i: int128, j: int128, dx: uint256) -> uint256:\\n    //     \\\"\\\"\\\"\\n    //     @notice Calculate the current output dy given input dx\\n    //     @dev Index values can be found via the `coins` public getter method\\n    //     @param i Index value for the coin to send\\n    //     @param j Index valie of the coin to recieve\\n    //     @param dx Amount of `i` being exchanged\\n    //     @return Amount of `j` predicted\\n    //     \\\"\\\"\\\"\\\",\\\"name\\\":\\\"coins\\\",\\\"inputs\\\":[{\\\"name\\\":\\\"arg0\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"address\\\"}]\\n\\n    // function exchange(\\n    //     int128 i,\\n    //     int128 j,\\n    //     uint256 _dx,\\n    //     uint256 _min_dy\\n    // ) external returns (uint256);\\n\\n    // function exchange(\\n    //     int128 i,\\n    //     int128 j,\\n    //     uint256 _dx,\\n    //     uint256 _min_dy,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n\\n    function coins(uint256 arg0) external view returns (address);\\n\\n    //stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"balances\\\",\\\"inputs\\\":[{\\\"name\\\":\\\"arg0\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"\\n\\n    //     @external\\n    // @nonreentrant('lock')\\n    // def exchange(\\n    //     i: int128,\\n    //     j: int128,\\n    //     _dx: uint256,\\n    //     _min_dy: uint256,\\n    //     _receiver: address = msg.sender,\\n    // ) -> uint256:\\n    // nonpayable function exchange inputs [i int128,j int128, _dx uint256, _min_dy uint256,_receiver address],outputs type\\\":\\\"uint256\\\"}]},\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolDODO.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPoolDODO {\\n    // function _QUOTE_TOKEN_() external view returns (address);\\n\\n    // function _BASE_TOKEN_() external view returns (address);\\n\\n    function _BASE_PRICE_CUMULATIVE_LAST_() external view returns (uint256);\\n\\n    function _BASE_RESERVE_() external view returns (uint112);\\n\\n    function _BASE_TARGET_() external view returns (uint112);\\n\\n    // function _BASE_TOKEN_() external view returns (address);\\n\\n    function _BLOCK_TIMESTAMP_LAST_() external view returns (uint32);\\n\\n    function _IS_OPEN_TWAP_() external view returns (bool);\\n\\n    function _I_() external view returns (uint128);\\n\\n    // function _K_() external view returns (uint64);\\n\\n    // function _LP_FEE_RATE_() external view returns (uint64);\\n\\n    // function _MAINTAINER_() external view returns (address);\\n\\n    function _MT_FEE_RATE_MODEL_() external view returns (address);\\n\\n    // function _NEW_OWNER_() external view returns (address);\\n    //\\n    // function _OWNER_() external view returns (address);\\n\\n    function _QUOTE_RESERVE_() external view returns (uint112);\\n\\n    function _QUOTE_TARGET_() external view returns (uint112);\\n\\n    // function _QUOTE_TOKEN_() external view returns (address);\\n\\n    function _RState_() external view returns (uint32);\\n\\n    // function claimOwnership() external;\\n\\n    //   function flashLoan ( uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes data ) external;\\n    function getBaseInput() external view returns (uint256 input);\\n\\n    function getMidPrice() external view returns (uint256 midPrice);\\n\\n    //   function getPMMState (  ) external view returns ( tuple state );\\n    function getPMMStateForCall()\\n        external\\n        view\\n        returns (\\n            uint256 i,\\n            uint256 K,\\n            uint256 B,\\n            uint256 Q,\\n            uint256 B0,\\n            uint256 Q0,\\n            uint256 R\\n        );\\n\\n    function getQuoteInput() external view returns (uint256 input);\\n\\n    function getUserFeeRate(\\n        address user\\n    ) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\\n\\n    function getVaultReserve()\\n        external\\n        view\\n        returns (uint256 baseReserve, uint256 quoteReserve);\\n\\n    function init(\\n        address owner,\\n        address maintainer,\\n        address baseTokenAddress,\\n        address quoteTokenAddress,\\n        uint256 lpFeeRate,\\n        address mtFeeRateModel,\\n        uint256 k,\\n        uint256 i,\\n        bool isOpenTWAP\\n    ) external;\\n\\n    function initOwner(address newOwner) external;\\n\\n    function querySellBase(\\n        address trader,\\n        uint256 payBaseAmount\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 receiveQuoteAmount,\\n            uint256 mtFee,\\n            uint8 newRState,\\n            uint256 newBaseTarget\\n        );\\n\\n    function querySellQuote(\\n        address trader,\\n        uint256 payQuoteAmount\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 receiveBaseAmount,\\n            uint256 mtFee,\\n            uint8 newRState,\\n            uint256 newQuoteTarget\\n        );\\n\\n    function ratioSync() external;\\n\\n    function reset(\\n        address assetTo,\\n        uint256 newLpFeeRate,\\n        uint256 newI,\\n        uint256 newK,\\n        uint256 baseOutAmount,\\n        uint256 quoteOutAmount,\\n        uint256 minBaseReserve,\\n        uint256 minQuoteReserve\\n    ) external returns (bool);\\n\\n    function retrieve(address to, address token, uint256 amount) external;\\n\\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\\n\\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\\n\\n    function _BASE_BALANCE_() external view returns (uint256);\\n\\n    function _BASE_BALANCE_LIMIT_() external view returns (uint256);\\n\\n    function _BASE_CAPITAL_RECEIVE_QUOTE_() external view returns (uint256);\\n\\n    function _BASE_CAPITAL_TOKEN_() external view returns (address);\\n\\n    function _BASE_TOKEN_() external view returns (address);\\n\\n    function _BUYING_ALLOWED_() external view returns (bool);\\n\\n    function _CLAIMED_(address) external view returns (bool);\\n\\n    function _CLOSED_() external view returns (bool);\\n\\n    function _DEPOSIT_BASE_ALLOWED_() external view returns (bool);\\n\\n    function _DEPOSIT_QUOTE_ALLOWED_() external view returns (bool);\\n\\n    function _GAS_PRICE_LIMIT_() external view returns (uint256);\\n\\n    function _K_() external view returns (uint256);\\n\\n    function _LP_FEE_RATE_() external view returns (uint256);\\n\\n    function _MAINTAINER_() external view returns (address);\\n\\n    function _MT_FEE_RATE_() external view returns (uint256);\\n\\n    function _NEW_OWNER_() external view returns (address);\\n\\n    function _ORACLE_() external view returns (address);\\n\\n    function _OWNER_() external view returns (address);\\n\\n    function _QUOTE_BALANCE_() external view returns (uint256);\\n\\n    function _QUOTE_BALANCE_LIMIT_() external view returns (uint256);\\n\\n    function _QUOTE_CAPITAL_RECEIVE_BASE_() external view returns (uint256);\\n\\n    function _QUOTE_CAPITAL_TOKEN_() external view returns (address);\\n\\n    function _QUOTE_TOKEN_() external view returns (address);\\n\\n    function _R_STATUS_() external view returns (uint8);\\n\\n    function _SELLING_ALLOWED_() external view returns (bool);\\n\\n    function _SUPERVISOR_() external view returns (address);\\n\\n    function _TARGET_BASE_TOKEN_AMOUNT_() external view returns (uint256);\\n\\n    function _TARGET_QUOTE_TOKEN_AMOUNT_() external view returns (uint256);\\n\\n    function _TRADE_ALLOWED_() external view returns (bool);\\n\\n    function buyBaseToken(\\n        uint256 amount,\\n        uint256 maxPayQuote,\\n        bytes memory data\\n    ) external returns (uint256);\\n\\n    function claimAssets() external;\\n\\n    function claimOwnership() external;\\n\\n    function depositBase(uint256 amount) external returns (uint256);\\n\\n    function depositBaseTo(\\n        address to,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function depositQuote(uint256 amount) external returns (uint256);\\n\\n    function depositQuoteTo(\\n        address to,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function disableBaseDeposit() external;\\n\\n    function disableBuying() external;\\n\\n    function disableQuoteDeposit() external;\\n\\n    function disableSelling() external;\\n\\n    function disableTrading() external;\\n\\n    function donateBaseToken(uint256 amount) external;\\n\\n    function donateQuoteToken(uint256 amount) external;\\n\\n    function enableBaseDeposit() external;\\n\\n    function enableBuying() external;\\n\\n    function enableQuoteDeposit() external;\\n\\n    function enableSelling() external;\\n\\n    function enableTrading() external;\\n\\n    function finalSettlement() external;\\n\\n    function getBaseCapitalBalanceOf(\\n        address lp\\n    ) external view returns (uint256);\\n\\n    function getExpectedTarget()\\n        external\\n        view\\n        returns (uint256 baseTarget, uint256 quoteTarget);\\n\\n    function getLpBaseBalance(\\n        address lp\\n    ) external view returns (uint256 lpBalance);\\n\\n    function getLpQuoteBalance(\\n        address lp\\n    ) external view returns (uint256 lpBalance);\\n\\n    // function getMidPrice() external view returns (uint256 midPrice);\\n\\n    function getOraclePrice() external view returns (uint256);\\n\\n    function getQuoteCapitalBalanceOf(\\n        address lp\\n    ) external view returns (uint256);\\n\\n    function getTotalBaseCapital() external view returns (uint256);\\n\\n    function getTotalQuoteCapital() external view returns (uint256);\\n\\n    function getWithdrawBasePenalty(\\n        uint256 amount\\n    ) external view returns (uint256 penalty);\\n\\n    function getWithdrawQuotePenalty(\\n        uint256 amount\\n    ) external view returns (uint256 penalty);\\n\\n    function init(\\n        address owner,\\n        address supervisor,\\n        address maintainer,\\n        address baseToken,\\n        address quoteToken,\\n        address oracle,\\n        uint256 lpFeeRate,\\n        uint256 mtFeeRate,\\n        uint256 k,\\n        uint256 gasPriceLimit\\n    ) external;\\n\\n    function queryBuyBaseToken(\\n        uint256 amount\\n    ) external view returns (uint256 payQuote);\\n\\n    function querySellBaseToken(\\n        uint256 amount\\n    ) external view returns (uint256 receiveQuote);\\n\\n    function retrieve(address token, uint256 amount) external;\\n\\n    function sellBaseToken(\\n        uint256 amount,\\n        uint256 minReceiveQuote,\\n        bytes memory data\\n    ) external returns (uint256);\\n\\n    function setBaseBalanceLimit(uint256 newBaseBalanceLimit) external;\\n\\n    function setGasPriceLimit(uint256 newGasPriceLimit) external;\\n\\n    function setK(uint256 newK) external;\\n\\n    function setLiquidityProviderFeeRate(\\n        uint256 newLiquidityPorviderFeeRate\\n    ) external;\\n\\n    function setMaintainer(address newMaintainer) external;\\n\\n    function setMaintainerFeeRate(uint256 newMaintainerFeeRate) external;\\n\\n    function setOracle(address newOracle) external;\\n\\n    function setQuoteBalanceLimit(uint256 newQuoteBalanceLimit) external;\\n\\n    function setSupervisor(address newSupervisor) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    // function version() external pure returns (uint256);\\n\\n    function version() external pure returns (string memory);\\n\\n    function withdrawAllBase() external returns (uint256);\\n\\n    function withdrawAllBaseTo(address to) external returns (uint256);\\n\\n    function withdrawAllQuote() external returns (uint256);\\n\\n    function withdrawAllQuoteTo(address to) external returns (uint256);\\n\\n    function withdrawBase(uint256 amount) external returns (uint256);\\n\\n    function withdrawBaseTo(\\n        address to,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function withdrawQuote(uint256 amount) external returns (uint256);\\n\\n    function withdrawQuoteTo(\\n        address to,\\n        uint256 amount\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolGmx.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// https://bia.is/tools/abi2solidity/\\n\\n// https://curve.readthedocs.io/ref-addresses.html\\ninterface IPoolGmx {\\n    // function BASIS_POINTS_DIVISOR() external view returns (uint256);\\n\\n    // function FUNDING_RATE_PRECISION() external view returns (uint256);\\n\\n    // function MAX_FEE_BASIS_POINTS() external view returns (uint256);\\n\\n    // function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);\\n\\n    // function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);\\n\\n    // function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);\\n\\n    // function MIN_LEVERAGE() external view returns (uint256);\\n\\n    // function PRICE_PRECISION() external view returns (uint256);\\n\\n    // function USDG_DECIMALS() external view returns (uint256);\\n\\n    // function addRouter(address _router) external;\\n\\n    // function adjustForDecimals(\\n    //     uint256 _amount,\\n    //     address _tokenDiv,\\n    //     address _tokenMul\\n    // ) external view returns (uint256);\\n\\n    // function allWhitelistedTokens(uint256) external view returns (address);\\n\\n    // function allWhitelistedTokensLength() external view returns (uint256);\\n\\n    // function approvedRouters(address, address) external view returns (bool);\\n\\n    // function bufferAmounts(address) external view returns (uint256);\\n\\n    // function buyUSDG(\\n    //     address _token,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n\\n    // function clearTokenConfig(address _token) external;\\n\\n    // function cumulativeFundingRates(address) external view returns (uint256);\\n\\n    // function decreasePosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     uint256 _collateralDelta,\\n    //     uint256 _sizeDelta,\\n    //     bool _isLong,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n\\n    // function directPoolDeposit(address _token) external;\\n\\n    // function errorController() external view returns (address);\\n\\n    // function errors(uint256) external view returns (string);\\n\\n    // function feeReserves(address) external view returns (uint256);\\n\\n    // function fundingInterval() external view returns (uint256);\\n\\n    // function fundingRateFactor() external view returns (uint256);\\n\\n    // function getDelta(\\n    //     address _indexToken,\\n    //     uint256 _size,\\n    //     uint256 _averagePrice,\\n    //     bool _isLong,\\n    //     uint256 _lastIncreasedTime\\n    // ) external view returns (bool, uint256);\\n\\n    // function getFeeBasisPoints(\\n    //     address _token,\\n    //     uint256 _usdgDelta,\\n    //     uint256 _feeBasisPoints,\\n    //     uint256 _taxBasisPoints,\\n    //     bool _increment\\n    // ) external view returns (uint256);\\n\\n    // function getFundingFee(\\n    //     address _token,\\n    //     uint256 _size,\\n    //     uint256 _entryFundingRate\\n    // ) external view returns (uint256);\\n\\n    // function getGlobalShortDelta(\\n    //     address _token\\n    // ) external view returns (bool, uint256);\\n\\n    // function getMaxPrice(address _token) external view returns (uint256);\\n\\n    // function getMinPrice(address _token) external view returns (uint256);\\n\\n    // function getNextAveragePrice(\\n    //     address _indexToken,\\n    //     uint256 _size,\\n    //     uint256 _averagePrice,\\n    //     bool _isLong,\\n    //     uint256 _nextPrice,\\n    //     uint256 _sizeDelta,\\n    //     uint256 _lastIncreasedTime\\n    // ) external view returns (uint256);\\n\\n    // function getNextFundingRate(address _token) external view returns (uint256);\\n\\n    // function getNextGlobalShortAveragePrice(\\n    //     address _indexToken,\\n    //     uint256 _nextPrice,\\n    //     uint256 _sizeDelta\\n    // ) external view returns (uint256);\\n\\n    // function getPosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         bool,\\n    //         uint256\\n    //     );\\n\\n    // function getPositionDelta(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external view returns (bool, uint256);\\n\\n    // function getPositionFee(uint256 _sizeDelta) external view returns (uint256);\\n\\n    // function getPositionKey(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external pure returns (bytes32);\\n\\n    // function getPositionLeverage(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external view returns (uint256);\\n\\n    // function getRedemptionAmount(\\n    //     address _token,\\n    //     uint256 _usdgAmount\\n    // ) external view returns (uint256);\\n\\n    // function getRedemptionCollateral(\\n    //     address _token\\n    // ) external view returns (uint256);\\n\\n    // function getRedemptionCollateralUsd(\\n    //     address _token\\n    // ) external view returns (uint256);\\n\\n    // function getTargetUsdgAmount(\\n    //     address _token\\n    // ) external view returns (uint256);\\n\\n    // function getUtilisation(address _token) external view returns (uint256);\\n\\n    // function globalShortAveragePrices(address) external view returns (uint256);\\n\\n    // function globalShortSizes(address) external view returns (uint256);\\n\\n    // function gov() external view returns (address);\\n\\n    // function guaranteedUsd(address) external view returns (uint256);\\n\\n    // function hasDynamicFees() external view returns (bool);\\n\\n    // function inManagerMode() external view returns (bool);\\n\\n    // function inPrivateLiquidationMode() external view returns (bool);\\n\\n    // function includeAmmPrice() external view returns (bool);\\n\\n    // function increasePosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     uint256 _sizeDelta,\\n    //     bool _isLong\\n    // ) external;\\n\\n    // function initialize(\\n    //     address _router,\\n    //     address _usdg,\\n    //     address _priceFeed,\\n    //     uint256 _liquidationFeeUsd,\\n    //     uint256 _fundingRateFactor,\\n    //     uint256 _stableFundingRateFactor\\n    // ) external;\\n\\n    // function isInitialized() external view returns (bool);\\n\\n    // function isLeverageEnabled() external view returns (bool);\\n\\n    // function isLiquidator(address) external view returns (bool);\\n\\n    // function isManager(address) external view returns (bool);\\n\\n    // function isSwapEnabled() external view returns (bool);\\n\\n    // function lastFundingTimes(address) external view returns (uint256);\\n\\n    // function liquidatePosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong,\\n    //     address _feeReceiver\\n    // ) external;\\n\\n    // function liquidationFeeUsd() external view returns (uint256);\\n\\n    // function marginFeeBasisPoints() external view returns (uint256);\\n\\n    // function maxGasPrice() external view returns (uint256);\\n\\n    // function maxLeverage() external view returns (uint256);\\n\\n    // function maxUsdgAmounts(address) external view returns (uint256);\\n\\n    // function minProfitBasisPoints(address) external view returns (uint256);\\n\\n    // function minProfitTime() external view returns (uint256);\\n\\n    // function mintBurnFeeBasisPoints() external view returns (uint256);\\n\\n    // function poolAmounts(address) external view returns (uint256);\\n\\n    // function positions(\\n    //     bytes32\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256 size,\\n    //         uint256 collateral,\\n    //         uint256 averagePrice,\\n    //         uint256 entryFundingRate,\\n    //         uint256 reserveAmount,\\n    //         int256 realisedPnl,\\n    //         uint256 lastIncreasedTime\\n    //     );\\n\\n    // function priceFeed() external view returns (address);\\n\\n    // function removeRouter(address _router) external;\\n\\n    // function reservedAmounts(address) external view returns (uint256);\\n\\n    // function router() external view returns (address);\\n\\n    // function sellUSDG(\\n    //     address _token,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n\\n    // function setBufferAmount(address _token, uint256 _amount) external;\\n\\n    // function setError(uint256 _errorCode, string _error) external;\\n\\n    // function setErrorController(address _errorController) external;\\n\\n    // function setFees(\\n    //     uint256 _taxBasisPoints,\\n    //     uint256 _stableTaxBasisPoints,\\n    //     uint256 _mintBurnFeeBasisPoints,\\n    //     uint256 _swapFeeBasisPoints,\\n    //     uint256 _stableSwapFeeBasisPoints,\\n    //     uint256 _marginFeeBasisPoints,\\n    //     uint256 _liquidationFeeUsd,\\n    //     uint256 _minProfitTime,\\n    //     bool _hasDynamicFees\\n    // ) external;\\n\\n    // function setFundingRate(\\n    //     uint256 _fundingInterval,\\n    //     uint256 _fundingRateFactor,\\n    //     uint256 _stableFundingRateFactor\\n    // ) external;\\n\\n    // function setGov(address _gov) external;\\n\\n    // function setInManagerMode(bool _inManagerMode) external;\\n\\n    // function setInPrivateLiquidationMode(\\n    //     bool _inPrivateLiquidationMode\\n    // ) external;\\n\\n    // function setIsLeverageEnabled(bool _isLeverageEnabled) external;\\n\\n    // function setIsSwapEnabled(bool _isSwapEnabled) external;\\n\\n    // function setLiquidator(address _liquidator, bool _isActive) external;\\n\\n    // function setManager(address _manager, bool _isManager) external;\\n\\n    // function setMaxGasPrice(uint256 _maxGasPrice) external;\\n\\n    // function setMaxLeverage(uint256 _maxLeverage) external;\\n\\n    // function setPriceFeed(address _priceFeed) external;\\n\\n    // function setTokenConfig(\\n    //     address _token,\\n    //     uint256 _tokenDecimals,\\n    //     uint256 _tokenWeight,\\n    //     uint256 _minProfitBps,\\n    //     uint256 _maxUsdgAmount,\\n    //     bool _isStable,\\n    //     bool _isShortable\\n    // ) external;\\n\\n    // function setUsdgAmount(address _token, uint256 _amount) external;\\n\\n    // function shortableTokens(address) external view returns (bool);\\n\\n    // function stableFundingRateFactor() external view returns (uint256);\\n\\n    // function stableSwapFeeBasisPoints() external view returns (uint256);\\n\\n    // function stableTaxBasisPoints() external view returns (uint256);\\n\\n    // function stableTokens(address) external view returns (bool);\\n\\n    function swap(\\n        address _tokenIn,\\n        address _tokenOut,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    // function swapFeeBasisPoints() external view returns (uint256);\\n\\n    // function taxBasisPoints() external view returns (uint256);\\n\\n    // function tokenBalances(address) external view returns (uint256);\\n\\n    // function tokenDecimals(address) external view returns (uint256);\\n\\n    // function tokenToUsdMin(\\n    //     address _token,\\n    //     uint256 _tokenAmount\\n    // ) external view returns (uint256);\\n\\n    // function tokenWeights(address) external view returns (uint256);\\n\\n    // function totalTokenWeights() external view returns (uint256);\\n\\n    // function updateCumulativeFundingRate(address _token) external;\\n\\n    // function upgradeVault(\\n    //     address _newVault,\\n    //     address _token,\\n    //     uint256 _amount\\n    // ) external;\\n\\n    // function usdToToken(\\n    //     address _token,\\n    //     uint256 _usdAmount,\\n    //     uint256 _price\\n    // ) external view returns (uint256);\\n\\n    // function usdToTokenMax(\\n    //     address _token,\\n    //     uint256 _usdAmount\\n    // ) external view returns (uint256);\\n\\n    // function usdToTokenMin(\\n    //     address _token,\\n    //     uint256 _usdAmount\\n    // ) external view returns (uint256);\\n\\n    // function usdg() external view returns (address);\\n\\n    // function usdgAmounts(address) external view returns (uint256);\\n\\n    // function useSwapPricing() external view returns (bool);\\n\\n    // function validateLiquidation(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong,\\n    //     bool _raise\\n    // ) external view returns (uint256, uint256);\\n\\n    // function whitelistedTokenCount() external view returns (uint256);\\n\\n    // function whitelistedTokens(address) external view returns (bool);\\n\\n    // function withdrawFees(\\n    //     address _token,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolKyberswap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.4;\\n\\ninterface IPoolKyberswap {\\n    //https://polygonscan.com/address/0x546C79662E028B661dFB4767664d0273184E4dD1#code\\n    // function MINIMUM_LIQUIDITY() external view returns (uint256);\\n\\n    // function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    // function allowance(\\n    //     address owner,\\n    //     address spender\\n    // ) external view returns (uint256);\\n\\n    // function ampBps() external view returns (uint32);\\n\\n    // function approve(address spender, uint256 amount) external returns (bool);\\n\\n    // function balanceOf(address account) external view returns (uint256);\\n\\n    // function burn(\\n    //     address to\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    // function decimals() external view returns (uint8);\\n\\n    // function decreaseAllowance(\\n    //     address spender,\\n    //     uint256 subtractedValue\\n    // ) external returns (bool);\\n\\n    // function domainSeparator() external view returns (bytes32);\\n\\n    // function factory() external view returns (address);\\n\\n    // function getReserves()\\n    //     external\\n    //     view\\n    //     returns (uint112 _reserve0, uint112 _reserve1);\\n\\n    function getTradeInfo()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint112 _vReserve0,\\n            uint112 _vReserve1,\\n            uint256 _feeInPrecision\\n        );\\n\\n    // function increaseAllowance(\\n    //     address spender,\\n    //     uint256 addedValue\\n    // ) external returns (bool);\\n\\n    // function initialize(\\n    //     address _token0,\\n    //     address _token1,\\n    //     uint32 _ampBps,\\n    //     uint24 _feeUnits\\n    // ) external;\\n\\n    // function kLast() external view returns (uint256);\\n\\n    // function mint(address to) external returns (uint256 liquidity);\\n\\n    // function name() external view returns (string memory);\\n\\n    // function nonces(address) external view returns (uint256);\\n\\n    // function permit(\\n    //     address owner,\\n    //     address spender,\\n    //     uint256 value,\\n    //     uint256 deadline,\\n    //     uint8 v,\\n    //     bytes32 r,\\n    //     bytes32 s\\n    // ) external;\\n\\n    // function skim(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes memory callbackData\\n    ) external;\\n\\n    // function symbol() external view returns (string memory);\\n\\n    // function sync() external;\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    // function totalSupply() external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    // function transferFrom(\\n    //     address sender,\\n    //     address recipient,\\n    //     uint256 amount\\n    // ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolKyberswapV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.4;\\n\\ninterface IPoolKyberswapV2 {\\n    // function allowance(\\n    //     address owner,\\n    //     address spender\\n    // ) external view returns (uint256);\\n\\n    // function approve(address spender, uint256 amount) external returns (bool);\\n\\n    // function balanceOf(address account) external view returns (uint256);\\n\\n    // function burn(\\n    //     int24 tickLower,\\n    //     int24 tickUpper,\\n    //     uint128 qty\\n    // )\\n    //     external\\n    //     returns (uint256 qty0, uint256 qty1, uint256 feeGrowthInsideLast);\\n\\n    // function burnRTokens(\\n    //     uint256 _qty,\\n    //     bool isLogicalBurn\\n    // ) external returns (uint256 qty0, uint256 qty1);\\n\\n    // function decimals() external view returns (uint8);\\n\\n    // function decreaseAllowance(\\n    //     address spender,\\n    //     uint256 subtractedValue\\n    // ) external returns (bool);\\n\\n    // function factory() external view returns (address);\\n\\n    // function flash(\\n    //     address recipient,\\n    //     uint256 qty0,\\n    //     uint256 qty1,\\n    //     bytes memory data\\n    // ) external;\\n\\n    // function getFeeGrowthGlobal() external view returns (uint256);\\n\\n    // function getLiquidityState()\\n    //     external\\n    //     view\\n    //     returns (uint128 baseL, uint128 reinvestL, uint128 reinvestLLast);\\n\\n    function getPoolState()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtP,\\n            int24 currentTick,\\n            int24 nearestCurrentTick,\\n            bool locked\\n        );\\n\\n    // function getPositions(\\n    //     address owner,\\n    //     int24 tickLower,\\n    //     int24 tickUpper\\n    // ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\\n\\n    // function getSecondsPerLiquidityData()\\n    //     external\\n    //     view\\n    //     returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\\n\\n    // function getSecondsPerLiquidityInside(\\n    //     int24 tickLower,\\n    //     int24 tickUpper\\n    // ) external view returns (uint128 secondsPerLiquidityInside);\\n\\n    // function increaseAllowance(\\n    //     address spender,\\n    //     uint256 addedValue\\n    // ) external returns (bool);\\n\\n    // function initializedTicks(\\n    //     int24\\n    // ) external view returns (int24 previous, int24 next);\\n\\n    // function maxTickLiquidity() external view returns (uint128);\\n\\n    // function mint(\\n    //     address recipient,\\n    //     int24 tickLower,\\n    //     int24 tickUpper,\\n    //     int24[2] memory ticksPrevious,\\n    //     uint128 qty,\\n    //     bytes memory data\\n    // )\\n    //     external\\n    //     returns (uint256 qty0, uint256 qty1, uint256 feeGrowthInsideLast);\\n\\n    // function name() external view returns (string memory);\\n\\n    function swap(\\n        address recipient,\\n        int256 swapQty,\\n        bool isToken0,\\n        uint160 limitSqrtP,\\n        bytes memory data\\n    ) external returns (int256 deltaQty0, int256 deltaQty1);\\n\\n    // function swapFeeUnits() external view returns (uint24);\\n\\n    // function symbol() external view returns (string memory);\\n\\n    // function tickDistance() external view returns (int24);\\n\\n    // function ticks(\\n    //     int24\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint128 liquidityGross,\\n    //         int128 liquidityNet,\\n    //         uint256 feeGrowthOutside,\\n    //         uint128 secondsPerLiquidityOutside\\n    //     );\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    // function totalSupply() external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    // function transferFrom(\\n    //     address sender,\\n    //     address recipient,\\n    //     uint256 amount\\n    // ) external returns (bool);\\n\\n    // function unlockPool(\\n    //     uint160 initialSqrtP\\n    // ) external returns (uint256 qty0, uint256 qty1);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolMetavault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// https://bia.is/tools/abi2solidity/\\n\\n// https://curve.readthedocs.io/ref-addresses.html\\ninterface IPoolMetavault {\\n    // function BASIS_POINTS_DIVISOR() external view returns (uint256);\\n    // function FUNDING_RATE_PRECISION() external view returns (uint256);\\n    // function MAX_FEE_BASIS_POINTS() external view returns (uint256);\\n    // function MAX_FUNDING_RATE_FACTOR() external view returns (uint256);\\n    // function MAX_LIQUIDATION_FEE_USD() external view returns (uint256);\\n    // function MIN_FUNDING_RATE_INTERVAL() external view returns (uint256);\\n    // function MIN_LEVERAGE() external view returns (uint256);\\n    // function PRICE_PRECISION() external view returns (uint256);\\n    // function USDM_DECIMALS() external view returns (uint256);\\n    // function addRouter(address _router) external;\\n    // function adjustForDecimals(\\n    //     uint256 _amount,\\n    //     address _tokenDiv,\\n    //     address _tokenMul\\n    // ) external view returns (uint256);\\n    // function allWhitelistedTokens(uint256) external view returns (address);\\n    // function allWhitelistedTokensLength() external view returns (uint256);\\n    // function approvedRouters(address, address) external view returns (bool);\\n    // function bufferAmounts(address) external view returns (uint256);\\n    // function buyUSDM(\\n    //     address _token,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n    // function clearTokenConfig(address _token) external;\\n    // function cumulativeFundingRates(address) external view returns (uint256);\\n    // function decreasePosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     uint256 _collateralDelta,\\n    //     uint256 _sizeDelta,\\n    //     bool _isLong,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n    // function directPoolDeposit(address _token) external;\\n    // function errorController() external view returns (address);\\n    // function errors(uint256) external view returns (string);\\n    // function feeReserves(address) external view returns (uint256);\\n    // function fundingInterval() external view returns (uint256);\\n    // function fundingRateFactor() external view returns (uint256);\\n    // function getDelta(\\n    //     address _indexToken,\\n    //     uint256 _size,\\n    //     uint256 _averagePrice,\\n    //     bool _isLong,\\n    //     uint256 _lastIncreasedTime\\n    // ) external view returns (bool, uint256);\\n    // function getEntryFundingRate(\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external view returns (uint256);\\n    // function getFeeBasisPoints(\\n    //     address _token,\\n    //     uint256 _usdmDelta,\\n    //     uint256 _feeBasisPoints,\\n    //     uint256 _taxBasisPoints,\\n    //     bool _increment\\n    // ) external view returns (uint256);\\n    // function getFundingFee(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong,\\n    //     uint256 _size,\\n    //     uint256 _entryFundingRate\\n    // ) external view returns (uint256);\\n    // function getGlobalShortDelta(\\n    //     address _token\\n    // ) external view returns (bool, uint256);\\n    // function getMaxPrice(address _token) external view returns (uint256);\\n    // function getMinPrice(address _token) external view returns (uint256);\\n    // function getNextAveragePrice(\\n    //     address _indexToken,\\n    //     uint256 _size,\\n    //     uint256 _averagePrice,\\n    //     bool _isLong,\\n    //     uint256 _nextPrice,\\n    //     uint256 _sizeDelta,\\n    //     uint256 _lastIncreasedTime\\n    // ) external view returns (uint256);\\n    // function getNextFundingRate(address _token) external view returns (uint256);\\n    // function getNextGlobalShortAveragePrice(\\n    //     address _indexToken,\\n    //     uint256 _nextPrice,\\n    //     uint256 _sizeDelta\\n    // ) external view returns (uint256);\\n    // function getPosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         uint256,\\n    //         bool,\\n    //         uint256\\n    //     );\\n    // function getPositionDelta(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external view returns (bool, uint256);\\n    // function getPositionFee(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong,\\n    //     uint256 _sizeDelta\\n    // ) external view returns (uint256);\\n    // function getPositionKey(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external pure returns (bytes32);\\n    // function getPositionLeverage(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong\\n    // ) external view returns (uint256);\\n    // function getRedemptionAmount(\\n    //     address _token,\\n    //     uint256 _usdmAmount\\n    // ) external view returns (uint256);\\n    // function getRedemptionCollateral(\\n    //     address _token\\n    // ) external view returns (uint256);\\n    // function getRedemptionCollateralUsd(\\n    //     address _token\\n    // ) external view returns (uint256);\\n    // function getTargetUsdmAmount(\\n    //     address _token\\n    // ) external view returns (uint256);\\n    // function getUtilisation(address _token) external view returns (uint256);\\n    // function globalShortAveragePrices(address) external view returns (uint256);\\n    // function globalShortSizes(address) external view returns (uint256);\\n    // function gov() external view returns (address);\\n    // function guaranteedUsd(address) external view returns (uint256);\\n    // function hasDynamicFees() external view returns (bool);\\n    // function inManagerMode() external view returns (bool);\\n    // function inPrivateLiquidationMode() external view returns (bool);\\n    // function includeAmmPrice() external view returns (bool);\\n    // function increasePosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     uint256 _sizeDelta,\\n    //     bool _isLong\\n    // ) external;\\n    // function initialize(\\n    //     address _router,\\n    //     address _usdm,\\n    //     address _priceFeed,\\n    //     uint256 _liquidationFeeUsd,\\n    //     uint256 _fundingRateFactor,\\n    //     uint256 _stableFundingRateFactor\\n    // ) external;\\n    // function isInitialized() external view returns (bool);\\n    // function isLeverageEnabled() external view returns (bool);\\n    // function isLiquidator(address) external view returns (bool);\\n    // function isManager(address) external view returns (bool);\\n    // function isSwapEnabled() external view returns (bool);\\n    // function lastFundingTimes(address) external view returns (uint256);\\n    // function liquidatePosition(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong,\\n    //     address _feeReceiver\\n    // ) external;\\n    // function liquidationFeeUsd() external view returns (uint256);\\n    // function marginFeeBasisPoints() external view returns (uint256);\\n    // function maxGasPrice() external view returns (uint256);\\n    // function maxGlobalShortSizes(address) external view returns (uint256);\\n    // function maxLeverage() external view returns (uint256);\\n    // function maxUsdmAmounts(address) external view returns (uint256);\\n    // function minProfitBasisPoints(address) external view returns (uint256);\\n    // function minProfitTime() external view returns (uint256);\\n    // function mintBurnFeeBasisPoints() external view returns (uint256);\\n    // function poolAmounts(address) external view returns (uint256);\\n    // function positions(\\n    //     bytes32\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256 size,\\n    //         uint256 collateral,\\n    //         uint256 averagePrice,\\n    //         uint256 entryFundingRate,\\n    //         uint256 reserveAmount,\\n    //         int256 realisedPnl,\\n    //         uint256 lastIncreasedTime\\n    //     );\\n    // function priceFeed() external view returns (address);\\n    // function removeRouter(address _router) external;\\n    // function reservedAmounts(address) external view returns (uint256);\\n    // function router() external view returns (address);\\n    // function sellUSDM(\\n    //     address _token,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n    // function setBufferAmount(address _token, uint256 _amount) external;\\n    // function setError(uint256 _errorCode, string _error) external;\\n    // function setErrorController(address _errorController) external;\\n    // function setFees(\\n    //     uint256 _taxBasisPoints,\\n    //     uint256 _stableTaxBasisPoints,\\n    //     uint256 _mintBurnFeeBasisPoints,\\n    //     uint256 _swapFeeBasisPoints,\\n    //     uint256 _stableSwapFeeBasisPoints,\\n    //     uint256 _marginFeeBasisPoints,\\n    //     uint256 _liquidationFeeUsd,\\n    //     uint256 _minProfitTime,\\n    //     bool _hasDynamicFees\\n    // ) external;\\n    // function setFundingRate(\\n    //     uint256 _fundingInterval,\\n    //     uint256 _fundingRateFactor,\\n    //     uint256 _stableFundingRateFactor\\n    // ) external;\\n    // function setGov(address _gov) external;\\n    // function setInManagerMode(bool _inManagerMode) external;\\n    // function setInPrivateLiquidationMode(\\n    //     bool _inPrivateLiquidationMode\\n    // ) external;\\n    // function setIsLeverageEnabled(bool _isLeverageEnabled) external;\\n    // function setIsSwapEnabled(bool _isSwapEnabled) external;\\n    // function setLiquidator(address _liquidator, bool _isActive) external;\\n    // function setManager(address _manager, bool _isManager) external;\\n    // function setMaxGasPrice(uint256 _maxGasPrice) external;\\n    // function setMaxGlobalShortSize(address _token, uint256 _amount) external;\\n    // function setMaxLeverage(uint256 _maxLeverage) external;\\n    // function setPriceFeed(address _priceFeed) external;\\n    // function setTokenConfig(\\n    //     address _token,\\n    //     uint256 _tokenDecimals,\\n    //     uint256 _tokenWeight,\\n    //     uint256 _minProfitBps,\\n    //     uint256 _maxUsdmAmount,\\n    //     bool _isStable,\\n    //     bool _isShortable\\n    // ) external;\\n    // function setUsdmAmount(address _token, uint256 _amount) external;\\n    // function setVaultUtils(address _vaultUtils) external;\\n    // function shortableTokens(address) external view returns (bool);\\n    // function stableFundingRateFactor() external view returns (uint256);\\n    // function stableSwapFeeBasisPoints() external view returns (uint256);\\n    // function stableTaxBasisPoints() external view returns (uint256);\\n    // function stableTokens(address) external view returns (bool);\\n    function swap(\\n        address _tokenIn,\\n        address _tokenOut,\\n        address _receiver\\n    ) external returns (uint256);\\n    // function swapFeeBasisPoints() external view returns (uint256);\\n    // function taxBasisPoints() external view returns (uint256);\\n    // function tokenBalances(address) external view returns (uint256);\\n    // function tokenDecimals(address) external view returns (uint256);\\n    // function tokenToUsdMin(\\n    //     address _token,\\n    //     uint256 _tokenAmount\\n    // ) external view returns (uint256);\\n    // function tokenWeights(address) external view returns (uint256);\\n    // function totalTokenWeights() external view returns (uint256);\\n    // function updateCumulativeFundingRate(\\n    //     address _collateralToken,\\n    //     address _indexToken\\n    // ) external;\\n    // function upgradeVault(\\n    //     address _newVault,\\n    //     address _token,\\n    //     uint256 _amount\\n    // ) external;\\n    // function usdToToken(\\n    //     address _token,\\n    //     uint256 _usdAmount,\\n    //     uint256 _price\\n    // ) external view returns (uint256);\\n    // function usdToTokenMax(\\n    //     address _token,\\n    //     uint256 _usdAmount\\n    // ) external view returns (uint256);\\n    // function usdToTokenMin(\\n    //     address _token,\\n    //     uint256 _usdAmount\\n    // ) external view returns (uint256);\\n    // function usdm() external view returns (address);\\n    // function usdmAmounts(address) external view returns (uint256);\\n    // function useSwapPricing() external view returns (bool);\\n    // function validateLiquidation(\\n    //     address _account,\\n    //     address _collateralToken,\\n    //     address _indexToken,\\n    //     bool _isLong,\\n    //     bool _raise\\n    // ) external view returns (uint256, uint256);\\n    // function vaultUtils() external view returns (address);\\n    // function whitelistedTokenCount() external view returns (uint256);\\n    // function whitelistedTokens(address) external view returns (bool);\\n    // function withdrawFees(\\n    //     address _token,\\n    //     address _receiver\\n    // ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolSaddle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPoolSaddle {\\n    // function MAX_BPS() external view returns (uint256);\\n    // // function addLiquidity(\\n    // //     uint256[] amounts,\\n    // //     uint256 minToMint,\\n    // //     uint256 deadline\\n    // // ) external returns (uint256);\\n    // // function calculateRemoveLiquidity(\\n    // //     uint256 amount\\n    // // ) external view returns (uint256[]);\\n    // function calculateRemoveLiquidityOneToken(\\n    //     uint256 tokenAmount,\\n    //     uint8 tokenIndex\\n    // ) external view returns (uint256 availableTokenAmount);\\n    function calculateSwap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    // function calculateTokenAmount(\\n    //     uint256[] memory amounts,\\n    //     bool deposit\\n    // ) external view returns (uint256);\\n    // // function flashLoan(\\n    // //     address receiver,\\n    // //     address token,\\n    // //     uint256 amount,\\n    // //     bytes params\\n    // // ) external;\\n    // function flashLoanFeeBPS() external view returns (uint256);\\n    // function getA() external view returns (uint256);\\n    // function getAPrecise() external view returns (uint256);\\n    // function getAdminBalance(uint256 index) external view returns (uint256);\\n    // function getToken(uint8 index) external view returns (address);\\n    // function getTokenBalance(uint8 index) external view returns (uint256);\\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\\n\\n    // function getVirtualPrice() external view returns (uint256);\\n    // // function initialize(\\n    // //     address[] _pooledTokens,\\n    // //     uint8[] decimals,\\n    // //     string lpTokenName,\\n    // //     string lpTokenSymbol,\\n    // //     uint256 _a,\\n    // //     uint256 _fee,\\n    // //     uint256 _adminFee,\\n    // //     address lpTokenTargetAddress\\n    // // ) external;\\n    // function owner() external view returns (address);\\n    // function pause() external;\\n    // function paused() external view returns (bool);\\n    // function protocolFeeShareBPS() external view returns (uint256);\\n    // function rampA(uint256 futureA, uint256 futureTime) external;\\n    // // function removeLiquidity(\\n    // //     uint256 amount,\\n    // //     uint256[] minAmounts,\\n    // //     uint256 deadline\\n    // // ) external returns (uint256[]);\\n    // // function removeLiquidityImbalance(\\n    // //     uint256[] amounts,\\n    // //     uint256 maxBurnAmount,\\n    // //     uint256 deadline\\n    // // ) external returns (uint256);\\n    // function removeLiquidityOneToken(\\n    //     uint256 tokenAmount,\\n    //     uint8 tokenIndex,\\n    //     uint256 minAmount,\\n    //     uint256 deadline\\n    // ) external returns (uint256);\\n    // function renounceOwnership() external;\\n    // function setAdminFee(uint256 newAdminFee) external;\\n    // function setFlashLoanFees(\\n    //     uint256 newFlashLoanFeeBPS,\\n    //     uint256 newProtocolFeeShareBPS\\n    // ) external;\\n    // function setSwapFee(uint256 newSwapFee) external;\\n    // function stopRampA() external;\\n    function swap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy,\\n        uint256 deadline\\n    ) external returns (uint256);\\n    // function swapStorage()\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256 initialA,\\n    //         uint256 futureA,\\n    //         uint256 initialATime,\\n    //         uint256 futureATime,\\n    //         uint256 swapFee,\\n    //         uint256 adminFee,\\n    //         address lpToken\\n    //     );\\n    // function transferOwnership(address newOwner) external;\\n    // function unpause() external;\\n    // function withdrawAdminFees() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolUniV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//https://polygonscan.com/address/0xe0ce1d5380681d0d944b91c5a56d2b56e3cc93dc#code\\n//pool: \\\"0xe0ce1D5380681d0d944b91C5A56D2B56e3cc93Dc\\\",\\npragma solidity ^0.8.4;\\n\\ninterface IPoolUniV2 {\\n    // function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    // function HOLDING_ADDRESS() external view returns (address);\\n\\n    // function MINIMUM_LIQUIDITY() external view returns (uint256);\\n\\n    // function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    // function allowance(address, address) external view returns (uint256);\\n\\n    // function approve(address spender, uint256 value) external returns (bool);\\n\\n    // function balanceOf(address) external view returns (uint256);\\n\\n    // function burn(\\n    //     address to\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    // function decimals() external view returns (uint8);\\n\\n    // function destroy(uint256 value) external returns (bool);\\n\\n    // function factory() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n\\n    // function handleEarnings() external returns (uint256 amount);\\n\\n    // function initialize(address _token0, address _token1) external;\\n\\n    // function kLast() external view returns (uint256);\\n\\n    // function mint(address to) external returns (uint256 liquidity);\\n\\n    // function name() external view returns (string);\\n\\n    // function nonces(address) external view returns (uint256);\\n\\n    // function permit(\\n    //     address owner,\\n    //     address spender,\\n    //     uint256 value,\\n    //     uint256 deadline,\\n    //     uint8 v,\\n    //     bytes32 r,\\n    //     bytes32 s\\n    // ) external;\\n\\n    // function price0CumulativeLast() external view returns (uint256);\\n\\n    // function price1CumulativeLast() external view returns (uint256);\\n\\n    // function skim(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes memory data\\n    ) external;\\n\\n    ///function symbol() external view returns (string);\\n\\n    // function sync() external;\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    // function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolUniV3.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//https://polygonscan.com/address/0xe0ce1d5380681d0d944b91c5a56d2b56e3cc93dc#code\\n//pool: \\\"0xe0ce1D5380681d0d944b91C5A56D2B56e3cc93Dc\\\",\\npragma solidity ^0.8.4;\\n\\ninterface IPoolUniV3 {\\n    // function burn(\\n    //     int24 tickLower,\\n    //     int24 tickUpper,\\n    //     uint128 amount\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    // function collect(\\n    //     address recipient,\\n    //     int24 tickLower,\\n    //     int24 tickUpper,\\n    //     uint128 amount0Requested,\\n    //     uint128 amount1Requested\\n    // ) external returns (uint128 amount0, uint128 amount1);\\n\\n    // function collectProtocol(\\n    //     address recipient,\\n    //     uint128 amount0Requested,\\n    //     uint128 amount1Requested\\n    // ) external returns (uint128 amount0, uint128 amount1);\\n\\n    // function factory() external view returns (address);\\n\\n    // function fee() external view returns (uint24);\\n\\n    // function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    // function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    // function flash(\\n    //     address recipient,\\n    //     uint256 amount0,\\n    //     uint256 amount1,\\n    //     bytes memory data\\n    // ) external;\\n\\n    // function increaseObservationCardinalityNext(\\n    //     uint16 observationCardinalityNext\\n    // ) external;\\n\\n    // function initialize(uint160 sqrtPriceX96) external;\\n\\n    // function liquidity() external view returns (uint128);\\n\\n    // function maxLiquidityPerTick() external view returns (uint128);\\n\\n    // function mint(\\n    //     address recipient,\\n    //     int24 tickLower,\\n    //     int24 tickUpper,\\n    //     uint128 amount,\\n    //     bytes memory data\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    // function observations(\\n    //     uint256\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint32 blockTimestamp,\\n    //         int56 tickCumulative,\\n    //         uint160 secondsPerLiquidityCumulativeX128,\\n    //         bool initialized\\n    //     );\\n\\n    // function observe(\\n    //     uint32[] memory secondsAgos\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         int56[] memory tickCumulatives,\\n    //         uint160[] memory secondsPerLiquidityCumulativeX128s\\n    //     );\\n\\n    // function positions(\\n    //     bytes32\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint128 liquidity,\\n    //         uint256 feeGrowthInside0LastX128,\\n    //         uint256 feeGrowthInside1LastX128,\\n    //         uint128 tokensOwed0,\\n    //         uint128 tokensOwed1\\n    //     );\\n\\n    // function protocolFees()\\n    //     external\\n    //     view\\n    //     returns (uint128 token0, uint128 token1);\\n\\n    // function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\\n\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    // function snapshotCumulativesInside(\\n    //     int24 tickLower,\\n    //     int24 tickUpper\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         int56 tickCumulativeInside,\\n    //         uint160 secondsPerLiquidityInsideX128,\\n    //         uint32 secondsInside\\n    //     );\\n\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes memory data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    // function tickBitmap(int16) external view returns (uint256);\\n\\n    // function tickSpacing() external view returns (int24);\\n\\n    // function ticks(\\n    //     int24\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint128 liquidityGross,\\n    //         int128 liquidityNet,\\n    //         uint256 feeGrowthOutside0X128,\\n    //         uint256 feeGrowthOutside1X128,\\n    //         int56 tickCumulativeOutside,\\n    //         uint160 secondsPerLiquidityOutsideX128,\\n    //         uint32 secondsOutside,\\n    //         bool initialized\\n    //     );\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolVelodrome.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IPoolVelodrome {\\n    // function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    // function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    // function allowance(address, address) external view returns (uint256);\\n\\n    // function approve(address spender, uint256 amount) external returns (bool);\\n\\n    // function balanceOf(address) external view returns (uint256);\\n\\n    // function blockTimestampLast() external view returns (uint256);\\n\\n    // function burn(\\n    //     address to\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    // function chainId() external view returns (uint256);\\n\\n    // function claimFees() external returns (uint256 claimed0, uint256 claimed1);\\n\\n    // function claimable0(address) external view returns (uint256);\\n\\n    // function claimable1(address) external view returns (uint256);\\n\\n    // function current(\\n    //     address tokenIn,\\n    //     uint256 amountIn\\n    // ) external view returns (uint256 amountOut);\\n\\n    // function currentCumulativePrices()\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256 reserve0Cumulative,\\n    //         uint256 reserve1Cumulative,\\n    //         uint256 blockTimestamp\\n    //     );\\n\\n    // function decimals() external view returns (uint8);\\n\\n    // function factory() external view returns (address);\\n\\n    // function fees() external view returns (address);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn\\n    ) external view returns (uint256);\\n\\n    // function getReserves()\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint112 _reserve0,\\n    //         uint112 _reserve1,\\n    //         uint32 _blockTimestampLast\\n    //     );\\n\\n    // function index0() external view returns (uint256);\\n\\n    // function index1() external view returns (uint256);\\n\\n    // // function lastObservation() external view returns (tuple );\\n\\n    // function metadata()\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256 dec0,\\n    //         uint256 dec1,\\n    //         uint256 r0,\\n    //         uint256 r1,\\n    //         bool st,\\n    //         address t0,\\n    //         address t1\\n    //     );\\n\\n    // function mint(address to) external returns (uint256 liquidity);\\n\\n    // function name() external view returns (string memory);\\n\\n    // function nonces(address) external view returns (uint256);\\n\\n    // function observationLength() external view returns (uint256);\\n\\n    // function observations(\\n    //     uint256\\n    // )\\n    //     external\\n    //     view\\n    //     returns (\\n    //         uint256 timestamp,\\n    //         uint256 reserve0Cumulative,\\n    //         uint256 reserve1Cumulative\\n    //     );\\n\\n    // function permit(\\n    //     address owner,\\n    //     address spender,\\n    //     uint256 value,\\n    //     uint256 deadline,\\n    //     uint8 v,\\n    //     bytes32 r,\\n    //     bytes32 s\\n    // ) external;\\n\\n    // function prices(\\n    //     address tokenIn,\\n    //     uint256 amountIn,\\n    //     uint256 points\\n    // ) external view returns (uint256[] memory);\\n\\n    // function quote(\\n    //     address tokenIn,\\n    //     uint256 amountIn,\\n    //     uint256 granularity\\n    // ) external view returns (uint256 amountOut);\\n\\n    // function reserve0() external view returns (uint256);\\n\\n    // function reserve0CumulativeLast() external view returns (uint256);\\n\\n    // function reserve1() external view returns (uint256);\\n\\n    // function reserve1CumulativeLast() external view returns (uint256);\\n\\n    // function sample(\\n    //     address tokenIn,\\n    //     uint256 amountIn,\\n    //     uint256 points,\\n    //     uint256 window\\n    // ) external view returns (uint256[] memory);\\n\\n    // function skim(address to) external;\\n\\n    // function stable() external view returns (bool);\\n\\n    // function supplyIndex0(address) external view returns (uint256);\\n\\n    // function supplyIndex1(address) external view returns (uint256);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes memory data\\n    ) external;\\n\\n    // function symbol() external view returns (string memory);\\n\\n    // function sync() external;\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function tokens() external view returns (address, address);\\n\\n    // function totalSupply() external view returns (uint256);\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    // function transferFrom(\\n    //     address src,\\n    //     address dst,\\n    //     uint256 amount\\n    // ) external returns (bool);\\n\\n    // function treasury() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    // event PairCreated(\\n    //     address indexed token0,\\n    //     address indexed token1,\\n    //     address pair,\\n    //     uint256\\n    // );\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n\\n    // function allPairs(uint256) external view returns (address pair);\\n\\n    // function allPairsLength() external view returns (uint256);\\n\\n    // function feeTo() external view returns (address);\\n\\n    // function feeToSetter() external view returns (address);\\n\\n    // function createPair(address tokenA, address tokenB)\\n    //     external\\n    //     returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    // event Approval(\\n    //     address indexed owner,\\n    //     address indexed spender,\\n    //     uint256 value\\n    // );\\n    // event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    // function name() external pure returns (string memory);\\n\\n    // function symbol() external pure returns (string memory);\\n\\n    // function decimals() external pure returns (uint8);\\n\\n    // function totalSupply() external view returns (uint256);\\n\\n    // function balanceOf(address owner) external view returns (uint256);\\n\\n    // function allowance(\\n    //     address owner,\\n    //     address spender\\n    // ) external view returns (uint256);\\n\\n    // function approve(address spender, uint256 value) external returns (bool);\\n\\n    // function transfer(address to, uint256 value) external returns (bool);\\n\\n    // function transferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256 value\\n    // ) external returns (bool);\\n\\n    // function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    // function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    // function nonces(address owner) external view returns (uint256);\\n\\n    // function permit(\\n    //     address owner,\\n    //     address spender,\\n    //     uint256 value,\\n    //     uint256 deadline,\\n    //     uint8 v,\\n    //     bytes32 r,\\n    //     bytes32 s\\n    // ) external;\\n\\n    // event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    // event Burn(\\n    //     address indexed sender,\\n    //     uint256 amount0,\\n    //     uint256 amount1,\\n    //     address indexed to\\n    // );\\n    // event Swap(\\n    //     address indexed sender,\\n    //     uint256 amount0In,\\n    //     uint256 amount1In,\\n    //     uint256 amount0Out,\\n    //     uint256 amount1Out,\\n    //     address indexed to\\n    // );\\n    // event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    // function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    // function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    // function price0CumulativeLast() external view returns (uint256);\\n\\n    // function price1CumulativeLast() external view returns (uint256);\\n\\n    // function kLast() external view returns (uint256);\\n\\n    // function mint(address to) external returns (uint256 liquidity);\\n\\n    // function burn(\\n    //     address to\\n    // ) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    // function skim(address to) external;\\n\\n    // function sync() external;\\n\\n    // function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/KyberArbitrage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\n//https://polygonscan.com/\\n\\npragma solidity ^0.8.4;\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"./libraries/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IPoolUniV2.sol\\\";\\nimport \\\"./interfaces/IPoolUniV3.sol\\\";\\nimport \\\"./interfaces/IPoolAddressesProvider.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/DexSwaps.sol\\\";\\nimport \\\"./interfaces/IPoolDODO.sol\\\";\\nimport \\\"./interfaces/IAsset.sol\\\";\\nimport \\\"./interfaces/IBalancerVault.sol\\\";\\nimport \\\"./interfaces/IPoolCurve.sol\\\";\\nimport \\\"./interfaces/IPoolSaddle.sol\\\";\\nimport \\\"./interfaces/IPoolMetavault.sol\\\";\\nimport \\\"./interfaces/IPoolAddressesProvider.sol\\\";\\nimport \\\"./libraries/FlashLoanSimpleReceiverBase.sol\\\";\\n\\ncontract KyberArbitrage is DexSwaps, FlashLoanSimpleReceiverBase {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n    address public owner;\\n    address addressProvider;\\n    //Declare an Event\\n    event ArbitrageExecuted(\\n        address token,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        uint256 ratio,\\n        uint256 profit\\n    );\\n\\n    constructor(\\n        address _addressProvider\\n    ) FlashLoanSimpleReceiverBase(IPoolAddressesProvider(_addressProvider)) {\\n        addressProvider = _addressProvider;\\n        owner = (msg.sender);\\n        console.log(\\\"create KyberArbitrage\\\");\\n    }\\n\\n    // ////////////////////////////ARBITRAGE\\n    function Arbitrage(\\n        bytes[] calldata encodedSwap,\\n        address tokenIn,\\n        uint256 amountIn\\n    ) external {\\n        console.log(\\\"create Arbitrage\\\");\\n        bytes memory data = abi.encode(encodedSwap); // before flash loan\\n        console.log(\\n            \\\"BAlance antes del prestamo de usdt \\\",\\n            IERC20(tokenIn).balanceOf(address(this))\\n        );\\n        // AAVE Flash Loan\\n        requestFlashLoan(data, tokenIn, amountIn);\\n    }\\n\\n    // ////////////////////////////executeOperation\\n\\n    function executeOperation(\\n        address asset,\\n        uint256 amount,\\n        uint256 premium,\\n        address,\\n        bytes calldata params //mandar data\\n    ) external override returns (bool) {\\n        SwapInfo[6] memory swapInfoArray = SetSwapInfoArray(params); // in side Onflashloan  callback\\n        uint256 amountIn = amount;\\n        uint256 amountOwed = amount + premium;\\n        // console.log(\\\"amount in \\\", amountIn);\\n        // console.log(\\n        //     \\\"ERC20(asset).balanceOf(address(this) \\\",\\n        //     IERC20(asset).balanceOf(address(this))\\n        // );\\n        // ExecuteSwaps\\n        for (uint8 i; i < swapInfoArray.length; i++) {\\n            console.log(\\\"i \\\", i);\\n\\n            if (swapInfoArray[i].pool != address(0)) {\\n                amountIn = ExecuteSwap(swapInfoArray[i], amountIn);\\n            }\\n        }\\n\\n        uint256 FinalBalance = amountIn;\\n        // uint256 FinalBalance = IERC20(asset).balanceOf(address(this)); ///////////////////// temporal\\n\\n        // console.log(\\\"\\\\n\\\\n\\\");\\n        // console.log(\\\"amount\\\", amount);\\n        // console.log(\\\"premium\\\", premium);\\n        // console.log(\\\"amountOwed\\\", amountOwed);\\n        // console.log(\\\"FinalBalance\\\", FinalBalance);\\n\\n        require(FinalBalance > amountOwed, \\\"Arbitrage not profitable\\\");\\n\\n        console.log(\\\"FinalBalance - amountOwed\\\", FinalBalance - amountOwed);\\n\\n        IERC20(asset).transfer(owner, FinalBalance - amountOwed);\\n        approveToken(asset, address(POOL));\\n        emit ArbitrageExecuted(\\n            asset,\\n            amount,\\n            FinalBalance,\\n            (FinalBalance * 1000000) / amount,\\n            FinalBalance - amount\\n        );\\n        return true;\\n    }\\n\\n    ///////////////////// EXECUTE SWAP\\n    function ExecuteSwap(\\n        SwapInfo memory swapInfo,\\n        uint256 amountIn\\n    ) internal returns (uint256) {\\n        console.log(swapInfo.poolType);\\n        // UNISWAP V2\\n        if (swapInfo.poolType == 0) {\\n            SwapUniswapV2(swapInfo, amountIn);\\n        }\\n        // UNISWAP V3\\n        else if (swapInfo.poolType == 1) {\\n            SwapUniswapV3(swapInfo, amountIn);\\n        }\\n        // // BALANCER\\n        else if (swapInfo.poolType == 2) {\\n            SwapBalancer(swapInfo, amountIn);\\n        }\\n        // // CURVE\\n        else if (swapInfo.poolType == 3) {\\n            SwapCurve(swapInfo, amountIn);\\n        }\\n        //DODO\\n        else if (swapInfo.poolType == 4) {\\n            SwapDodo(swapInfo, amountIn);\\n        }\\n        //DODO CLASSIC\\n        else if (swapInfo.poolType == 10) {\\n            SwapDodoClassic(swapInfo, amountIn);\\n        }\\n        // // KYBERSWAP V1\\n        else if (swapInfo.poolType == 5) {\\n            SwapKyberswapV1(swapInfo, amountIn);\\n        }\\n        // // KYBERSWAP V2\\n        else if (swapInfo.poolType == 6) {\\n            SwapKyberswapV2(swapInfo, amountIn);\\n        }\\n        // //METAVAULT\\n        else if (swapInfo.poolType == 7) {\\n            SwapMetavault(swapInfo, amountIn);\\n        }\\n        // // SADDLE\\n        else if (swapInfo.poolType == 8) {\\n            SwapSaddle(swapInfo, amountIn);\\n        }\\n        // VELODROME\\n        else if (swapInfo.poolType == 9) {\\n            console.log(\\\"VELODROME\\\", swapInfo.poolType);\\n\\n            // SwapVelodrome(swapInfo, amountIn);\\n        }\\n        // //GMX\\n        else if (swapInfo.poolType == 11) {\\n            SwapGmx(swapInfo, amountIn);\\n        }\\n        // //camelot\\n        else if (swapInfo.poolType == 12) {\\n            console.log(\\\"camelot\\\", swapInfo.poolType);\\n\\n            SwapCamelot(swapInfo, amountIn);\\n        }\\n        uint256 balanceTokenOut = IERC20(swapInfo.tokenOut).balanceOf(\\n            address(this)\\n        );\\n\\n        require(balanceTokenOut > 0, \\\"Swap Failed\\\");\\n        return balanceTokenOut;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only the contract owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    function getBalanceOfToken(address _address) public view returns (uint256) {\\n        return IERC20(_address).balanceOf(address(this));\\n    }\\n\\n    function testFunction() public pure returns (address) {\\n        return address(0);\\n    }\\n\\n    function withdrawAll() public returns (address) {\\n        address[] memory tokens = tokensAAVE();\\n        for (uint256 i; i < tokens.length; i++) {\\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\\n            if (balance > 0) {\\n                IERC20(tokens[i]).transfer(owner, balance);\\n            }\\n            // console.log(\\\"\\\\n\\\", tokens[i]);\\n            // console.log(balance);\\n        }\\n\\n        return address(0);\\n    }\\n\\n    function SetSwapInfoArray(\\n        bytes memory data\\n    ) internal pure returns (SwapInfo[6] memory) {\\n        bytes[] memory decodedSwap = abi.decode(data, (bytes[]));\\n        SwapInfo[6] memory swapInfoArray;\\n\\n        for (uint8 i; i < decodedSwap.length; i++) {\\n            swapInfoArray[i] = decodeSwapInfo(decodedSwap[i]);\\n        }\\n\\n        return swapInfoArray;\\n    }\\n\\n    function decodeSwapInfo(\\n        bytes memory data\\n    ) public pure returns (SwapInfo memory) {\\n        (\\n            address pool,\\n            address tokenIn,\\n            address tokenOut,\\n            uint8 poolType,\\n            bytes32 poolId\\n        ) = abi.decode(data, (address, address, address, uint8, bytes32));\\n\\n        SwapInfo memory swapInfo = SwapInfo(\\n            pool,\\n            tokenIn,\\n            tokenOut,\\n            poolType,\\n            poolId\\n        );\\n        return swapInfo;\\n    }\\n\\n    ///////////////////// AAVE FLASHLOAN\\n    function requestFlashLoan(\\n        bytes memory data,\\n        address _token,\\n        uint256 _amount\\n    ) public {\\n        address reciverAddress = address(this);\\n        address asset = _token;\\n        uint256 amount = _amount;\\n        uint16 referralCode = 0; // ?\\n\\n        POOL.flashLoanSimple(reciverAddress, asset, amount, data, referralCode);\\n    }\\n\\n    ///////////////////// AAVE TOKENS\\n    function tokensAAVE() public view returns (address[] memory) {\\n        IPoolAddressesProvider.tokensAAVE[]\\n            memory list = IPoolAddressesProvider(\\n                IPoolAddressesProvider(addressProvider).getPoolDataProvider()\\n            ).getAllReservesTokens();\\n\\n        address[] memory addressList = new address[](list.length);\\n        for (uint256 i; i < list.length; i++) {\\n            addressList[i] = list[i].token;\\n        }\\n        return addressList;\\n    }\\n\\n    function contractBalance(\\n        address referenceToken,\\n        address factory\\n    ) external view returns (Balance[] memory) {\\n        console.log(referenceToken, factory);\\n        address[] memory tokens = tokensAAVE();\\n        console.log(\\\"Contract -  contractBalance tokensAAVE\\\");\\n\\n        Balance[] memory balances = new Balance[](tokens.length + 1);\\n\\n        for (uint256 i; i < tokens.length; i++) {\\n            string memory symbol = IERC20(tokens[i]).symbol();\\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\\n            uint256 referenceBalance;\\n            if (referenceToken != tokens[i]) {\\n                referenceBalance = getAmountsOut(\\n                    factory,\\n                    balance,\\n                    tokens[i],\\n                    referenceToken\\n                );\\n            } else {\\n                referenceBalance = balance;\\n            }\\n\\n            uint8 decimals = IERC20(tokens[i]).decimals();\\n            balances[i] = Balance(\\n                symbol,\\n                tokens[i],\\n                decimals,\\n                balance,\\n                referenceBalance\\n            );\\n        }\\n\\n        uint256 totalBalanceUSD;\\n        for (uint256 i; i < tokens.length; i++) {\\n            // console.log(\\\"totalBalanceUSD\\\", totalBalanceUSD);\\n            totalBalanceUSD = balances[i].balanceUSD + totalBalanceUSD;\\n        }\\n\\n        // console.log(\\\"tokens.length + 1\\\", tokens.length + 1);\\n        // console.log(\\\"decimals\\\", IERC20(referenceToken).decimals());\\n\\n        balances[tokens.length] = Balance(\\n            \\\"TOTAL\\\",\\n            address(0),\\n            IERC20(referenceToken).decimals(),\\n            totalBalanceUSD,\\n            totalBalanceUSD\\n        );\\n\\n        return balances;\\n    }\\n\\n    function getAmountsOut(\\n        address factory,\\n        uint amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) internal view returns (uint256 amountsOut) {\\n        address pool = IUniswapV2Factory(factory).getPair(tokenIn, tokenOut);\\n        // console.log(\\\"pool\\\", pool);\\n        if (pool != address(0)) {\\n            (uint reserveIn, uint reserveOut, ) = IPoolUniV2(pool)\\n                .getReserves();\\n            uint amountInWithFee = amountIn.mul(997);\\n            uint numerator = amountInWithFee.mul(reserveOut);\\n            uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n            amountsOut = numerator / denominator;\\n        } else {\\n            amountsOut = 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.6;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        //timestamp of last update\\n        uint40 lastUpdateTimestamp;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint16 id;\\n        //aToken address\\n        address aTokenAddress;\\n        //stableDebtToken address\\n        address stableDebtTokenAddress;\\n        //variableDebtToken address\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the current treasury balance, scaled\\n        uint128 accruedToTreasury;\\n        //the outstanding unbacked aTokens minted through the bridging feature\\n        uint128 unbacked;\\n        //the outstanding debt borrowed against this asset in isolation mode\\n        uint128 isolationModeTotalDebt;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60: asset is paused\\n        //bit 61: borrowing in isolation mode is enabled\\n        //bit 62-63: reserved\\n        //bit 64-79: reserve factor\\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n        //bit 152-167 liquidation protocol fee\\n        //bit 168-175 eMode category\\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n        //bit 252-255 unused\\n\\n        uint256 data;\\n    }\\n\\n    struct UserConfigurationMap {\\n        /**\\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n         * asset is borrowed by the user.\\n         */\\n        uint256 data;\\n    }\\n\\n    struct EModeCategory {\\n        // each eMode category has a custom ltv and liquidation threshold\\n        uint16 ltv;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationBonus;\\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\n        address priceSource;\\n        string label;\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n\\n    struct ReserveCache {\\n        uint256 currScaledVariableDebt;\\n        uint256 nextScaledVariableDebt;\\n        uint256 currPrincipalStableDebt;\\n        uint256 currAvgStableBorrowRate;\\n        uint256 currTotalStableDebt;\\n        uint256 nextAvgStableBorrowRate;\\n        uint256 nextTotalStableDebt;\\n        uint256 currLiquidityIndex;\\n        uint256 nextLiquidityIndex;\\n        uint256 currVariableBorrowIndex;\\n        uint256 nextVariableBorrowIndex;\\n        uint256 currLiquidityRate;\\n        uint256 currVariableBorrowRate;\\n        uint256 reserveFactor;\\n        ReserveConfigurationMap reserveConfiguration;\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        uint40 reserveLastUpdateTimestamp;\\n        uint40 stableDebtLastUpdateTimestamp;\\n    }\\n\\n    struct ExecuteLiquidationCallParams {\\n        uint256 reservesCount;\\n        uint256 debtToCover;\\n        address collateralAsset;\\n        address debtAsset;\\n        address user;\\n        bool receiveAToken;\\n        address priceOracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct ExecuteSupplyParams {\\n        address asset;\\n        uint256 amount;\\n        address onBehalfOf;\\n        uint16 referralCode;\\n    }\\n\\n    struct ExecuteBorrowParams {\\n        address asset;\\n        address user;\\n        address onBehalfOf;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        uint16 referralCode;\\n        bool releaseUnderlying;\\n        uint256 maxStableRateBorrowSizePercent;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct ExecuteRepayParams {\\n        address asset;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        address onBehalfOf;\\n        bool useATokens;\\n    }\\n\\n    struct ExecuteWithdrawParams {\\n        address asset;\\n        uint256 amount;\\n        address to;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n    }\\n\\n    struct ExecuteSetUserEModeParams {\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 categoryId;\\n    }\\n\\n    struct FinalizeTransferParams {\\n        address asset;\\n        address from;\\n        address to;\\n        uint256 amount;\\n        uint256 balanceFromBefore;\\n        uint256 balanceToBefore;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 fromEModeCategory;\\n    }\\n\\n    struct FlashloanParams {\\n        address receiverAddress;\\n        address[] assets;\\n        uint256[] amounts;\\n        uint256[] interestRateModes;\\n        address onBehalfOf;\\n        bytes params;\\n        uint16 referralCode;\\n        uint256 flashLoanPremiumToProtocol;\\n        uint256 flashLoanPremiumTotal;\\n        uint256 maxStableRateBorrowSizePercent;\\n        uint256 reservesCount;\\n        address addressesProvider;\\n        uint8 userEModeCategory;\\n        bool isAuthorizedFlashBorrower;\\n    }\\n\\n    struct FlashloanSimpleParams {\\n        address receiverAddress;\\n        address asset;\\n        uint256 amount;\\n        bytes params;\\n        uint16 referralCode;\\n        uint256 flashLoanPremiumToProtocol;\\n        uint256 flashLoanPremiumTotal;\\n    }\\n\\n    struct FlashLoanRepaymentParams {\\n        uint256 amount;\\n        uint256 totalPremium;\\n        uint256 flashLoanPremiumToProtocol;\\n        address asset;\\n        address receiverAddress;\\n        uint16 referralCode;\\n    }\\n\\n    struct CalculateUserAccountDataParams {\\n        UserConfigurationMap userConfig;\\n        uint256 reservesCount;\\n        address user;\\n        address oracle;\\n        uint8 userEModeCategory;\\n    }\\n\\n    struct ValidateBorrowParams {\\n        ReserveCache reserveCache;\\n        UserConfigurationMap userConfig;\\n        address asset;\\n        address userAddress;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        uint256 maxStableLoanPercent;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n        bool isolationModeActive;\\n        address isolationModeCollateralAddress;\\n        uint256 isolationModeDebtCeiling;\\n    }\\n\\n    struct ValidateLiquidationCallParams {\\n        ReserveCache debtReserveCache;\\n        uint256 totalDebt;\\n        uint256 healthFactor;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct CalculateInterestRatesParams {\\n        uint256 unbacked;\\n        uint256 liquidityAdded;\\n        uint256 liquidityTaken;\\n        uint256 totalStableDebt;\\n        uint256 totalVariableDebt;\\n        uint256 averageStableBorrowRate;\\n        uint256 reserveFactor;\\n        address reserve;\\n        address aToken;\\n    }\\n\\n    struct InitReserveParams {\\n        address asset;\\n        address aTokenAddress;\\n        address stableDebtAddress;\\n        address variableDebtAddress;\\n        address interestRateStrategyAddress;\\n        uint16 reservesCount;\\n        uint16 maxNumberReserves;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DexSwaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.4;\\nimport \\\"./TickMath.sol\\\";\\nimport \\\"./FullMath.sol\\\";\\n// import \\\"../interfaces/IUniswapV3Pool.sol\\\";\\n// import \\\"../interfaces/IUniswapV2Router02.sol\\\";\\n// import \\\"../interfaces/IUniswapV2Router01.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n// import \\\"../interfaces/IFactoryCurve.sol\\\";\\nimport \\\"../interfaces/IPoolCurve.sol\\\";\\n// import \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\\\";\\n// import \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\n// import \\\"../interfaces/IRouterSOLIDLY.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IPoolUniV2.sol\\\";\\nimport \\\"../interfaces/IPoolUniV3.sol\\\";\\nimport \\\"../interfaces/IPoolKyberswap.sol\\\";\\nimport \\\"../interfaces/IPoolKyberswapV2.sol\\\";\\nimport \\\"../interfaces/IPoolVelodrome.sol\\\";\\nimport \\\"../interfaces/IPoolCamelot.sol\\\";\\n\\nimport \\\"../interfaces/IPoolAddressesProvider.sol\\\";\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../interfaces/IPoolDODO.sol\\\";\\nimport \\\"../interfaces/IAsset.sol\\\";\\nimport \\\"../interfaces/IBalancerVault.sol\\\";\\n// import \\\"../interfaces/IFactoryCurve.sol\\\";\\nimport \\\"../interfaces/IPoolSaddle.sol\\\";\\nimport \\\"../interfaces/IPoolMetavault.sol\\\";\\nimport \\\"../interfaces/IPoolGmx.sol\\\";\\n\\ncontract DexSwaps {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    struct SwapInfo {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint8 poolType;\\n        bytes32 poolId;\\n    }\\n\\n    struct Balance {\\n        string symbol;\\n        address token;\\n        uint8 decimals;\\n        uint256 balance;\\n        uint256 balanceUSD;\\n    }\\n    uint256 constant MAX_INT =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    function SwapUniswapV2(SwapInfo memory info, uint256 amountIn) internal {\\n        // // console.log(\\\"*********** SwapUniswapV2 ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        uint112 _reserve0;\\n        uint112 _reserve1;\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n\\n        // approve the tokenIn on the pool\\n        approveToken(info.tokenIn, info.pool);\\n\\n        // transfer: This function allows an address to send tokens to another address.\\n        IERC20(info.tokenIn).transfer(address(info.pool), amountIn);\\n\\n        // Use IPoolUniV2 to get token 0 and 1\\n        address token0 = IPoolUniV2(info.pool).token0();\\n        address token1 = IPoolUniV2(info.pool).token1();\\n\\n        //get the reserves from the pool\\n        (_reserve0, _reserve1, ) = IPoolUniV2(info.pool).getReserves();\\n        reserveIn = info.tokenIn == token0 ? _reserve0 : _reserve1;\\n        reserveOut = info.tokenIn == token1 ? _reserve0 : _reserve1;\\n\\n        //make operatios to take amountOut\\n        uint256 amountOut;\\n        // uint256 amountIn = amountIn;\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n\\n        // validate if the amountOut is for token0 or token1\\n        uint256 amount0Out = info.tokenIn == token0 ? 0 : amountOut;\\n        uint256 amount1Out = info.tokenIn == token1 ? 0 : amountOut;\\n\\n        //make the swap\\n        IPoolUniV2(info.pool).swap(amount0Out, amount1Out, address(this), \\\"\\\");\\n        // ///tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapUniswapV3(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"*********** SwapUniswapV3 ***********\\\");\\n        bool zeroForOne;\\n        // ///tokensBalance(info.tokenIn, info.tokenOut);\\n        address token0 = IPoolUniV3(info.pool).token0();\\n        (uint160 sqrtPriceLimitX96, , , , , , ) = IPoolUniV3(info.pool).slot0();\\n\\n        if (token0 == info.tokenIn) {\\n            zeroForOne = true;\\n            sqrtPriceLimitX96 = (sqrtPriceLimitX96 * 900) / 1000;\\n        } else {\\n            zeroForOne = false;\\n            sqrtPriceLimitX96 = (sqrtPriceLimitX96 * 1100) / 1000;\\n        }\\n\\n        bytes memory data = abi.encode(info.pool, info.tokenIn, zeroForOne);\\n\\n        IPoolUniV3(info.pool).swap(\\n            address(this),\\n            zeroForOne,\\n            int256(amountIn),\\n            sqrtPriceLimitX96,\\n            data\\n        );\\n\\n        // ///tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external {\\n        (address pool, address tokenIn, bool zeroForOne) = abi.decode(\\n            data,\\n            (address, address, bool)\\n        );\\n        // console.log(\\\"uniswapV3SwapCallback\\\");\\n\\n        // console.logInt(amount0Delta);\\n        // console.logInt(amount1Delta);\\n\\n        if (zeroForOne) {\\n            IERC20(tokenIn).transfer(address(pool), uint256(amount0Delta));\\n        } else {\\n            IERC20(tokenIn).transfer(address(pool), uint256(amount1Delta));\\n        }\\n        // console.log(\\\"*********** uniswapV3SwapCallback  transfer ***********\\\");\\n    }\\n\\n    function SwapMetavault(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n*********** SwapMetavault ***********\\\");\\n        //tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        IERC20(info.tokenIn).transfer(info.pool, amountIn);\\n        IPoolMetavault(info.pool).swap(\\n            info.tokenIn,\\n            info.tokenOut,\\n            address(this)\\n        );\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapGmx(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n*********** SwapGmx ***********\\\");\\n        //tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        IERC20(info.tokenIn).transfer(info.pool, amountIn);\\n        IPoolGmx(info.pool).swap(info.tokenIn, info.tokenOut, address(this));\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapCamelot(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n*********** SwapGmx ***********\\\");\\n        //tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        //appruve\\n        // approveToken(info.tokenIn, info.pool);\\n        IERC20(info.tokenIn).transfer(info.pool, amountIn);\\n\\n        address token0 = IPoolUniV2(info.pool).token0();\\n        // address token1 = IPoolUniV2(info.pool).token1();\\n\\n        uint256 amount = IPoolCamelot(info.pool).getAmountOut(\\n            amountIn,\\n            info.tokenIn\\n        );\\n        console.log(\\\"amount\\\", amount);\\n\\n        uint256 amount0Out;\\n        uint256 amount1Out;\\n\\n        if (info.tokenOut == token0) {\\n            amount0Out = amount;\\n        } else {\\n            amount1Out = amount;\\n        }\\n\\n        IPoolCamelot(info.pool).swap(amount0Out, amount1Out, address(this), \\\"\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapDodo(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n***********DexSwaps SwapDodo ***********\\\");\\n\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        IERC20(info.tokenIn).transfer(info.pool, amountIn);\\n        console.log(\\\"info.pool\\\", info.pool);\\n        if (IPoolDODO(info.pool)._BASE_TOKEN_() == info.tokenIn) {\\n            // console.log(\\\"sellBase\\\");\\n            IPoolDODO(info.pool).sellBase(address(this)); //WMATIC\\n        } else if (IPoolDODO(info.pool)._QUOTE_TOKEN_() == info.tokenIn) {\\n            // console.log(\\\"_QUOTE_TOKEN_\\\");\\n\\n            IPoolDODO(info.pool).sellQuote(address(this)); //USDC`\\n        }\\n\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapDodoClassic(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n***********DexSwaps SwapDodo ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n        // IERC20(info.tokenIn).transfer(info.pool, amountIn);\\n\\n        approveToken(info.tokenIn, info.pool);\\n        uint256 amountOut;\\n        // uint256 amountIn = IERC20(info.tokenIn).balanceOf(address(this));\\n\\n        // console.log(\\\"\\\\nSwapDodoClassic info.pool\\\", info.pool);\\n        bytes memory emptyData = new bytes(0);\\n        if (IPoolDODO(info.pool)._BASE_TOKEN_() == info.tokenIn) {\\n            amountOut = IPoolDODO(info.pool).queryBuyBaseToken(amountIn);\\n\\n            // console.log(\\\"\\\\nsellBaseToken amountOut\\\", amountOut);\\n\\n            IPoolDODO(info.pool).sellBaseToken(amountIn, 0, emptyData);\\n        } else if (IPoolDODO(info.pool)._QUOTE_TOKEN_() == info.tokenIn) {\\n            amountOut = IPoolDODO(info.pool).querySellBaseToken(amountIn);\\n\\n            // console.log(\\\"\\\\nbuyBaseToken amountOut\\\", amountOut);\\n\\n            IPoolDODO(info.pool).buyBaseToken(amountIn, MAX_INT, emptyData);\\n        }\\n\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapKyberswapV1(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n***********DexSwaps SwapKyberswapV1 ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        IERC20(info.tokenIn).transfer(address(info.pool), amountIn);\\n        (\\n            ,\\n            ,\\n            uint256 vReserveIn,\\n            uint256 vReserveOut,\\n            uint256 feeInPrecision\\n        ) = IPoolKyberswap(info.pool).getTradeInfo();\\n        uint256 PRECISION = 1e18;\\n\\n        uint256 amountInWithFee = amountIn\\n            .mul(PRECISION.sub(feeInPrecision))\\n            .div(PRECISION);\\n\\n        uint256 amount0Out;\\n        uint256 amount1Out;\\n        uint256 denominator;\\n        if (IPoolKyberswap(info.pool).token0() == info.tokenIn) {\\n            denominator = vReserveIn.add(amountInWithFee);\\n            amount1Out = amountInWithFee.mul(vReserveOut).div(denominator);\\n        } else {\\n            denominator = vReserveOut.add(amountInWithFee);\\n            amount0Out = amountInWithFee.mul(vReserveIn).div(denominator);\\n        }\\n\\n        IPoolKyberswap(info.pool).swap(\\n            amount0Out,\\n            amount1Out,\\n            address(this),\\n            \\\"\\\"\\n        );\\n\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapKyberswapV2(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n***********DexSwaps SwapKiberswapV2 ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        IPoolKyberswapV2 pool = IPoolKyberswapV2(info.pool);\\n\\n        (uint160 sqrtPriceLimitX96, , , ) = pool.getPoolState();\\n        bool zeroForOne;\\n\\n        if (pool.token0() == info.tokenIn) {\\n            zeroForOne = true;\\n            sqrtPriceLimitX96 = (sqrtPriceLimitX96 * 900) / 1000;\\n        } else {\\n            zeroForOne = false;\\n\\n            sqrtPriceLimitX96 = (sqrtPriceLimitX96 * 1100) / 1000;\\n        }\\n        pool.swap(\\n            address(this),\\n            int256(amountIn),\\n            zeroForOne,\\n            sqrtPriceLimitX96,\\n            \\\"\\\"\\n        );\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    // function SwapVelodrome(SwapInfo memory info, uint256 amountIn) internal {\\n    //     // console.log(\\\"\\\\n***********DexSwaps SwapVelodrome ***********\\\");\\n    //     // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n    //     IERC20(info.tokenIn).transfer(info.pool, amountIn);\\n\\n    //     IPoolVelodrome pool = IPoolVelodrome(info.pool);\\n\\n    //     uint256 amountOut = pool.getAmountOut(amountIn, info.tokenIn);\\n\\n    //     uint256 amount0Out = info.tokenIn == pool.token0() ? 0 : amountOut;\\n    //     uint256 amount1Out = info.tokenIn != pool.token0() ? 0 : amountOut;\\n\\n    //     pool.swap(amount0Out, amount1Out, address(this), \\\"\\\");\\n    //     // tokensBalance(info.tokenIn, info.tokenOut);\\n    // }\\n\\n    function SwapSaddle(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n*********** SwapSaddle ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        uint8 i = IPoolSaddle(info.pool).getTokenIndex(info.tokenIn);\\n        uint8 j = IPoolSaddle(info.pool).getTokenIndex(info.tokenOut);\\n\\n        // // console.log(\\\"i\\\", i);\\n        // // console.log(\\\"j\\\", j);\\n        uint256 amountOut = IPoolSaddle(info.pool).calculateSwap(\\n            i,\\n            j,\\n            amountIn\\n        );\\n        // // console.log(\\\"amountOut\\\", amountOut);\\n        approveToken(info.tokenIn, info.pool);\\n\\n        IPoolSaddle(info.pool).swap(i, j, amountIn, amountOut, block.timestamp);\\n\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapCurve(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"\\\\n*********** SwapCurve ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        uint256 i = 1000;\\n        uint256 j = 1000;\\n\\n        for (uint k = 0; k < 20; k++) {\\n            if (i != 1000 && j != 1000) {\\n                break;\\n            }\\n            address coin = IPoolCurve(info.pool).coins(k);\\n\\n            if (coin == info.tokenIn) {\\n                i = k;\\n            }\\n            if (coin == info.tokenOut) {\\n                j = k;\\n            }\\n        }\\n\\n        approveToken(info.tokenIn, info.pool);\\n        uint256 dy = IPoolCurve(info.pool).get_dy(i, j, amountIn);\\n        // console.log(\\\"\\\\n here\\\");\\n        // console.log(info.pool);\\n        // console.log(i);\\n        // console.log(j);\\n        // console.log(amountIn);\\n        // console.log(dy);\\n        IPoolCurve(info.pool).exchange(i, j, amountIn, dy);\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    function SwapBalancer(SwapInfo memory info, uint256 amountIn) internal {\\n        // console.log(\\\"*********** SwapBalancer ***********\\\");\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n\\n        IBalancerVault.FundManagement memory fund = IBalancerVault\\n            .FundManagement(\\n                address(this),\\n                false,\\n                payable(address(this)),\\n                false\\n            );\\n\\n        IBalancerVault.SingleSwap memory singleBalSwap = IBalancerVault\\n            .SingleSwap(\\n                info.poolId,\\n                IBalancerVault.SwapKind.GIVEN_IN,\\n                IAsset(info.tokenIn),\\n                IAsset(info.tokenOut),\\n                amountIn,\\n                \\\"\\\"\\n            );\\n\\n        approveToken(info.tokenIn, info.pool);\\n\\n        IBalancerVault(info.pool).swap(singleBalSwap, fund, 0, block.timestamp);\\n        // tokensBalance(info.tokenIn, info.tokenOut);\\n    }\\n\\n    //IPoolKyberswapV2\\n    function swapCallback(\\n        int256 deltaQty0,\\n        int256 deltaQty1,\\n        bytes calldata\\n    ) external {\\n        int256 amount;\\n        IPoolKyberswapV2 pool = IPoolKyberswapV2(msg.sender);\\n\\n        // tokensBalance(\\n        // 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270,\\n        // 0x1C954E8fe737F99f68Fa1CCda3e51ebDB291948C\\n        // );\\n        if (deltaQty0 > 0) {\\n            amount = deltaQty0;\\n            IERC20(pool.token0()).transfer(msg.sender, uint256(amount));\\n        } else {\\n            amount = deltaQty1;\\n            IERC20(pool.token1()).transfer(msg.sender, uint256(amount));\\n        }\\n    }\\n\\n    // function tokensBalance(address tokenIn, address tokenOut) internal view {\\n    // uint256 balanceIn = IERC20(tokenIn).balanceOf(address(this));\\n    // uint256 balanceOut = IERC20(tokenOut).balanceOf(address(this));\\n    // console.log(\\\"\\\\nbalance tokenIn\\\", balanceIn, tokenIn);\\n    // console.log(\\\"balance tokenOut\\\", balanceOut, tokenOut);\\n    // }\\n\\n    function approveToken(address token, address pool) internal {\\n        // console.log(\\\"APPROve1\\\");\\n        if (IERC20(token).allowance(address(this), pool) == 0) {\\n            // console.log(\\\"APPROve2\\\");\\n\\n            IERC20(token).approve(pool, MAX_INT);\\n            // console.log(\\\"APPROve3\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FlashLoanSimpleReceiverBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// pragma solidity 0.8.10;\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/IPoolAddressesProvider.sol\\\";\\nimport \\\"../interfaces/IPool.sol\\\";\\n\\nimport \\\"../interfaces/IFlashLoanSimpleReceiver.sol\\\";\\n\\n// import {IFlashLoanSimpleReceiver} from \\\"../interfaces/IFlashLoanSimpleReceiver.sol\\\";\\n// import {IPoolAddressesProvider} from \\\"../../interfaces/IPoolAddressesProvider.sol\\\";\\n// import {IPool} from \\\"../../interfaces/IPool.sol\\\";\\n\\n/**\\n * @title FlashLoanSimpleReceiverBase\\n * @author Aave\\n * @notice Base contract to develop a flashloan-receiver contract.\\n */\\nabstract contract FlashLoanSimpleReceiverBase is IFlashLoanSimpleReceiver {\\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\\n    IPool public immutable override POOL;\\n\\n    constructor(IPoolAddressesProvider provider) {\\n        ADDRESSES_PROVIDER = provider;\\n        POOL = IPool(provider.getPool());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(\\n            value\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            \\\"SafeERC20: decreased allowance below zero\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.6;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    error T();\\n    error R();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO =\\n        1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(\\n        int24 tick\\n    ) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0\\n                ? uint256(-int256(tick))\\n                : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0)\\n                ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0)\\n                ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0)\\n                ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0)\\n                ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0)\\n                ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0)\\n                ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0)\\n                ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0)\\n                ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0)\\n                ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0)\\n                ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0)\\n                ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0)\\n                ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0)\\n                ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0)\\n                ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0)\\n                ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0)\\n                ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0)\\n                ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0)\\n                ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0)\\n                ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160(\\n                (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\n            );\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    // function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n    //     unchecked {\\n    //         // second inequality must be < because the price can never reach the price at the max tick\\n    //         if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\\n    //         uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n    //         uint256 r = ratio;\\n    //         uint256 msb = 0;\\n\\n    //         assembly {\\n    //             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := shl(5, gt(r, 0xFFFFFFFF))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := shl(4, gt(r, 0xFFFF))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := shl(3, gt(r, 0xFF))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := shl(2, gt(r, 0xF))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := shl(1, gt(r, 0x3))\\n    //             msb := or(msb, f)\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             let f := gt(r, 0x1)\\n    //             msb := or(msb, f)\\n    //         }\\n\\n    //         if (msb >= 128) r = ratio >> (msb - 127);\\n    //         else r = ratio << (127 - msb);\\n\\n    //         int256 log_2 = (int256(msb) - 128) << 64;\\n\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(63, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(62, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(61, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(60, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(59, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(58, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(57, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(56, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(55, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(54, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(53, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(52, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(51, f))\\n    //             r := shr(f, r)\\n    //         }\\n    //         assembly {\\n    //             r := shr(127, mul(r, r))\\n    //             let f := shr(128, r)\\n    //             log_2 := or(log_2, shl(50, f))\\n    //         }\\n\\n    //         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n    //         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n    //         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n    //         tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    //     }\\n    // }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ArbitrageExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"encodedSwap\",\"type\":\"bytes[]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"Arbitrage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referenceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"contractBalance\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceUSD\",\"type\":\"uint256\"}],\"internalType\":\"struct DexSwaps.Balance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decodeSwapInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"poolType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"internalType\":\"struct DexSwaps.SwapInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalanceOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"deltaQty0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaQty1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"swapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testFunction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensAAVE\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "KyberArbitrage",
    "CompilerVersion": "v0.8.8+commit.dddeac2f",
    "OptimizationUsed": "1",
    "Runs": "1000000",
    "ConstructorArguments": "000000000000000000000000a97684ead0e402dc232d5a977953df7ecbab3cdb",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}