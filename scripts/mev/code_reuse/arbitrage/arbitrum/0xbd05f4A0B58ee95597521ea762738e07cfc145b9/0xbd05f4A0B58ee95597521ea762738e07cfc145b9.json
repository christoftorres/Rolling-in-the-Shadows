{
    "SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IArbiDexRouter {\r\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IArbDexPair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ncontract Arbitrage {\r\n    address public treasury;\r\n    address public router;\r\n    address public owner;\r\n    address USDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\r\n    uint256 multiplier = 9950; // 99.40%\r\n    uint256 public profit = 0; // Amount of profit (in USDC) from doing an arbitrage\r\n    uint256 public requiredTokens = 0; // Amount of tokens (minimum) required for the most profit\r\n    uint256 public minimumTokensOut = 0;\r\n    address[] tokenPath; // The path of tokens that will be utilized for arbitrage\r\n    mapping(address => bool) approvedTokens; // List of all the tokens that have been approved (token approval for transfers).\r\n    address[] arbPairs;\r\n    mapping(address => address[2]) arbTokens; // pair, and then tokens associated that are up for arbitrage.\r\n\r\n    constructor(\r\n        address _router,\r\n        address _treasury\r\n    ) {\r\n        treasury = _treasury;\r\n        router = _router;\r\n        owner = msg.sender;\r\n        generateApproval(USDC);\r\n    }\r\n\r\n    event NormalArbitrage(uint256, uint256);\r\n    event NoArbitrage();\r\n    event LowBalanceArbitrage(uint256, uint256);\r\n    event OwnershipTransferred(address);\r\n    event TreasuryUpdated(address);\r\n    event SetMultiplier(uint256);\r\n\r\n    modifier onlyOwner {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n\r\n    function setMultiplier(uint256 _multiplier) external onlyOwner {\r\n        require(multiplier != _multiplier, \"Multiplier already set to that\");\r\n        require(_multiplier >= 0, \"Multiplier cannot be zero\");\r\n        multiplier = _multiplier;\r\n        emit SetMultiplier(_multiplier);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != owner, \"Owner is already set to that address\");\r\n        require(_newOwner != address(0), \"Cannot be zero address\");\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(_newOwner);\r\n    }\r\n\r\n    function setTreasury(address _treasury) external onlyOwner {\r\n        require(_treasury != treasury, \"Treasury is already set to that address\");\r\n        require(_treasury != address(0), \"Cannot be zero address\");\r\n        treasury = _treasury;\r\n        emit TreasuryUpdated(_treasury);\r\n    }\r\n\r\n    function generateApproval(address _token) internal {\r\n        // Used to approve all the tokens our platform has for transfer by the router from this contract\r\n        approvedTokens[_token] = true;\r\n        IERC20(_token).approve(router, 1000000000000000000000000);\r\n    }\r\n\r\n    function recoverToken(address _token) external onlyOwner {\r\n        require(_token != address(0), \"Cannot be zero address\");\r\n        require(IERC20(_token).balanceOf(address(this)) > 0, \"Nothing to transfer\");\r\n        IERC20(_token).transfer(treasury, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n\r\n    function updateList(address _pairAddress) external onlyOwner {\r\n        arbPairs.push(_pairAddress);\r\n        arbTokens[_pairAddress] = [IArbDexPair(_pairAddress).token0(), IArbDexPair(_pairAddress).token1()];\r\n    }\r\n\r\n    function computeProfit(uint256 amountIn) internal {\r\n        // Going to add 1 USDC to see if we can make a higher profit (requires us to recompute output of the path via Router)\r\n        uint256 newAmountIn = amountIn + (10 * (10 ** 6));\r\n        if (newAmountIn > IERC20(USDC).balanceOf(treasury)) {return;}\r\n        uint256[] memory newAmounts =  IArbiDexRouter(router).getAmountsOut(newAmountIn, tokenPath);\r\n        // Expected amount out has to be recomputed since we called the Router again, remembering that 0.6% of our starting tokens come back to us.\r\n        uint256 newExpectedAmount = (newAmountIn * multiplier)/10000;\r\n\r\n        if (newAmounts[newAmounts.length-1] > newExpectedAmount && (newAmounts[newAmounts.length-1] - newExpectedAmount) > profit) {\r\n            // Profit was higher than previous profit, so let's update profit amount and token amounts and then do all of it over again\r\n            minimumTokensOut = newAmounts[newAmounts.length-1];\r\n            profit = newAmounts[newAmounts.length-1] - newExpectedAmount;\r\n            requiredTokens = newAmountIn;\r\n            // Delete these variables and arrays that way we save on gas\r\n            delete newExpectedAmount;\r\n            delete newAmounts;\r\n            computeProfit(newAmountIn);\r\n        }\r\n    }\r\n\r\n    function conductArbitrage(address tokenA, address tokenB) internal {\r\n        // Returns the amount of profit, or the amount of USDC we get out subtracted by the amount we started by (profit).\r\n        // We take into account the fact that 0.2% of every swap goes back to the multisig, and remember to account for those swap fees during this calculation.\r\n\r\n        if (!approvedTokens[tokenA]) {\r\n            generateApproval(tokenA);\r\n        }\r\n        if (!approvedTokens[tokenB]) {\r\n            generateApproval(tokenB);\r\n        }\r\n        if (tokenA == USDC || tokenB == USDC) {return;}\r\n\r\n        // Amount we start with multiplied by decimals 6 (USDC)\r\n        uint256 amountIn = 10 * (10 ** 6);\r\n\r\n        // Since we starting a new check, lets reset all of our variables\r\n        profit = 0;\r\n        requiredTokens = 0;\r\n        minimumTokensOut = 0;\r\n\r\n        address[] memory path1 = new address[](4);\r\n        address[] memory path2 = new address[](4);\r\n        path1[0] = USDC; path1[1] = tokenA; path1[2] = tokenB; path1[3] = USDC;\r\n        path2[0] = USDC; path2[1] = tokenB; path2[2] = tokenA; path2[3] = USDC;\r\n\r\n        uint256[] memory amounts1 = IArbiDexRouter(router).getAmountsOut(amountIn, path1);\r\n        uint256[] memory amounts2 = IArbiDexRouter(router).getAmountsOut(amountIn, path2);\r\n        uint256 expectedAmount = (amountIn * multiplier)/10000;\r\n\r\n        if (amounts1[amounts1.length-1] > expectedAmount && amounts1[amounts1.length-1] > amounts2[amounts2.length-1]) {\r\n            // Profitable on first path, compute the precise amount of tokens we can use to maximize profits\r\n            delete amounts2;\r\n\r\n            tokenPath = path1;\r\n            profit = amounts1[amounts1.length-1] - expectedAmount;\r\n\r\n            // We don't need the expectedAmount or amounts1 variable anymore, so let's delete it and save gas\r\n            delete expectedAmount;\r\n            delete amounts1;\r\n\r\n            // We no longer need the path1 or path2 variables, lets delete them to save gas\r\n            delete path1;\r\n            delete path2;\r\n            \r\n            computeProfit(amountIn);\r\n        } else if (amounts2[amounts2.length-1] > expectedAmount && amounts2[amounts2.length-1] > amounts1[amounts1.length-1]) {\r\n            // Profitable on second path, compute the precise amount of tokens we can use to maximize profits\r\n            delete amounts1;\r\n\r\n            tokenPath = path2;\r\n            profit = amounts2[amounts2.length-1] - expectedAmount;\r\n\r\n            // We don't need the expectedAmount or amounts2 variable anymore, so let's delete it and save gas\r\n            delete expectedAmount;\r\n            delete amounts2;\r\n\r\n            // We no longer need the path1 or path2 variables, lets delete them to save gas\r\n            delete path1;\r\n            delete path2;\r\n            \r\n            computeProfit(amountIn);\r\n        }\r\n\r\n        if (profit > 0) {\r\n            // If the required tokens to do arbitrage is less than or equal to how many USDC we have, let's do the swap (as long as their is some profit to be made)\r\n\r\n            IERC20(USDC).transferFrom(treasury, address(this), requiredTokens);\r\n            IArbiDexRouter(router).swapExactTokensForTokens(requiredTokens, minimumTokensOut, tokenPath, treasury, (block.timestamp + 120));\r\n            emit NormalArbitrage(requiredTokens, minimumTokensOut);\r\n        } else {\r\n            emit NoArbitrage();\r\n        }\r\n    }\r\n\r\n    function tryArbitrage() external {\r\n        for (uint256 i = 0; i < arbPairs.length; i++) {\r\n            conductArbitrage(arbTokens[arbPairs[i]][0], arbTokens[arbPairs[i]][1]);\r\n        }\r\n    }\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LowBalanceArbitrage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NoArbitrage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NormalArbitrage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SetMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"TreasuryUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"minimumTokensOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"setMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tryArbitrage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pairAddress\",\"type\":\"address\"}],\"name\":\"updateList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "Arbitrage",
    "CompilerVersion": "v0.8.18+commit.87f61d96",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "0000000000000000000000003e48298a5fe88e4d62985dff65dee39a259149750000000000000000000000002084e8ecdca037e4751a8ead62ebd324425ff3f8",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://43cc2657f896c3cfc925d4d9c0589d1a61bef77ee4860c3d7dd93e6944ac3d0b"
}