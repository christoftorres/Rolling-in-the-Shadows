{
    "SourceCode": "pragma solidity =0.5.16;\r\n\r\ninterface IUniswapV2Factory {\r\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n\tfunction feeTo() external view returns (address);\r\n\r\n\tfunction feeToSetter() external view returns (address);\r\n\r\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n\tfunction allPairs(uint256) external view returns (address pair);\r\n\r\n\tfunction allPairsLength() external view returns (uint256);\r\n\r\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n\tfunction setFeeTo(address) external;\r\n\r\n\tfunction setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tfunction name() external pure returns (string memory);\r\n\r\n\tfunction symbol() external pure returns (string memory);\r\n\r\n\tfunction decimals() external pure returns (uint8);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint256);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) external returns (bool);\r\n\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n\tfunction nonces(address owner) external view returns (uint256);\r\n\r\n\tfunction permit(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 value,\r\n\t\tuint256 deadline,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external;\r\n\r\n\tevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n\tevent Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n\tevent Swap(\r\n\t\taddress indexed sender,\r\n\t\tuint256 amount0In,\r\n\t\tuint256 amount1In,\r\n\t\tuint256 amount0Out,\r\n\t\tuint256 amount1Out,\r\n\t\taddress indexed to\r\n\t);\r\n\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n\tfunction factory() external view returns (address);\r\n\r\n\tfunction token0() external view returns (address);\r\n\r\n\tfunction token1() external view returns (address);\r\n\r\n\tfunction getReserves()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint112 reserve0,\r\n\t\t\tuint112 reserve1,\r\n\t\t\tuint32 blockTimestampLast\r\n\t\t);\r\n\r\n\tfunction price0CumulativeLast() external view returns (uint256);\r\n\r\n\tfunction price1CumulativeLast() external view returns (uint256);\r\n\r\n\tfunction kLast() external view returns (uint256);\r\n\r\n\tfunction mint(address to) external returns (uint256 liquidity);\r\n\r\n\tfunction burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n\tfunction swap(\r\n\t\tuint256 amount0Out,\r\n\t\tuint256 amount1Out,\r\n\t\taddress to,\r\n\t\tbytes calldata data\r\n\t) external;\r\n\r\n\tfunction skim(address to) external;\r\n\r\n\tfunction sync() external;\r\n\r\n\tfunction initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2ERC20 {\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tfunction name() external pure returns (string memory);\r\n\r\n\tfunction symbol() external pure returns (string memory);\r\n\r\n\tfunction decimals() external pure returns (uint8);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint256);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) external returns (bool);\r\n\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n\tfunction nonces(address owner) external view returns (uint256);\r\n\r\n\tfunction permit(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 value,\r\n\t\tuint256 deadline,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external;\r\n}\r\n\r\ninterface IERC20 {\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tfunction name() external view returns (string memory);\r\n\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint256);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Callee {\r\n\tfunction uniswapV2Call(\r\n\t\taddress sender,\r\n\t\tuint256 amount0,\r\n\t\tuint256 amount1,\r\n\t\tbytes calldata data\r\n\t) external;\r\n}\r\n\r\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\r\n\tusing SafeMath for uint256;\r\n\r\n\tstring public constant name = \"Telefy LP\";\r\n\tstring public constant symbol = \"TEL-LP\";\r\n\tuint8 public constant decimals = 18;\r\n\tuint256 public totalSupply;\r\n\tmapping(address => uint256) public balanceOf;\r\n\tmapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\tbytes32 public DOMAIN_SEPARATOR;\r\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant PERMIT_TYPEHASH =\r\n\t\t0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\tmapping(address => uint256) public nonces;\r\n\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tconstructor() public {\r\n\t\tuint256 chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid\r\n\t\t}\r\n\t\tDOMAIN_SEPARATOR = keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256(\r\n\t\t\t\t\t\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n\t\t\t\t),\r\n\t\t\t\tkeccak256(bytes(name)),\r\n\t\t\t\tkeccak256(bytes(\"1\")),\r\n\t\t\t\tchainId,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction _mint(address to, uint256 value) internal {\r\n\t\ttotalSupply = totalSupply.add(value);\r\n\t\tbalanceOf[to] = balanceOf[to].add(value);\r\n\t\temit Transfer(address(0), to, value);\r\n\t}\r\n\r\n\tfunction _burn(address from, uint256 value) internal {\r\n\t\tbalanceOf[from] = balanceOf[from].sub(value);\r\n\t\ttotalSupply = totalSupply.sub(value);\r\n\t\temit Transfer(from, address(0), value);\r\n\t}\r\n\r\n\tfunction _approve(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) private {\r\n\t\tallowance[owner][spender] = value;\r\n\t\temit Approval(owner, spender, value);\r\n\t}\r\n\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) private {\r\n\t\tbalanceOf[from] = balanceOf[from].sub(value);\r\n\t\tbalanceOf[to] = balanceOf[to].add(value);\r\n\t\temit Transfer(from, to, value);\r\n\t}\r\n\r\n\tfunction approve(address spender, uint256 value) external returns (bool) {\r\n\t\t_approve(msg.sender, spender, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transfer(address to, uint256 value) external returns (bool) {\r\n\t\t_transfer(msg.sender, to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) external returns (bool) {\r\n\t\tif (allowance[from][msg.sender] != uint256(-1)) {\r\n\t\t\tallowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n\t\t}\r\n\t\t_transfer(from, to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction permit(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 value,\r\n\t\tuint256 deadline,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external {\r\n\t\trequire(deadline >= block.timestamp, \"Telefy: EXPIRED\");\r\n\t\tbytes32 digest = keccak256(\r\n\t\t\tabi.encodePacked(\r\n\t\t\t\t\"\\x19\\x01\",\r\n\t\t\t\tDOMAIN_SEPARATOR,\r\n\t\t\t\tkeccak256(\r\n\t\t\t\t\tabi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t);\r\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\r\n\t\trequire(\r\n\t\t\trecoveredAddress != address(0) && recoveredAddress == owner,\r\n\t\t\t\"Telefy: INVALID_SIGNATURE\"\r\n\t\t);\r\n\t\t_approve(owner, spender, value);\r\n\t}\r\n}\r\n\r\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\r\n\tusing SafeMath for uint256;\r\n\tusing UQ112x112 for uint224;\r\n\r\n\tuint256 public constant MINIMUM_LIQUIDITY = 10**3;\r\n\tbytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n\r\n\taddress public factory;\r\n\taddress public token0;\r\n\taddress public token1;\r\n\r\n\tuint112 private reserve0; // uses single storage slot, accessible via getReserves\r\n\tuint112 private reserve1; // uses single storage slot, accessible via getReserves\r\n\tuint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n\tuint256 public price0CumulativeLast;\r\n\tuint256 public price1CumulativeLast;\r\n\tuint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n\tuint256 private unlocked = 1;\r\n\tmodifier lock() {\r\n\t\trequire(unlocked == 1, \"Telefy: LOCKED\");\r\n\t\tunlocked = 0;\r\n\t\t_;\r\n\t\tunlocked = 1;\r\n\t}\r\n\r\n\tfunction getReserves()\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint112 _reserve0,\r\n\t\t\tuint112 _reserve1,\r\n\t\t\tuint32 _blockTimestampLast\r\n\t\t)\r\n\t{\r\n\t\t_reserve0 = reserve0;\r\n\t\t_reserve1 = reserve1;\r\n\t\t_blockTimestampLast = blockTimestampLast;\r\n\t}\r\n\r\n\tfunction _safeTransfer(\r\n\t\taddress token,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) private {\r\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n\t\trequire(\r\n\t\t\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\r\n\t\t\t\"Telefy: TRANSFER_FAILED\"\r\n\t\t);\r\n\t}\r\n\r\n\tevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n\tevent Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n\tevent Swap(\r\n\t\taddress indexed sender,\r\n\t\tuint256 amount0In,\r\n\t\tuint256 amount1In,\r\n\t\tuint256 amount0Out,\r\n\t\tuint256 amount1Out,\r\n\t\taddress indexed to\r\n\t);\r\n\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n\tconstructor() public {\r\n\t\tfactory = msg.sender;\r\n\t}\r\n\r\n\t// called once by the factory at time of deployment\r\n\tfunction initialize(address _token0, address _token1) external {\r\n\t\trequire(msg.sender == factory, \"Telefy: FORBIDDEN\"); // sufficient check\r\n\t\ttoken0 = _token0;\r\n\t\ttoken1 = _token1;\r\n\t}\r\n\r\n\t// update reserves and, on the first call per block, price accumulators\r\n\tfunction _update(\r\n\t\tuint256 balance0,\r\n\t\tuint256 balance1,\r\n\t\tuint112 _reserve0,\r\n\t\tuint112 _reserve1\r\n\t) private {\r\n\t\trequire(balance0 <= uint112(-1) && balance1 <= uint112(-1), \"Telefy: OVERFLOW\");\r\n\t\tuint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n\t\tuint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n\t\tif (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n\t\t\t// * never overflows, and + overflow is desired\r\n\t\t\tprice0CumulativeLast +=\r\n\t\t\t\tuint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\r\n\t\t\t\ttimeElapsed;\r\n\t\t\tprice1CumulativeLast +=\r\n\t\t\t\tuint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\r\n\t\t\t\ttimeElapsed;\r\n\t\t}\r\n\t\treserve0 = uint112(balance0);\r\n\t\treserve1 = uint112(balance1);\r\n\t\tblockTimestampLast = blockTimestamp;\r\n\t\temit Sync(reserve0, reserve1);\r\n\t}\r\n\r\n\t// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n\tfunction _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n\t\taddress feeTo = IUniswapV2Factory(factory).feeTo();\r\n\t\tfeeOn = feeTo != address(0);\r\n\t\tuint256 _kLast = kLast; // gas savings\r\n\t\tif (feeOn) {\r\n\t\t\tif (_kLast != 0) {\r\n\t\t\t\tuint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\r\n\t\t\t\tuint256 rootKLast = Math.sqrt(_kLast);\r\n\t\t\t\tif (rootK > rootKLast) {\r\n\t\t\t\t\tuint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\r\n\t\t\t\t\tuint256 denominator = rootK.mul(5).add(rootKLast);\r\n\t\t\t\t\tuint256 liquidity = numerator / denominator;\r\n\t\t\t\t\tif (liquidity > 0) _mint(feeTo, liquidity);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (_kLast != 0) {\r\n\t\t\tkLast = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// this low-level function should be called from a contract which performs important safety checks\r\n\tfunction mint(address to) external lock returns (uint256 liquidity) {\r\n\t\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n\t\tuint256 balance0 = IERC20(token0).balanceOf(address(this));\r\n\t\tuint256 balance1 = IERC20(token1).balanceOf(address(this));\r\n\t\tuint256 amount0 = balance0.sub(_reserve0);\r\n\t\tuint256 amount1 = balance1.sub(_reserve1);\r\n\r\n\t\tbool feeOn = _mintFee(_reserve0, _reserve1);\r\n\t\tuint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n\t\tif (_totalSupply == 0) {\r\n\t\t\tliquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n\t\t\t_mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n\t\t} else {\r\n\t\t\tliquidity = Math.min(\r\n\t\t\t\tamount0.mul(_totalSupply) / _reserve0,\r\n\t\t\t\tamount1.mul(_totalSupply) / _reserve1\r\n\t\t\t);\r\n\t\t}\r\n\t\trequire(liquidity > 0, \"Telefy: INSUFFICIENT_LIQUIDITY_MINTED\");\r\n\t\t_mint(to, liquidity);\r\n\r\n\t\t_update(balance0, balance1, _reserve0, _reserve1);\r\n\t\tif (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\r\n\t\temit Mint(msg.sender, amount0, amount1);\r\n\t}\r\n\r\n\t// this low-level function should be called from a contract which performs important safety checks\r\n\tfunction burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\r\n\t\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n\t\taddress _token0 = token0; // gas savings\r\n\t\taddress _token1 = token1; // gas savings\r\n\t\tuint256 balance0 = IERC20(_token0).balanceOf(address(this));\r\n\t\tuint256 balance1 = IERC20(_token1).balanceOf(address(this));\r\n\t\tuint256 liquidity = balanceOf[address(this)];\r\n\r\n\t\tbool feeOn = _mintFee(_reserve0, _reserve1);\r\n\t\tuint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n\t\tamount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\r\n\t\tamount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\r\n\t\trequire(amount0 > 0 && amount1 > 0, \"Telefy: INSUFFICIENT_LIQUIDITY_BURNED\");\r\n\t\t_burn(address(this), liquidity);\r\n\t\t_safeTransfer(_token0, to, amount0);\r\n\t\t_safeTransfer(_token1, to, amount1);\r\n\t\tbalance0 = IERC20(_token0).balanceOf(address(this));\r\n\t\tbalance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n\t\t_update(balance0, balance1, _reserve0, _reserve1);\r\n\t\tif (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\r\n\t\temit Burn(msg.sender, amount0, amount1, to);\r\n\t}\r\n\r\n\t// this low-level function should be called from a contract which performs important safety checks\r\n\tfunction swap(\r\n\t\tuint256 amount0Out,\r\n\t\tuint256 amount1Out,\r\n\t\taddress to,\r\n\t\tbytes calldata data\r\n\t) external lock {\r\n\t\trequire(amount0Out > 0 || amount1Out > 0, \"Telefy: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n\t\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n\t\trequire(amount0Out < _reserve0 && amount1Out < _reserve1, \"Telefy: INSUFFICIENT_LIQUIDITY\");\r\n\r\n\t\tuint256 balance0;\r\n\t\tuint256 balance1;\r\n\t\t{\r\n\t\t\t// scope for _token{0,1}, avoids stack too deep errors\r\n\t\t\taddress _token0 = token0;\r\n\t\t\taddress _token1 = token1;\r\n\t\t\trequire(to != _token0 && to != _token1, \"Telefy: INVALID_TO\");\r\n\t\t\tif (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n\t\t\tif (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n\t\t\tif (data.length > 0)\r\n\t\t\t\tIUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n\t\t\tbalance0 = IERC20(_token0).balanceOf(address(this));\r\n\t\t\tbalance1 = IERC20(_token1).balanceOf(address(this));\r\n\t\t}\r\n\t\tuint256 amount0In = balance0 > _reserve0 - amount0Out\r\n\t\t\t? balance0 - (_reserve0 - amount0Out)\r\n\t\t\t: 0;\r\n\t\tuint256 amount1In = balance1 > _reserve1 - amount1Out\r\n\t\t\t? balance1 - (_reserve1 - amount1Out)\r\n\t\t\t: 0;\r\n\t\trequire(amount0In > 0 || amount1In > 0, \"Telefy: INSUFFICIENT_INPUT_AMOUNT\");\r\n\t\t{\r\n\t\t\t// scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n\t\t\tuint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(27) / 10);\r\n\t\t\tuint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(27) / 10);\r\n\t\t\trequire(\r\n\t\t\t\tbalance0Adjusted.mul(balance1Adjusted) >=\r\n\t\t\t\t\tuint256(_reserve0).mul(_reserve1).mul(1000**2),\r\n\t\t\t\t\"Telefy: K\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t_update(balance0, balance1, _reserve0, _reserve1);\r\n\t\temit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n\t}\r\n\r\n\t// force balances to match reserves\r\n\tfunction skim(address to) external lock {\r\n\t\taddress _token0 = token0; // gas savings\r\n\t\taddress _token1 = token1; // gas savings\r\n\t\t_safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n\t\t_safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n\t}\r\n\r\n\t// force reserves to match balances\r\n\tfunction sync() external lock {\r\n\t\t_update(\r\n\t\t\tIERC20(token0).balanceOf(address(this)),\r\n\t\t\tIERC20(token1).balanceOf(address(this)),\r\n\t\t\treserve0,\r\n\t\t\treserve1\r\n\t\t);\r\n\t}\r\n}\r\n\r\ncontract UniswapV2Factory is IUniswapV2Factory {\r\n\tbytes32 public constant INIT_CODE_PAIR_HASH =\r\n\t\tkeccak256(abi.encodePacked(type(UniswapV2Pair).creationCode));\r\n\taddress public feeTo;\r\n\taddress public feeToSetter;\r\n\r\n\tmapping(address => mapping(address => address)) public getPair;\r\n\taddress[] public allPairs;\r\n\r\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n\tconstructor(address _feeToSetter) public {\r\n\t\tfeeToSetter = _feeToSetter;\r\n\t}\r\n\r\n\tfunction allPairsLength() external view returns (uint256) {\r\n\t\treturn allPairs.length;\r\n\t}\r\n\r\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair) {\r\n\t\trequire(tokenA != tokenB, \"Telefy: IDENTICAL_ADDRESSES\");\r\n\t\t(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n\t\trequire(token0 != address(0), \"Telefy: ZERO_ADDRESS\");\r\n\t\trequire(getPair[token0][token1] == address(0), \"Telefy: PAIR_EXISTS\"); // single check is sufficient\r\n\t\tbytes memory bytecode = type(UniswapV2Pair).creationCode;\r\n\t\tbytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n\t\tassembly {\r\n\t\t\tpair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n\t\t}\r\n\t\tIUniswapV2Pair(pair).initialize(token0, token1);\r\n\t\tgetPair[token0][token1] = pair;\r\n\t\tgetPair[token1][token0] = pair; // populate mapping in the reverse direction\r\n\t\tallPairs.push(pair);\r\n\t\temit PairCreated(token0, token1, pair, allPairs.length);\r\n\t}\r\n\r\n\tfunction setFeeTo(address _feeTo) external {\r\n\t\trequire(msg.sender == feeToSetter, \"Telefy: FORBIDDEN\");\r\n\t\tfeeTo = _feeTo;\r\n\t}\r\n\r\n\tfunction setFeeToSetter(address _feeToSetter) external {\r\n\t\trequire(msg.sender == feeToSetter, \"Telefy: FORBIDDEN\");\r\n\t\tfeeToSetter = _feeToSetter;\r\n\t}\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n\tfunction add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\trequire((z = x + y) >= x, \"ds-math-add-overflow\");\r\n\t}\r\n\r\n\tfunction sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\trequire((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n\t}\r\n\r\n\tfunction mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\trequire(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n\t}\r\n}\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n\tfunction min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\tz = x < y ? x : y;\r\n\t}\r\n\r\n\t// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n\tfunction sqrt(uint256 y) internal pure returns (uint256 z) {\r\n\t\tif (y > 3) {\r\n\t\t\tz = y;\r\n\t\t\tuint256 x = y / 2 + 1;\r\n\t\t\twhile (x < z) {\r\n\t\t\t\tz = x;\r\n\t\t\t\tx = (y / x + x) / 2;\r\n\t\t\t}\r\n\t\t} else if (y != 0) {\r\n\t\t\tz = 1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n\tuint224 constant Q112 = 2**112;\r\n\r\n\t// encode a uint112 as a UQ112x112\r\n\tfunction encode(uint112 y) internal pure returns (uint224 z) {\r\n\t\tz = uint224(y) * Q112; // never overflows\r\n\t}\r\n\r\n\t// divide a UQ112x112 by a uint112, returning a UQ112x112\r\n\tfunction uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n\t\tz = x / uint224(y);\r\n\t}\r\n}",
    "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "UniswapV2Pair",
    "CompilerVersion": "v0.5.16+commit.9c3226ce",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "None",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "bzzr://0e5bbfccdc867732b2f0faba701f00bbb60aeeb6448d89756a7c2a6653769fc4"
}