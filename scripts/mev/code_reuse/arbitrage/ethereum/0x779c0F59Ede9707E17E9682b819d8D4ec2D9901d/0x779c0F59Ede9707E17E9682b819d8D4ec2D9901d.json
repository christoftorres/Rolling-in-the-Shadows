{
    "SourceCode": "# @version ^0.3\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\nOWNER_ADDR: immutable(address)\r\nWETH_ADDR: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\nV3_FACTORY: constant(address) = 0x1F98431c8aD98523631AE4a59f267346ea31F984\r\n\r\nMAX_PAYLOADS: constant(uint256) = 16\r\nMAX_PAYLOAD_BYTES: constant(uint256) = 1024\r\n\r\n\r\nstruct payload:\r\n    target: address\r\n    calldata: Bytes[MAX_PAYLOAD_BYTES]\r\n    value: uint256\r\n\r\n\r\n@external\r\n@payable\r\ndef __init__():\r\n    OWNER_ADDR = msg.sender\r\n    \r\n    # wrap initial Ether to WETH\r\n    if msg.value > 0:\r\n        raw_call(\r\n            WETH_ADDR,\r\n            method_id('deposit()'),\r\n            value=msg.value\r\n        )\r\n\r\n\r\n@external\r\n@payable\r\ndef execute_payloads(\r\n    payloads: DynArray[payload, MAX_PAYLOADS],\r\n    start_token_address: address\r\n    ):\r\n    \r\n    assert msg.sender == OWNER_ADDR, \"ERR_OWNER\"\r\n\r\n    start_token: ERC20 = ERC20(start_token_address)\r\n    start_amount: uint256 = start_token.balanceOf(self)\r\n   \r\n    for _payload in payloads:\r\n        raw_call(\r\n            _payload.target,\r\n            _payload.calldata,\r\n            value=_payload.value,\r\n        )\r\n\r\n    assert start_token.balanceOf(self) >= start_amount, \"ERR_BALANCE\"\r\n\r\n\r\n@internal\r\n@pure\r\ndef verifyCallback(\r\n    tokenA: address, \r\n    tokenB: address, \r\n    fee: uint24\r\n) -> address:   \r\n            \r\n    token0: address = tokenA\r\n    token1: address = tokenB\r\n\r\n    if convert(tokenA,uint160) > convert(tokenB,uint160):        \r\n        token0 = tokenB\r\n        token1 = tokenA\r\n        \r\n    return convert(\r\n        slice(\r\n            convert(\r\n                convert(\r\n                    keccak256(\r\n                        concat(\r\n                            b'\\xFF',\r\n                            convert(V3_FACTORY,bytes20),\r\n                            keccak256(\r\n                                _abi_encode(\r\n                                    token0,\r\n                                    token1,\r\n                                    fee\r\n                                )\r\n                            ),\r\n                            0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,\r\n                        )\r\n                    ),\r\n                    uint256\r\n                ),\r\n                bytes32\r\n            ),\r\n            12,\r\n            20,\r\n        ),\r\n        address\r\n    )\r\n\r\n\r\n@external\r\n@payable\r\ndef uniswapV3SwapCallback(\r\n    amount0: int256, \r\n    amount1: int256, \r\n    data: Bytes[32]\r\n):\r\n\r\n    # get the token0/token1 addresses and fee reported by msg.sender\r\n    token0: address = extract32(\r\n        raw_call(\r\n            msg.sender,\r\n            method_id('token0()'),\r\n            max_outsize=32,\r\n        ),\r\n        0,\r\n        output_type=address\r\n    )\r\n\r\n    token1: address = extract32(\r\n        raw_call(\r\n            msg.sender,\r\n            method_id('token1()'),\r\n            max_outsize=32,\r\n        ),\r\n        0,\r\n        output_type=address\r\n    )\r\n\r\n    fee: uint24 = extract32(\r\n        raw_call(\r\n            msg.sender,\r\n            method_id('fee()'),\r\n            max_outsize=32,\r\n        ),\r\n        0,\r\n        output_type=uint24\r\n    )\r\n    \r\n    assert msg.sender == self.verifyCallback(token0,token1,fee), \"!V3LP\"\r\n\r\n    # transfer token back to pool\r\n    if amount0 > 0:\r\n        raw_call(\r\n            token0,\r\n            _abi_encode(\r\n                msg.sender,\r\n                amount0,\r\n                method_id=method_id('transfer(address,uint256)')\r\n            )\r\n        )\r\n    elif amount1 > 0:\r\n        raw_call(\r\n            token1,\r\n            _abi_encode(\r\n                msg.sender,\r\n                amount1,\r\n                method_id=method_id('transfer(address,uint256)')\r\n            )\r\n        )\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    # accept basic Ether transfers to the contract with no calldata\r\n    if len(msg.data) == 0:\r\n        return\r\n    \r\n    # revert on all other calls\r\n    else:\r\n        raise",
    "ABI": "[{\"stateMutability\":\"payable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"execute_payloads\",\"inputs\":[{\"name\":\"payloads\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"value\",\"type\":\"uint256\"}]},{\"name\":\"start_token_address\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"uniswapV3SwapCallback\",\"inputs\":[{\"name\":\"amount0\",\"type\":\"int256\"},{\"name\":\"amount1\",\"type\":\"int256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]",
    "ContractName": "Vyper_contract",
    "CompilerVersion": "vyper:0.3.7",
    "OptimizationUsed": "0",
    "Runs": "0",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "None",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}