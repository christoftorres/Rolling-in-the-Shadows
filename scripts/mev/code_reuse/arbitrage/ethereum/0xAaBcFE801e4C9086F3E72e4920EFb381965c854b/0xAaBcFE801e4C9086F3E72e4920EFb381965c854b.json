{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"flattenedBundleExecutor.sol\": {\r\n      \"content\": \"// Sources flattened with hardhat v2.10.1 https://hardhat.org\\r\\n\\r\\n// File contracts/Interfaces.sol\\r\\n\\r\\n// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender's allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller's\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Callee {\\r\\n  function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\r\\n}\\r\\n\\r\\n\\r\\n// File contracts/Libraries.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary SafeMath {\\r\\n  /**\\r\\n   * @dev Returns the addition of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity's `+` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Addition cannot overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, 'SafeMath: addition overflow');\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b <= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity's `*` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Multiplication cannot overflow.\\r\\n   */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, 'SafeMath: division by zero');\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b > 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, 'SafeMath: modulo by zero');\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts with custom message when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n  /**\\r\\n   * @dev Returns true if `account` is a contract.\\r\\n   *\\r\\n   * [IMPORTANT]\\r\\n   * ====\\r\\n   * It is unsafe to assume that an address for which this function returns\\r\\n   * false is an externally-owned account (EOA) and not a contract.\\r\\n   *\\r\\n   * Among others, `isContract` will return false for the following\\r\\n   * types of addresses:\\r\\n   *\\r\\n   *  - an externally-owned account\\r\\n   *  - a contract in construction\\r\\n   *  - an address where a contract will be created\\r\\n   *  - an address where a contract lived, but was destroyed\\r\\n   * ====\\r\\n   */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n    // for accounts without code, i.e. `keccak256('')`\\r\\n    bytes32 codehash;\\r\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n    // solhint-disable-next-line no-inline-assembly\\r\\n    assembly {\\r\\n      codehash := extcodehash(account)\\r\\n    }\\r\\n    return (codehash != accountHash && codehash != 0x0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n   * `recipient`, forwarding all available gas and reverting on errors.\\r\\n   *\\r\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n   * imposed by `transfer`, making them unable to receive funds via\\r\\n   * `transfer`. {sendValue} removes this limitation.\\r\\n   *\\r\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n   *\\r\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n   * taken to not create reentrancy vulnerabilities. Consider using\\r\\n   * {ReentrancyGuard} or the\\r\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n   */\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n    (bool success, ) = recipient.call{value: amount}('');\\r\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\r\\n    );\\r\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool success, bytes memory returndata) = address(token).call(data);\\r\\n    require(success, 'SafeERC20: low-level call failed');\\r\\n\\r\\n    if (returndata.length > 0) {\\r\\n      // Return data is optional\\r\\n      // solhint-disable-next-line max-line-length\\r\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary DataTypes {\\r\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\r\\n  struct ReserveData {\\r\\n    //stores the reserve configuration\\r\\n    ReserveConfigurationMap configuration;\\r\\n    //the liquidity index. Expressed in ray\\r\\n    uint128 liquidityIndex;\\r\\n    //variable borrow index. Expressed in ray\\r\\n    uint128 variableBorrowIndex;\\r\\n    //the current supply rate. Expressed in ray\\r\\n    uint128 currentLiquidityRate;\\r\\n    //the current variable borrow rate. Expressed in ray\\r\\n    uint128 currentVariableBorrowRate;\\r\\n    //the current stable borrow rate. Expressed in ray\\r\\n    uint128 currentStableBorrowRate;\\r\\n    uint40 lastUpdateTimestamp;\\r\\n    //tokens addresses\\r\\n    address aTokenAddress;\\r\\n    address stableDebtTokenAddress;\\r\\n    address variableDebtTokenAddress;\\r\\n    //address of the interest rate strategy\\r\\n    address interestRateStrategyAddress;\\r\\n    //the id of the reserve. Represents the position in the list of the active reserves\\r\\n    uint8 id;\\r\\n  }\\r\\n\\r\\n  struct ReserveConfigurationMap {\\r\\n    //bit 0-15: LTV\\r\\n    //bit 16-31: Liq. threshold\\r\\n    //bit 32-47: Liq. bonus\\r\\n    //bit 48-55: Decimals\\r\\n    //bit 56: Reserve is active\\r\\n    //bit 57: reserve is frozen\\r\\n    //bit 58: borrowing is enabled\\r\\n    //bit 59: stable rate borrowing enabled\\r\\n    //bit 60-63: reserved\\r\\n    //bit 64-79: reserve factor\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  struct UserConfigurationMap {\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\r\\n}\\r\\n\\r\\n\\r\\n// File contracts/BundleExecutor.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n    function deposit() external payable;\\r\\n    function withdraw(uint) external;\\r\\n}\\r\\n\\r\\ncontract FlashBotsMultiCallFL is IUniswapV2Callee {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public constant WETH_address = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\r\\n    \\r\\n    IWETH private constant WETH = IWETH(WETH_address);\\r\\n\\r\\n    IUniswapV2Factory public immutable _uniswapFactory;\\r\\n\\r\\n    constructor(IUniswapV2Factory uniswapFactory) payable {\\r\\n        _uniswapFactory = uniswapFactory;\\r\\n    }\\r\\n\\r\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override {\\r\\n        uint amount = SafeMath.add(amount0, amount1);\\r\\n        uint debt = SafeMath.add(amount, (SafeMath.add(SafeMath.div(SafeMath.mul(amount, 3), 997), 1)));\\r\\n\\r\\n        uniswapWethFLParams(amount, data, debt);\\r\\n    }\\r\\n\\r\\n    function flashloan(address token0, address token1, uint256 amountToBorrow, bytes memory _params) external {\\r\\n        address receiverAddress = address(this);\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(_uniswapFactory.getPair(token0, token1));\\r\\n\\r\\n        if(pair.token0() == WETH_address) {\\r\\n            pair.swap(amountToBorrow, 0, receiverAddress, _params);\\r\\n        } else {\\r\\n            pair.swap(0, amountToBorrow, receiverAddress, _params);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function uniswapWethFLParams(uint256 _amountToFirstMarket, bytes memory _params, uint256 debt) internal {\\r\\n        (uint256 _ethAmountToCoinbase, address[] memory _targets, bytes[] memory _payloads) = abi.decode(_params, (uint256, address[], bytes[]));\\r\\n        require(_targets.length == _payloads.length);\\r\\n\\r\\n        WETH.transfer(_targets[0], _amountToFirstMarket);\\r\\n        for (uint256 i = 0; i < _targets.length; i++) {\\r\\n            (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\\r\\n            require(_success); \\r\\n        }\\r\\n\\r\\n        uint256 _wethBalanceAfter = WETH.balanceOf(address(this));\\r\\n\\r\\n        uint256 _profit = _wethBalanceAfter - debt - _ethAmountToCoinbase;\\r\\n        \\r\\n        require(_profit >= 0);\\r\\n\\r\\n        WETH.withdraw(_ethAmountToCoinbase + _profit);\\r\\n        block.coinbase.transfer(_ethAmountToCoinbase);\\r\\n        payable(tx.origin).transfer(_profit);\\r\\n        \\r\\n        address token0 = IUniswapV2Pair(msg.sender).token0();\\r\\n        address token1 = IUniswapV2Pair(msg.sender).token1();\\r\\n        address pair = _uniswapFactory.getPair(token0, token1);\\r\\n        //Return funds\\r\\n        IERC20(WETH_address).transfer(pair, debt);\\r\\n    }\\r\\n\\r\\n    function call(address payable _to, uint256 _value, bytes calldata _data) external payable returns (bytes memory) {\\r\\n        require(_to != address(0));\\r\\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\\r\\n        require(_success);\\r\\n        return _result;\\r\\n    }\\r\\n    receive() external payable {\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"uniswapFactory\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToBorrow\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"flashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "FlashBotsMultiCallFL",
    "CompilerVersion": "v0.8.7+commit.e28d00a7",
    "OptimizationUsed": "0",
    "Runs": "200",
    "ConstructorArguments": "0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}