{
    "SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface IERC20 {\\n\\n    function balanceOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"},\"ISwapsCallee.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface ISwapsCallee {\\n\\n    function swapsCall(\\n        address _sender,\\n        uint256 _amount0,\\n        uint256 _amount1,\\n        bytes calldata _data\\n    )\\n        external;\\n}\\n\"},\"ISwapsERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface ISwapsERC20 {\\n\\n    function name()\\n        external\\n        pure\\n        returns (string memory);\\n\\n    function symbol()\\n        external\\n        pure\\n        returns (string memory);\\n\\n    function decimals()\\n        external\\n        pure\\n        returns (uint8);\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function DOMAIN_SEPARATOR()\\n        external\\n        view\\n        returns (bytes32);\\n\\n    function PERMIT_TYPEHASH()\\n        external\\n        pure\\n        returns (bytes32);\\n\\n    function nonces(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external;\\n}\\n\"},\"ISwapsFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface ISwapsFactory {\\n\\n    function feeTo()\\n        external\\n        view\\n        returns (address);\\n\\n    function feeToSetter()\\n        external\\n        view\\n        returns (address);\\n\\n    function getPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairsLength()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function createPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        returns (address pair);\\n\\n    function setFeeTo(\\n        address\\n    )\\n        external;\\n\\n    function setFeeToSetter(\\n        address\\n    )\\n        external;\\n\\n    function cloneTarget()\\n        external\\n        view\\n        returns (address target);\\n}\\n\"},\"ISwapsPair.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\nimport \\\"./ISwapsERC20.sol\\\";\\n\\ninterface ISwapsPair is ISwapsERC20 {\\n\\n    function MINIMUM_LIQUIDITY()\\n        external\\n        pure\\n        returns (uint256);\\n\\n    function factory()\\n        external\\n        view\\n        returns (address);\\n\\n    function token0()\\n        external\\n        view\\n        returns (address);\\n\\n    function token1()\\n        external\\n        view\\n        returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function price1CumulativeLast()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function kLast()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function mint(\\n        address _to\\n    )\\n        external\\n        returns (uint256 liquidity);\\n\\n    function burn(\\n        address _to\\n    )\\n        external\\n        returns (\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    function swap(\\n        uint256 _amount0Out,\\n        uint256 _amount1Out,\\n        address _to,\\n        bytes calldata _data\\n    )\\n        external;\\n\\n    function skim()\\n        external;\\n\\n    function initialize(\\n        address,\\n        address\\n    )\\n        external;\\n}\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface IWETH {\\n\\n    function deposit()\\n        external\\n        payable;\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool);\\n\\n    function withdraw(\\n        uint256\\n    )\\n        external;\\n}\\n\"},\"SwapsERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ncontract SwapsERC20 {\\n\\n    string public constant name = \\\"Verse Exchange\\\";\\n    string public constant symbol = \\\"VERSE-X\\\";\\n    uint8 public constant decimals = 18;\\n\\n    address constant ZERO_ADDRESS = address(0);\\n    uint256 constant UINT256_MAX = type(uint256).max;\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\\n        \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    constructor() {\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        totalSupply =\\n        totalSupply + _value;\\n\\n        unchecked {\\n            balanceOf[_to] =\\n            balanceOf[_to] + _value;\\n        }\\n\\n        emit Transfer(\\n            ZERO_ADDRESS,\\n            _to,\\n            _value\\n        );\\n    }\\n\\n    function _burn(\\n        address _from,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        unchecked {\\n            totalSupply =\\n            totalSupply - _value;\\n        }\\n\\n        balanceOf[_from] =\\n        balanceOf[_from] - _value;\\n\\n        emit Transfer(\\n            _from,\\n            ZERO_ADDRESS,\\n            _value\\n        );\\n    }\\n\\n    function _approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _value\\n    )\\n        private\\n    {\\n        allowance[_owner][_spender] = _value;\\n\\n        emit Approval(\\n            _owner,\\n            _spender,\\n            _value\\n        );\\n    }\\n\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        private\\n    {\\n        balanceOf[_from] =\\n        balanceOf[_from] - _value;\\n\\n        unchecked {\\n            balanceOf[_to] =\\n            balanceOf[_to] + _value;\\n        }\\n\\n        emit Transfer(\\n            _from,\\n            _to,\\n            _value\\n        );\\n    }\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            _spender,\\n            _value\\n        );\\n\\n        return true;\\n    }\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool)\\n    {\\n        _transfer(\\n            msg.sender,\\n            _to,\\n            _value\\n        );\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool)\\n    {\\n        if (allowance[_from][msg.sender] != UINT256_MAX) {\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n\\n        _transfer(\\n            _from,\\n            _to,\\n            _value\\n        );\\n\\n        return true;\\n    }\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external\\n    {\\n        require(\\n            _deadline \\u003e= block.timestamp,\\n            \\\"SwapsERC20: PERMIT_CALL_EXPIRED\\\"\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        _owner,\\n                        _spender,\\n                        _value,\\n                        nonces[_owner]++,\\n                        _deadline\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (uint256(_s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"SwapsERC20: INVALID_SIGNATURE\\\");\\n        }\\n\\n        address recoveredAddress = ecrecover(\\n            digest,\\n            _v,\\n            _r,\\n            _s\\n        );\\n\\n        require(\\n            recoveredAddress != ZERO_ADDRESS \\u0026\\u0026\\n            recoveredAddress == _owner,\\n            \\\"SwapsERC20: INVALID_SIGNATURE\\\"\\n        );\\n\\n        _approve(\\n            _owner,\\n            _spender,\\n            _value\\n        );\\n    }\\n}\\n\"},\"SwapsFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\nimport \\\"./ISwapsPair.sol\\\";\\nimport \\\"./SwapsPair.sol\\\";\\n\\ncontract SwapsFactory {\\n\\n    address public feeTo;\\n    address public feeToSetter;\\n    address public immutable cloneTarget;\\n    address constant ZERO_ADDRESS = address(0);\\n\\n    address[] public allPairs;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e address)) public getPair;\\n\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    constructor(\\n        address _feeToSetter\\n    ) {\\n        if (_feeToSetter == ZERO_ADDRESS) {\\n            revert(\\\"SwapsFactory: INVALID_INPUT\\\");\\n        }\\n\\n        feeToSetter = _feeToSetter;\\n        feeTo = _feeToSetter;\\n\\n        bytes32 salt;\\n        address pair;\\n\\n        bytes memory bytecode = type(SwapsPair).creationCode;\\n\\n        assembly {\\n            pair := create2(\\n                0,\\n                add(bytecode, 32),\\n                mload(bytecode),\\n                salt\\n            )\\n        }\\n\\n        cloneTarget = pair;\\n    }\\n\\n    function allPairsLength()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return allPairs.length;\\n    }\\n\\n    function createPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        returns (address pair)\\n    {\\n        require(\\n            _tokenA != _tokenB,\\n            \\\"SwapsFactory: IDENTICAL\\\"\\n        );\\n\\n        (address token0, address token1) = _tokenA \\u003c _tokenB\\n            ? (_tokenA, _tokenB)\\n            : (_tokenB, _tokenA);\\n\\n        require(\\n            token0 != ZERO_ADDRESS,\\n            \\\"SwapsFactory: ZERO_ADDRESS\\\"\\n        );\\n\\n        require(\\n            getPair[token0][token1] == ZERO_ADDRESS,\\n            \\\"SwapsFactory: PAIR_ALREADY_EXISTS\\\"\\n        );\\n\\n        bytes32 salt = keccak256(\\n            abi.encodePacked(\\n                token0,\\n                token1\\n            )\\n        );\\n\\n        bytes20 targetBytes = bytes20(\\n            cloneTarget\\n        );\\n\\n        assembly {\\n\\n            let clone := mload(0x40)\\n\\n            mstore(\\n                clone,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n\\n            mstore(\\n                add(clone, 0x14),\\n                targetBytes\\n            )\\n\\n            mstore(\\n                add(clone, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n\\n            pair := create2(0, clone, 0x37, salt)\\n        }\\n\\n        ISwapsPair(pair).initialize(\\n            token0,\\n            token1\\n        );\\n\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair;\\n\\n        allPairs.push(pair);\\n\\n        emit PairCreated(\\n            token0,\\n            token1,\\n            pair,\\n            allPairs.length\\n        );\\n    }\\n\\n    function setFeeTo(\\n        address _feeTo\\n    )\\n        external\\n    {\\n        require(\\n            msg.sender == feeToSetter,\\n            \\\"SwapsFactory: FORBIDDEN\\\"\\n        );\\n\\n        require(\\n            _feeTo != ZERO_ADDRESS,\\n            \\u0027SwapsFactory: ZERO_ADDRESS\\u0027\\n        );\\n\\n        feeTo = _feeTo;\\n    }\\n\\n    function setFeeToSetter(\\n        address _feeToSetter\\n    )\\n        external\\n    {\\n        require(\\n            msg.sender == feeToSetter,\\n            \\\"SwapsFactory: FORBIDDEN\\\"\\n        );\\n\\n        require(\\n            _feeToSetter != ZERO_ADDRESS,\\n            \\u0027SwapsFactory: ZERO_ADDRESS\\u0027\\n        );\\n\\n        feeToSetter = _feeToSetter;\\n    }\\n}\\n\\ncontract FactoryCodeCheck {\\n\\n    function factoryCodeHash()\\n        external\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            type(SwapsFactory).creationCode\\n        );\\n    }\\n\\n    function pairCodeHash()\\n        external\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            type(SwapsPair).creationCode\\n        );\\n    }\\n}\\n\"},\"SwapsHelper.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ncontract SwapsHelper {\\n\\n    uint256 constant UINT256_MAX = type(uint256).max;\\n    address constant ZERO_ADDRESS = address(0);\\n\\n    function sortTokens(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        internal\\n        pure\\n        returns (\\n            address token0,\\n            address token1\\n        )\\n    {\\n        require(\\n            _tokenA != _tokenB,\\n            \\\"SwapsHelper: IDENTICAL_ADDRESSES\\\"\\n        );\\n\\n        (token0, token1) = _tokenA \\u003c _tokenB\\n            ? (_tokenA, _tokenB)\\n            : (_tokenB, _tokenA);\\n\\n        require(\\n            token0 != ZERO_ADDRESS,\\n            \\\"SwapsHelper: ZERO_ADDRESS\\\"\\n        );\\n    }\\n\\n    function quote(\\n        uint256 _amountA,\\n        uint256 _reserveA,\\n        uint256 _reserveB\\n    )\\n        public\\n        pure\\n        returns (uint256 amountB)\\n    {\\n        require(\\n            _amountA \\u003e 0,\\n            \\\"SwapsHelper: INSUFFICIENT_AMOUNT\\\"\\n        );\\n\\n        require(\\n            _reserveA \\u003e 0 \\u0026\\u0026 _reserveB \\u003e 0,\\n            \\\"SwapsHelper: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        amountB = _amountA\\n            * _reserveB\\n            / _reserveA;\\n    }\\n\\n    function getAmountOut(\\n        uint256 _amountIn,\\n        uint256 _reserveIn,\\n        uint256 _reserveOut\\n    )\\n        public\\n        pure\\n        returns (uint256 amountOut)\\n    {\\n        require(\\n            _amountIn \\u003e 0,\\n            \\\"SwapsHelper: INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n\\n        require(\\n            _reserveIn \\u003e 0 \\u0026\\u0026 _reserveOut \\u003e 0,\\n            \\\"SwapsHelper: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 amountInWithFee = _amountIn * 997;\\n        uint256 numerator = amountInWithFee * _reserveOut;\\n        uint256 denominator = _reserveIn * 1000 + amountInWithFee;\\n\\n        amountOut = numerator / denominator;\\n    }\\n\\n    function getAmountIn(\\n        uint256 _amountOut,\\n        uint256 _reserveIn,\\n        uint256 _reserveOut\\n    )\\n        public\\n        pure\\n        returns (uint256 amountIn)\\n    {\\n        require(\\n            _amountOut \\u003e 0,\\n            \\\"SwapsHelper: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        require(\\n            _reserveIn \\u003e 0 \\u0026\\u0026\\n            _reserveOut \\u003e 0,\\n            \\\"SwapsHelper: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 numerator = _reserveIn * _amountOut * 1000;\\n        uint256 denominator = (_reserveOut - _amountOut) * 997;\\n\\n        amountIn = numerator / denominator + 1;\\n    }\\n\\n\\n    bytes4 constant TRANSFER = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transfer(address,uint256)\\\"\\n            )\\n        )\\n    );\\n\\n    bytes4 constant TRANSFER_FROM = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transferFrom(address,address,uint256)\\\"\\n            )\\n        )\\n    );\\n\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"SwapsHelper: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function _safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER_FROM,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"SwapsHelper: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function _safeTransferETH(\\n        address to,\\n        uint256 value\\n    )\\n        internal\\n    {\\n        (bool success,) = to.call{\\n            value: value\\n        }(new bytes(0));\\n\\n        require(\\n            success,\\n            \\\"SwapsHelper: ETH_TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function _pairFor(\\n        address _factory,\\n        address _tokenA,\\n        address _tokenB,\\n        address _implementation\\n    )\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        (address token0, address token1) = _tokenA \\u003c _tokenB\\n            ? (_tokenA, _tokenB)\\n            : (_tokenB, _tokenA);\\n\\n        bytes32 salt = keccak256(\\n            abi.encodePacked(\\n                token0,\\n                token1\\n            )\\n        );\\n\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, _implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, _factory))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n}\\n\"},\"SwapsPair.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISwapsFactory.sol\\\";\\nimport \\\"./ISwapsCallee.sol\\\";\\nimport \\\"./SwapsERC20.sol\\\";\\n\\ncontract SwapsPair is SwapsERC20 {\\n\\n    uint224 constant Q112 = 2 ** 112;\\n    uint112 constant UINT112_MAX = type(uint112).max;\\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\\n\\n    bytes4 private constant SELECTOR = bytes4(\\n        keccak256(bytes(\\u0027transfer(address,uint256)\\u0027))\\n    );\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n\\n    uint112 private reserve0;\\n    uint112 private reserve1;\\n    uint32  private blockTimestampLast;\\n\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n\\n    uint256 public kLast;\\n    uint256 private unlocked;\\n\\n    modifier lock() {\\n        require(\\n            unlocked == 1,\\n            \\\"SwapsPair: LOCKED\\\"\\n        );\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    event Mint(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n\\n    event Sync(\\n        uint112 reserve0,\\n        uint112 reserve1\\n    );\\n\\n    function initialize(\\n        address _token0,\\n        address _token1\\n    )\\n        external\\n    {\\n        require(\\n            factory == ZERO_ADDRESS,\\n            \\\"SwapsPair: ALREADY_INITIALIZED\\\"\\n        );\\n\\n        token0 = _token0;\\n        token1 = _token1;\\n        factory = msg.sender;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint112,\\n            uint112,\\n            uint32\\n        )\\n    {\\n        return (\\n            reserve0,\\n            reserve1,\\n            blockTimestampLast\\n        );\\n    }\\n\\n    function _update(\\n        uint256 _balance0,\\n        uint256 _balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    )\\n        private\\n    {\\n        require(\\n            _balance0 \\u003c= UINT112_MAX \\u0026\\u0026\\n            _balance1 \\u003c= UINT112_MAX,\\n            \\\"SwapsPair: OVERFLOW\\\"\\n        );\\n\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n\\n        unchecked {\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            if (timeElapsed \\u003e 0 \\u0026\\u0026 _reserve0 != 0 \\u0026\\u0026 _reserve1 != 0) {\\n                price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed;\\n                price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed;\\n            }\\n        }\\n\\n        reserve0 = uint112(_balance0);\\n        reserve1 = uint112(_balance1);\\n\\n        blockTimestampLast = blockTimestamp;\\n\\n        emit Sync(\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function _mintFee(\\n        uint112 _reserve0,\\n        uint112 _reserve1,\\n        uint256 _kLast\\n    )\\n        private\\n    {\\n        if (_kLast == 0) return;\\n\\n        uint256 rootK = sqrt(uint256(_reserve0) * _reserve1);\\n        uint256 rootKLast = sqrt(_kLast);\\n\\n        if (rootK \\u003e rootKLast) {\\n\\n            uint256 liquidity = totalSupply\\n                * (rootK - rootKLast)\\n                / (rootK * 5 + rootKLast);\\n\\n            if (liquidity == 0) return;\\n\\n            _mint(\\n                ISwapsFactory(factory).feeTo(),\\n                liquidity\\n            );\\n        }\\n    }\\n\\n    function mint(\\n        address _to\\n    )\\n        external\\n        lock\\n        returns (uint256 liquidity)\\n    {\\n        (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n\\n        ) = getReserves();\\n\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n\\n        uint256 amount0 = balance0 - _reserve0;\\n        uint256 amount1 = balance1 - _reserve1;\\n\\n        _mintFee(\\n            _reserve0,\\n            _reserve1,\\n            kLast\\n        );\\n\\n        uint256 _totalSupply = totalSupply;\\n\\n        if (_totalSupply == 0) {\\n\\n            liquidity = sqrt(\\n                amount0 * amount1\\n            ) - MINIMUM_LIQUIDITY;\\n\\n            _mint(\\n               ZERO_ADDRESS,\\n               MINIMUM_LIQUIDITY\\n            );\\n\\n        } else {\\n\\n            liquidity = min(\\n                amount0 * _totalSupply / _reserve0,\\n                amount1 * _totalSupply / _reserve1\\n            );\\n        }\\n\\n        require(\\n            liquidity \\u003e 0,\\n            \\\"INSUFFICIENT_LIQUIDITY_MINTED\\\"\\n        );\\n\\n        _mint(\\n            _to,\\n            liquidity\\n        );\\n\\n        _update(\\n            balance0,\\n            balance1,\\n            _reserve0,\\n            _reserve1\\n        );\\n\\n        kLast = uint256(reserve0) * reserve1;\\n\\n        emit Mint(\\n            msg.sender,\\n            amount0,\\n            amount1\\n        );\\n    }\\n\\n    function burn(\\n        address _to\\n    )\\n        external\\n        lock\\n        returns (\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n\\n        ) = getReserves();\\n\\n        address _token0 = token0;\\n        address _token1 = token1;\\n\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        _mintFee(\\n            _reserve0,\\n            _reserve1,\\n            kLast\\n        );\\n\\n        uint256 _totalSupply = totalSupply;\\n\\n        amount0 = liquidity * balance0 / _totalSupply;\\n        amount1 = liquidity * balance1 / _totalSupply;\\n\\n        require(\\n            amount0 \\u003e 0 \\u0026\\u0026\\n            amount1 \\u003e 0,\\n            \\\"INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n\\n        _burn(\\n            address(this),\\n            liquidity\\n        );\\n\\n        _safeTransfer(\\n            _token0,\\n            _to,\\n            amount0\\n        );\\n\\n        _safeTransfer(\\n            _token1,\\n            _to,\\n            amount1\\n        );\\n\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(\\n            balance0,\\n            balance1,\\n            _reserve0,\\n            _reserve1\\n        );\\n\\n        kLast = uint256(reserve0) * reserve1;\\n\\n        emit Burn(\\n            msg.sender,\\n            amount0,\\n            amount1,\\n            _to\\n        );\\n    }\\n\\n    function swap(\\n        uint256 _amount0Out,\\n        uint256 _amount1Out,\\n        address _to,\\n        bytes calldata _data\\n    )\\n        external\\n        lock\\n    {\\n        require(\\n            _amount0Out \\u003e 0 ||\\n            _amount1Out \\u003e 0,\\n            \\\"INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n\\n        ) = getReserves();\\n\\n        require(\\n            _amount0Out \\u003c _reserve0 \\u0026\\u0026\\n            _amount1Out \\u003c _reserve1,\\n            \\\"INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n\\n        {\\n            address _token0 = token0;\\n            address _token1 = token1;\\n\\n            if (_amount0Out \\u003e 0) _safeTransfer(_token0, _to, _amount0Out);\\n            if (_amount1Out \\u003e 0) _safeTransfer(_token1, _to, _amount1Out);\\n\\n            if (_data.length \\u003e 0) ISwapsCallee(_to).swapsCall(\\n                msg.sender,\\n                _amount0Out,\\n                _amount1Out,\\n                _data\\n            );\\n\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n\\n        uint256 _amount0In =\\n            balance0 \\u003e _reserve0 - _amount0Out ?\\n            balance0 - (_reserve0 - _amount0Out) : 0;\\n\\n        uint256 _amount1In =\\n            balance1 \\u003e _reserve1 - _amount1Out ?\\n            balance1 - (_reserve1 - _amount1Out) : 0;\\n\\n        require(\\n            _amount0In \\u003e 0 ||\\n            _amount1In \\u003e 0,\\n            \\\"INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n\\n        {\\n            uint256 balance0Adjusted = balance0 * 1000 - (_amount0In * 3);\\n            uint256 balance1Adjusted = balance1 * 1000 - (_amount1In * 3);\\n\\n            require(\\n                balance0Adjusted * balance1Adjusted \\u003e=\\n                uint256(_reserve0)\\n                    * _reserve1\\n                    * (1000 ** 2)\\n            );\\n        }\\n\\n        _update(\\n            balance0,\\n            balance1,\\n            _reserve0,\\n            _reserve1\\n        );\\n\\n        emit Swap(\\n            msg.sender,\\n            _amount0In,\\n            _amount1In,\\n            _amount0Out,\\n            _amount1Out,\\n            _to\\n        );\\n    }\\n\\n    function skim()\\n        external\\n        lock\\n    {\\n        address _token0 = token0;\\n        address _token1 = token1;\\n        address _feesTo = ISwapsFactory(factory).feeTo();\\n\\n        _safeTransfer(\\n            _token0,\\n            _feesTo,\\n            IERC20(_token0).balanceOf(address(this)) - reserve0\\n        );\\n\\n        _safeTransfer(\\n            _token1,\\n            _feesTo,\\n            IERC20(_token1).balanceOf(address(this)) - reserve1\\n        );\\n    }\\n\\n    function sync()\\n        external\\n        lock\\n    {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function encode(\\n        uint112 _y\\n    )\\n        pure\\n        internal\\n        returns (uint224 z)\\n    {\\n        unchecked {\\n            z = uint224(_y) * Q112;\\n        }\\n    }\\n\\n    function uqdiv(\\n        uint224 _x,\\n        uint112 _y\\n    )\\n        pure\\n        internal\\n        returns (uint224 z)\\n    {\\n        unchecked {\\n            z = _x / uint224(_y);\\n        }\\n    }\\n\\n    function min(\\n        uint256 _x,\\n        uint256 _y\\n    )\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        z = _x \\u003c _y ? _x : _y;\\n    }\\n\\n    function sqrt(\\n        uint256 _y\\n    )\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        unchecked {\\n            if (_y \\u003e 3) {\\n                z = _y;\\n                uint256 x = _y / 2 + 1;\\n                while (x \\u003c z) {\\n                    z = x;\\n                    x = (_y / x + x) / 2;\\n                }\\n            } else if (_y != 0) {\\n                z = 1;\\n            }\\n        }\\n    }\\n\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                SELECTOR,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"SwapsPair: TRANSFER_FAILED\\\"\\n        );\\n    }\\n}\\n\"},\"SwapsRouter.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISwapsFactory.sol\\\";\\nimport \\\"./ISwapsPair.sol\\\";\\nimport \\\"./SwapsHelper.sol\\\";\\n\\ncontract SwapsRouter is SwapsHelper {\\n\\n    address public immutable FACTORY;\\n    address public immutable WETH;\\n    address public immutable PAIR;\\n\\n    modifier ensure(\\n        uint256 _deadline\\n    ) {\\n        require(\\n            _deadline \\u003e= block.timestamp,\\n            \\\"SwapsRouter: DEADLINE_EXPIRED\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _factory,\\n        address _WETH\\n    ) {\\n        FACTORY = _factory;\\n        WETH = _WETH;\\n        PAIR = ISwapsFactory(_factory).cloneTarget();\\n    }\\n\\n    receive()\\n        external\\n        payable\\n    {\\n        require(\\n            msg.sender == WETH,\\n            \\\"SwapsRouter: INVALID_SENDER\\\"\\n        );\\n    }\\n\\n    function _addLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountADesired,\\n        uint256 _amountBDesired,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin\\n    )\\n        internal\\n        returns (uint256, uint256)\\n    {\\n        if (ISwapsFactory(FACTORY).getPair(_tokenA, _tokenB) == ZERO_ADDRESS) {\\n            ISwapsFactory(FACTORY).createPair(\\n                _tokenA,\\n                _tokenB\\n            );\\n        }\\n\\n        (\\n            uint256 reserveA,\\n            uint256 reserveB\\n\\n        ) = getReserves(\\n            FACTORY,\\n            _tokenA,\\n            _tokenB\\n        );\\n\\n        if (reserveA == 0 \\u0026\\u0026 reserveB == 0) {\\n            return (\\n                _amountADesired,\\n                _amountBDesired\\n            );\\n        }\\n\\n        uint256 amountBOptimal = quote(\\n            _amountADesired,\\n            reserveA,\\n            reserveB\\n        );\\n\\n        if (amountBOptimal \\u003c= _amountBDesired) {\\n\\n            require(\\n                amountBOptimal \\u003e= _amountBMin,\\n                \\\"SwapsRouter: INSUFFICIENT_B_AMOUNT\\\"\\n            );\\n\\n            return (\\n                _amountADesired,\\n                amountBOptimal\\n            );\\n        }\\n\\n        uint256 amountAOptimal = quote(\\n            _amountBDesired,\\n            reserveB,\\n            reserveA\\n        );\\n\\n        require(\\n            amountAOptimal \\u003c= _amountADesired,\\n            \\\"SwapsRouter: INVALID_DESIRED_AMOUNT\\\"\\n        );\\n\\n        require(\\n            amountAOptimal \\u003e= _amountAMin,\\n            \\\"SwapsRouter: INSUFFICIENT_A_AMOUNT\\\"\\n        );\\n\\n        return (\\n            amountAOptimal,\\n            _amountBDesired\\n        );\\n    }\\n\\n    function addLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountADesired,\\n        uint256 _amountBDesired,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountA, amountB) = _addLiquidity(\\n            _tokenA,\\n            _tokenB,\\n            _amountADesired,\\n            _amountBDesired,\\n            _amountAMin,\\n            _amountBMin\\n        );\\n\\n        address pair = _pairFor(\\n            FACTORY,\\n            _tokenA,\\n            _tokenB,\\n            PAIR\\n        );\\n\\n        _safeTransferFrom(\\n            _tokenA,\\n            msg.sender,\\n            pair,\\n            amountA\\n        );\\n\\n        _safeTransferFrom(\\n            _tokenB,\\n            msg.sender,\\n            pair,\\n            amountB\\n        );\\n\\n        liquidity = ISwapsPair(pair).mint(_to);\\n    }\\n\\n    function addLiquidityETH(\\n        address _token,\\n        uint256 _amountTokenDesired,\\n        uint256 _amountTokenMin,\\n        uint256 _amountETHMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        payable\\n        ensure(_deadline)\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountToken, amountETH) = _addLiquidity(\\n            _token,\\n            WETH,\\n            _amountTokenDesired,\\n            msg.value,\\n            _amountTokenMin,\\n            _amountETHMin\\n        );\\n\\n        address pair = _pairFor(\\n            FACTORY,\\n            _token,\\n            WETH,\\n            PAIR\\n        );\\n\\n        _safeTransferFrom(\\n            _token,\\n            msg.sender,\\n            pair,\\n            amountToken\\n        );\\n\\n        IWETH(WETH).deposit{\\n            value: amountETH\\n        }();\\n\\n        require(\\n            IWETH(WETH).transfer(\\n                pair,\\n                amountETH\\n            ),\\n            \\\"SwapsRouter: TRANSFER_FAIL\\\"\\n        );\\n\\n        liquidity = ISwapsPair(pair).mint(_to);\\n\\n        if (msg.value \\u003e amountETH) {\\n            unchecked {\\n                _safeTransferETH(\\n                    msg.sender,\\n                    msg.value - amountETH\\n                );\\n            }\\n        }\\n    }\\n\\n    function removeLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _liquidity,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        public\\n        ensure(_deadline)\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB\\n        )\\n    {\\n        address pair = _pairFor(\\n            FACTORY,\\n            _tokenA,\\n            _tokenB,\\n            PAIR\\n        );\\n\\n        _safeTransferFrom(\\n            pair,\\n            msg.sender,\\n            pair,\\n            _liquidity\\n        );\\n\\n        (\\n            uint256 amount0,\\n            uint256 amount1\\n\\n        ) = ISwapsPair(pair).burn(_to);\\n\\n        (address token0,) = sortTokens(\\n            _tokenA,\\n            _tokenB\\n        );\\n\\n        (amountA, amountB) = _tokenA == token0\\n            ? (amount0, amount1)\\n            : (amount1, amount0);\\n\\n        require(\\n            amountA \\u003e= _amountAMin,\\n            \\\"SwapsRouter: INSUFFICIENT_A_AMOUNT\\\"\\n        );\\n\\n        require(\\n            amountB \\u003e= _amountBMin,\\n            \\\"SwapsRouter: INSUFFICIENT_B_AMOUNT\\\"\\n        );\\n    }\\n\\n    function removeLiquidityETH(\\n        address _token,\\n        uint256 _liquidity,\\n        uint256 _amountTokenMin,\\n        uint256 _amountETHMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        public\\n        ensure(_deadline)\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH\\n        )\\n    {\\n        (amountToken, amountETH) = removeLiquidity(\\n            _token,\\n            WETH,\\n            _liquidity,\\n            _amountTokenMin,\\n            _amountETHMin,\\n            address(this),\\n            _deadline\\n        );\\n\\n        _safeTransfer(\\n            _token,\\n            _to,\\n            amountToken\\n        );\\n\\n        IWETH(WETH).withdraw(\\n            amountETH\\n        );\\n\\n        _safeTransferETH(\\n            _to,\\n            amountETH\\n        );\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _liquidity,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin,\\n        address _to,\\n        uint256 _deadline,\\n        bool _approveMax,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external\\n        returns (uint256, uint256)\\n    {\\n        address pair = _pairFor(\\n            FACTORY,\\n            _tokenA,\\n            _tokenB,\\n            PAIR\\n        );\\n\\n        uint256 value = _approveMax\\n            ? UINT256_MAX\\n            : _liquidity;\\n\\n        ISwapsPair(pair).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            _deadline,\\n            _v,\\n            _r,\\n            _s\\n        );\\n\\n        return removeLiquidity(\\n            _tokenA,\\n            _tokenB,\\n            _liquidity,\\n            _amountAMin,\\n            _amountBMin,\\n            _to,\\n            _deadline\\n        );\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        address _token,\\n        uint256 _liquidity,\\n        uint256 _amountTokenMin,\\n        uint256 _amountETHMin,\\n        address _to,\\n        uint256 _deadline,\\n        bool _approveMax,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external\\n        returns (uint256, uint256)\\n    {\\n        address pair = _pairFor(\\n            FACTORY,\\n            _token,\\n            WETH,\\n            PAIR\\n        );\\n\\n        uint256 value = _approveMax\\n            ? UINT256_MAX\\n            : _liquidity;\\n\\n        ISwapsPair(pair).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            _deadline,\\n            _v,\\n            _r,\\n            _s\\n        );\\n\\n        return removeLiquidityETH(\\n            _token,\\n            _liquidity,\\n            _amountTokenMin,\\n            _amountETHMin,\\n            _to,\\n            _deadline\\n        );\\n    }\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address _token,\\n        uint256 _liquidity,\\n        uint256 _amountTokenMin,\\n        uint256 _amountETHMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        public\\n        ensure(_deadline)\\n        returns (uint256 amountETH)\\n    {\\n        (, amountETH) = removeLiquidity(\\n            _token,\\n            WETH,\\n            _liquidity,\\n            _amountTokenMin,\\n            _amountETHMin,\\n            address(this),\\n            _deadline\\n        );\\n\\n        _safeTransfer(\\n            _token,\\n            _to,\\n            IERC20(_token).balanceOf(address(this))\\n        );\\n\\n        IWETH(WETH).withdraw(\\n            amountETH\\n        );\\n\\n        _safeTransferETH(\\n            _to,\\n            amountETH\\n        );\\n    }\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address _token,\\n        uint256 _liquidity,\\n        uint256 _amountTokenMin,\\n        uint256 _amountETHMin,\\n        address _to,\\n        uint256 _deadline,\\n        bool _approveMax,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external\\n        returns (uint256 amountETH)\\n    {\\n        address pair = _pairFor(\\n            FACTORY,\\n            _token,\\n            WETH,\\n            PAIR\\n        );\\n\\n        uint256 value = _approveMax\\n            ? UINT256_MAX\\n            : _liquidity;\\n\\n        ISwapsPair(pair).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            _deadline,\\n            _v,\\n            _r,\\n            _s\\n        );\\n\\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n            _token,\\n            _liquidity,\\n            _amountTokenMin,\\n            _amountETHMin,\\n            _to,\\n            _deadline\\n        );\\n    }\\n\\n    function _swap(\\n        uint256[] memory _amounts,\\n        address[] memory _path,\\n        address _to\\n    )\\n        internal\\n    {\\n        for (uint256 i; i \\u003c _path.length - 1; i++) {\\n\\n            (address input, address output) = (\\n                _path[i],\\n                _path[i + 1]\\n            );\\n\\n            (address token0,) = sortTokens(\\n                input,\\n                output\\n            );\\n\\n            uint256 amountOut = _amounts[i + 1];\\n\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint(0), amountOut)\\n                : (amountOut, uint(0));\\n\\n            address to = i \\u003c _path.length - 2\\n                ? _pairFor(FACTORY, output, _path[i + 2], PAIR)\\n                : _to;\\n\\n            ISwapsPair(\\n                _pairFor(\\n                    FACTORY,\\n                    input,\\n                    output,\\n                    PAIR\\n                )\\n            ).swap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint256 _amountIn,\\n        uint256 _amountOutMin,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        amounts = _getAmountsOut(\\n            FACTORY,\\n            _amountIn,\\n            _path\\n        );\\n\\n        require(\\n            amounts[amounts.length - 1] \\u003e= _amountOutMin,\\n            \\\"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        _safeTransferFrom(\\n            _path[0],\\n            msg.sender,\\n            _pairFor(\\n                FACTORY,\\n                _path[0],\\n                _path[1],\\n                PAIR\\n            ),\\n            amounts[0]\\n        );\\n\\n        _swap(\\n            amounts,\\n            _path,\\n            _to\\n        );\\n    }\\n\\n    function swapTokensForExactTokens(\\n        uint256 _amountOut,\\n        uint256 _amountInMax,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        amounts = _getAmountsIn(\\n            FACTORY,\\n            _amountOut,\\n            _path\\n        );\\n\\n        require(\\n            amounts[0] \\u003c= _amountInMax,\\n            \\\"SwapsRouter: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n\\n        _safeTransferFrom(\\n            _path[0],\\n            msg.sender,\\n            _pairFor(\\n                FACTORY,\\n                _path[0],\\n                _path[1],\\n                PAIR\\n            ),\\n            amounts[0]\\n        );\\n\\n        _swap(\\n            amounts,\\n            _path,\\n            _to\\n        );\\n    }\\n\\n    function swapExactETHForTokens(\\n        uint256 _amountOutMin,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        payable\\n        ensure(_deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(\\n            _path[0] == WETH,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        amounts = _getAmountsOut(\\n            FACTORY,\\n            msg.value,\\n            _path\\n        );\\n\\n        require(\\n            amounts[amounts.length - 1] \\u003e= _amountOutMin,\\n            \\\"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        IWETH(WETH).deposit{\\n            value: amounts[0]\\n        }();\\n\\n        require(\\n            IWETH(WETH).transfer(\\n                _pairFor(\\n                    FACTORY,\\n                    _path[0],\\n                    _path[1],\\n                    PAIR\\n                ),\\n                amounts[0]\\n            ),\\n            \\\"SwapsRouter: TRANSFER_FAIL\\\"\\n        );\\n\\n        _swap(\\n            amounts,\\n            _path,\\n            _to\\n        );\\n    }\\n\\n    function swapTokensForExactETH(\\n        uint256 _amountOut,\\n        uint256 _amountInMax,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(\\n            _path[_path.length - 1] == WETH,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        amounts = _getAmountsIn(\\n            FACTORY,\\n            _amountOut,\\n            _path\\n        );\\n\\n        require(\\n            amounts[0] \\u003c= _amountInMax,\\n            \\\"SwapsRouter: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n\\n        _safeTransferFrom(\\n            _path[0],\\n            msg.sender,\\n            _pairFor(\\n                FACTORY,\\n                _path[0],\\n                _path[1],\\n                PAIR\\n            ),\\n            amounts[0]\\n        );\\n\\n        _swap(\\n            amounts,\\n            _path,\\n            address(this)\\n        );\\n\\n        IWETH(WETH).withdraw(\\n            amounts[amounts.length - 1]\\n        );\\n\\n        _safeTransferETH(\\n            _to,\\n            amounts[amounts.length - 1]\\n        );\\n    }\\n\\n    function swapExactTokensForETH(\\n        uint256 _amountIn,\\n        uint256 _amountOutMin,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(\\n            _path[_path.length - 1] == WETH,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        amounts = _getAmountsOut(\\n            FACTORY,\\n            _amountIn,\\n            _path\\n        );\\n\\n        require(\\n            amounts[amounts.length - 1] \\u003e= _amountOutMin,\\n            \\\"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        _safeTransferFrom(\\n            _path[0],\\n            msg.sender,\\n            _pairFor(\\n                FACTORY,\\n                _path[0],\\n                _path[1],\\n                PAIR\\n            ),\\n            amounts[0]\\n        );\\n\\n        _swap(\\n            amounts,\\n            _path,\\n            address(this)\\n        );\\n\\n        IWETH(WETH).withdraw(\\n            amounts[amounts.length - 1]\\n        );\\n\\n        _safeTransferETH(\\n            _to,\\n            amounts[amounts.length - 1]\\n        );\\n    }\\n\\n    function swapETHForExactTokens(\\n        uint256 _amountOut,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        payable\\n        ensure(_deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(\\n            _path[0] == WETH,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        amounts = _getAmountsIn(\\n            FACTORY,\\n            _amountOut,\\n            _path\\n        );\\n\\n        require(\\n            amounts[0] \\u003c= msg.value,\\n            \\\"SwapsRouter: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n\\n        IWETH(WETH).deposit{\\n            value: amounts[0]\\n        }();\\n\\n        require(\\n            IWETH(WETH).transfer(\\n                _pairFor(\\n                    FACTORY,\\n                    _path[0],\\n                    _path[1],\\n                    PAIR\\n                ),\\n                amounts[0]\\n            ),\\n            \\\"SwapsRouter: TRANSFER_FAIL\\\"\\n        );\\n\\n        _swap(\\n            amounts,\\n            _path,\\n            _to\\n        );\\n\\n        if (msg.value \\u003e amounts[0]) {\\n            unchecked {\\n                _safeTransferETH(\\n                    msg.sender,\\n                    msg.value - amounts[0]\\n                );\\n            }\\n        }\\n    }\\n\\n    function _swapSupportingFeeOnTransferTokens(\\n        address[] memory _path,\\n        address _to\\n    )\\n        internal\\n    {\\n        for (uint256 i; i \\u003c _path.length - 1; i++) {\\n\\n            (address input, address output) = (\\n                _path[i],\\n                _path[i + 1]\\n            );\\n\\n            (address token0,) = sortTokens(\\n                input,\\n                output\\n            );\\n\\n            ISwapsPair pair = ISwapsPair(\\n                _pairFor(\\n                    FACTORY,\\n                    input,\\n                    output,\\n                    PAIR\\n                )\\n            );\\n\\n            uint256 amountInput;\\n            uint256 amountOutput;\\n\\n            {\\n\\n            (\\n                uint256 reserve0,\\n                uint256 reserve1,\\n\\n            ) = pair.getReserves();\\n\\n            (uint256 reserveInput, uint256 reserveOutput) = input == token0\\n                ? (reserve0, reserve1)\\n                : (reserve1, reserve0);\\n\\n            amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\\n            amountOutput = getAmountOut(\\n                amountInput,\\n                reserveInput,\\n                reserveOutput\\n            );\\n\\n            }\\n\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint(0), amountOutput)\\n                : (amountOutput, uint(0));\\n\\n            address to = i \\u003c _path.length - 2\\n                ? _pairFor(FACTORY, output, _path[i + 2], PAIR)\\n                : _to;\\n\\n            pair.swap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 _amountIn,\\n        uint256 _amountOutMin,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n    {\\n        _safeTransferFrom(\\n            _path[0],\\n            msg.sender,\\n            _pairFor(\\n                FACTORY,\\n                _path[0],\\n                _path[1],\\n                PAIR\\n            ),\\n            _amountIn\\n        );\\n\\n        uint256 balanceBefore = IERC20(_path[_path.length - 1]).balanceOf(_to);\\n\\n        _swapSupportingFeeOnTransferTokens(\\n            _path,\\n            _to\\n        );\\n\\n        require(\\n            IERC20(_path[_path.length - 1]).balanceOf(_to) - balanceBefore \\u003e= _amountOutMin,\\n            \\\"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n    }\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 _amountOutMin,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        payable\\n        ensure(_deadline)\\n    {\\n        require(\\n            _path[0] == WETH,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        uint256 amountIn = msg.value;\\n\\n        IWETH(WETH).deposit{\\n            value: amountIn\\n        }();\\n\\n        require(\\n            IWETH(WETH).transfer(\\n                _pairFor(\\n                    FACTORY,\\n                    _path[0],\\n                    _path[1],\\n                    PAIR\\n                ),\\n                amountIn\\n            ),\\n            \\\"SwapsRouter: TRANSFER_FAIL\\\"\\n        );\\n\\n        uint256 balanceBefore = IERC20(_path[_path.length - 1]).balanceOf(_to);\\n\\n        _swapSupportingFeeOnTransferTokens(\\n            _path,\\n            _to\\n        );\\n\\n        require(\\n            IERC20(_path[_path.length - 1]).balanceOf(_to) - balanceBefore \\u003e= _amountOutMin,\\n            \\\"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n    }\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 _amountIn,\\n        uint256 _amountOutMin,\\n        address[] calldata _path,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        external\\n        ensure(_deadline)\\n    {\\n        require(\\n            _path[_path.length - 1] == WETH,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        _safeTransferFrom(\\n            _path[0],\\n            msg.sender,\\n            _pairFor(\\n                FACTORY,\\n                _path[0],\\n                _path[1],\\n                PAIR\\n            ),\\n            _amountIn\\n        );\\n\\n        _swapSupportingFeeOnTransferTokens(\\n            _path,\\n            address(this)\\n        );\\n\\n        uint256 amountOut = IERC20(WETH).balanceOf(\\n            address(this)\\n        );\\n\\n        require(\\n            amountOut \\u003e= _amountOutMin,\\n            \\\"SwapsRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        IWETH(WETH).withdraw(\\n            amountOut\\n        );\\n\\n        _safeTransferETH(\\n            _to,\\n            amountOut\\n        );\\n    }\\n\\n    function pairFor(\\n        address _factory,\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        view\\n        returns (address predicted)\\n    {\\n        predicted = _pairFor(\\n            _factory,\\n            _tokenA,\\n            _tokenB,\\n            PAIR\\n        );\\n    }\\n\\n    function getAmountsOut(\\n        uint256 _amountIn,\\n        address[] memory _path\\n    )\\n        external\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        return _getAmountsOut(\\n            FACTORY,\\n            _amountIn,\\n            _path\\n        );\\n    }\\n\\n    function getAmountsIn(\\n        uint256 _amountOut,\\n        address[] memory _path\\n    )\\n        external\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        return _getAmountsIn(\\n            FACTORY,\\n            _amountOut,\\n            _path\\n        );\\n    }\\n\\n    function getReserves(\\n        address _factory,\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 reserveA,\\n            uint256 reserveB\\n        )\\n    {\\n        (address token0,) = sortTokens(\\n            _tokenA,\\n            _tokenB\\n        );\\n\\n        (\\n            uint256 reserve0,\\n            uint256 reserve1,\\n\\n        ) = ISwapsPair(\\n            _pairFor(\\n                _factory,\\n                _tokenA,\\n                _tokenB,\\n                PAIR\\n            )\\n        ).getReserves();\\n\\n        (reserveA, reserveB) = _tokenA == token0\\n            ? (reserve0, reserve1)\\n            : (reserve1, reserve0);\\n    }\\n\\n    function _getAmountsOut(\\n        address _factory,\\n        uint256 _amountIn,\\n        address[] memory _path\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        require(\\n            _path.length \\u003e= 2,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        amounts = new uint256[](\\n            _path.length\\n        );\\n\\n        amounts[0] = _amountIn;\\n\\n        for (uint256 i; i \\u003c _path.length - 1; i++) {\\n\\n            (\\n                uint256 reserveIn,\\n                uint256 reserveOut\\n\\n            ) = getReserves(\\n                _factory,\\n                _path[i],\\n                _path[i + 1]\\n            );\\n\\n            amounts[i + 1] = getAmountOut(\\n                amounts[i],\\n                reserveIn,\\n                reserveOut\\n            );\\n        }\\n    }\\n\\n    function _getAmountsIn(\\n        address _factory,\\n        uint256 _amountOut,\\n        address[] memory _path\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        require(\\n            _path.length \\u003e= 2,\\n            \\\"SwapsRouter: INVALID_PATH\\\"\\n        );\\n\\n        amounts = new uint256[](\\n            _path.length\\n        );\\n\\n        amounts[amounts.length - 1] = _amountOut;\\n\\n        for (uint256 i = _path.length - 1; i \\u003e 0; i--) {\\n\\n            (\\n                uint256 reserveIn,\\n                uint256 reserveOut\\n\\n            ) = getReserves(\\n                _factory,\\n                _path[i - 1],\\n                _path[i]\\n            );\\n\\n            amounts[i - 1] = getAmountIn(\\n                amounts[i],\\n                reserveIn,\\n                reserveOut\\n            );\\n        }\\n    }\\n}\\n\\ncontract RouterCodeCheck {\\n\\n    function routerCodeHash()\\n        external\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            type(SwapsRouter).creationCode\\n        );\\n    }\\n}\\n\"}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAIR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"predicted\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "SwapsRouter",
    "CompilerVersion": "v0.8.14+commit.80d49f37",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000ee3e9e46e34a27dc755a63e2849c9913ee1a06e2000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "GNU GPLv3",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://7dea02283b88a465792995de6238b8f85659e5f689fb350f51f3ac2a20d9229d"
}