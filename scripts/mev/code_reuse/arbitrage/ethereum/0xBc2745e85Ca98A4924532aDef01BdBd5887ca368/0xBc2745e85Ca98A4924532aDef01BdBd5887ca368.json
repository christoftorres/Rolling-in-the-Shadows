{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/routers/MainnetMultiHopRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../interfaces/router/IUniswapV2Router.sol\\\";\\nimport \\\"../interfaces/router/IUniswapV3Router.sol\\\";\\nimport \\\"../interfaces/router/IBalancerRouter.sol\\\";\\nimport \\\"../interfaces/router/ICurveTC1Router.sol\\\";\\nimport \\\"./Permitable.sol\\\";\\nimport \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\n\\n/// @title Router contract that swaps tokens with different DEXs using multihops.\\ncontract MainnetMultiHopRouter is Permitable {\\n    IUniswapV3Router private immutable UniV3Router;\\n    ICurveTC1Router private immutable curveTC1Router;\\n    IBalancerRouter private immutable balancer;\\n    WETH private immutable WETHContract;\\n    address private constant ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    uint32 public immutable _fee;\\n\\n    struct BalancerMultiInputs {\\n        uint256 deadline;\\n        address payable to;\\n        address srcToken;\\n    }\\n\\n    constructor(\\n        IUniswapV3Router _uniswapV3Router,\\n        IBalancerRouter _balancer,\\n        ICurveTC1Router _curveTC1Router,\\n        address payable _WETHAddress,\\n        uint32 fee\\n    ) {\\n        UniV3Router = _uniswapV3Router;\\n        balancer = _balancer;\\n        curveTC1Router = _curveTC1Router;\\n        WETHContract = WETH(_WETHAddress);\\n        _fee = fee;\\n    }\\n\\n    /////////////////////////////////// MULTIHOP SWAPS ////////////////////////////////////\\n    /// @notice Swaps tokens using multiple pools on UniV2 forks\\n    /// @param amountIn The amount of source token to be swapped\\n    /// @param amountOutMin The minimum amount of destination token to be received\\n    /// @param path The addresses of tokens to be swapped - source token and destination token\\n    /// @param deadline The deadline for the swap\\n    /// @param to The receiver address\\n    function uniswapV2MultiSwap(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        uint256 deadline,\\n        address to,\\n        IUniswapV2Router router\\n    ) public payable {\\n        if (msg.value != 0) {\\n            path[0] = address(WETHContract);\\n            unchecked {\\n                router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                    value: (msg.value * _fee) / 10000\\n                }(amountOutMin, path, to, deadline);\\n            }\\n        } else {\\n            bool ToETH = path[path.length - 1] == address(0);\\n            SafeTransferLib.safeTransferFrom(\\n                ERC20(path[0]),\\n                msg.sender,\\n                address(this),\\n                amountIn\\n            );\\n            unchecked {\\n                amountIn = (amountIn * _fee) / 10000;\\n            }\\n            SafeTransferLib.safeApprove(\\n                ERC20(path[0]),\\n                address(router),\\n                amountIn\\n            );\\n            if (ToETH) {\\n                path[path.length - 1] = address(WETHContract);\\n                router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                    amountIn,\\n                    amountOutMin,\\n                    path,\\n                    to,\\n                    deadline\\n                );\\n            } else {\\n                router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                    amountIn,\\n                    amountOutMin,\\n                    path,\\n                    to,\\n                    deadline\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Swaps tokens using multiple pools of UniV3\\n    /// @param amountIn The amount of source token to be swapped\\n    /// @param amountOutMin The minimum amount of destination token to be received\\n    /// @param deadline The deadline for the swap\\n    /// @param to The receiver address\\n    /// @param srcToken The source token address\\n    /// @param bytePath The encoded path with token address, fee, token adress, fee ... n times\\n    /// @return amountOut The amount of destination token received\\n    function uniswapV3MultiSwap(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        uint256 deadline,\\n        address payable to,\\n        address srcToken,\\n        bytes calldata bytePath\\n    ) public payable returns (uint256 amountOut) {\\n        SafeTransferLib.safeTransferFrom(\\n            ERC20(srcToken),\\n            msg.sender,\\n            address(this),\\n            amountIn\\n        );\\n        unchecked {\\n            amountIn = (amountIn * _fee) / 10000;\\n        }\\n        SafeTransferLib.safeApprove(\\n            ERC20(srcToken),\\n            address(UniV3Router),\\n            amountIn\\n        );\\n        amountOut = UniV3Router.exactInput(\\n            IUniswapV3Router.ExactInputParams({\\n                path: bytePath,\\n                recipient: to,\\n                deadline: deadline,\\n                amountIn: amountIn,\\n                amountOutMin: amountOutMin\\n            })\\n        );\\n    }\\n\\n    /// @notice Swaps tokens using multiple pools on Balancer\\n    /// @param swaps The BatchSwapStep struct for Balancer batchSwaps\\n    /// @param assets The sorted token addresses for the swap\\n    /// @param limits The limit values for each token in sort order\\n    /// @param inputs The deadline for the swap, the receiver address and the source token address\\n    /// @return amountOut The amount of destination token received \\n    function balancerMultiSwap(\\n        IBalancerRouter.BatchSwapStep[] memory swaps,\\n        address[] calldata assets,\\n        int256[] calldata limits,\\n        BalancerMultiInputs calldata inputs\\n    ) public payable returns (int256[] memory amountOut) {\\n        SafeTransferLib.safeTransferFrom(\\n            ERC20(inputs.srcToken),\\n            msg.sender,\\n            address(this),\\n            swaps[0].amount\\n        );\\n        unchecked {\\n            swaps[0].amount = (swaps[0].amount * _fee) / 10000;\\n        }\\n        SafeTransferLib.safeApprove(\\n            ERC20(inputs.srcToken),\\n            address(balancer),\\n            swaps[0].amount\\n        );\\n        amountOut = balancer.batchSwap(\\n            IBalancerRouter.SwapKind.GIVEN_IN,\\n            swaps,\\n            assets,\\n            IBalancerRouter.FundManagement({\\n                sender: address(this),\\n                fromInternalBalance: false,\\n                recipient: inputs.to,\\n                toInternalBalance: false\\n            }),\\n            limits,\\n            inputs.deadline\\n        );\\n    }\\n\\n    /// @notice Batch swap function using multiple pools on Cruve\\n    /// @param amountIn The amount of source token to be swapped\\n    /// @param amountOutMin The minimum amount of destination token to be received\\n    /// @param path The addresses of tokens to be swapped and unused slots with zero address\\n    /// @param to The receiver address\\n    /// @param swapParams Multidimensional array of [i, j, swapType] where i and j are indexes of tokens in each swap\\n    /// @param pools The pool addresses for the tokens to be swapped\\n    /// @return amountOut The amount of destination token received\\n    function CurveMultiSwap(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[9] memory path,\\n        address to,\\n        uint256[3][4] calldata swapParams,\\n        address[4] calldata pools\\n    ) public payable returns (uint256 amountOut) {\\n        if (msg.value != 0) {\\n            WETHContract.deposit{value: msg.value}();\\n            path[0] = ETH_ADDRESS;\\n            unchecked {\\n                amountIn = (msg.value * _fee) / 10000;\\n            }\\n        } else {\\n            SafeTransferLib.safeTransferFrom(\\n                ERC20(path[0]),\\n                msg.sender,\\n                address(this),\\n                amountIn\\n            );\\n            unchecked {\\n                amountIn = (amountIn * _fee) / 10000;\\n            }\\n        }\\n        SafeTransferLib.safeApprove(\\n            ERC20(path[0]),\\n            address(curveTC1Router),\\n            amountIn\\n        );\\n        if (msg.value != 0) {\\n            amountOut = curveTC1Router.exchange_multiple{value: amountIn}(\\n                path,\\n                swapParams,\\n                amountIn,\\n                amountOutMin,\\n                pools,\\n                to\\n            );\\n        } else {\\n            amountOut = curveTC1Router.exchange_multiple(\\n                path,\\n                swapParams,\\n                amountIn,\\n                amountOutMin,\\n                pools,\\n                to\\n            );\\n        }\\n    }\\n\\n    //////////////////////////////////// PERMIT SWAPS ////////////////////////////////////\\n    function swapUniV2Permit(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        uint256 deadline,\\n        address to,\\n        IUniswapV2Router router,\\n        bytes calldata permitData\\n    ) external payable {\\n        _permit(path[0], permitData);\\n        uniswapV2MultiSwap(amountIn, amountOutMin, path, deadline, to, router);\\n    }\\n\\n    function swapUniV3Permit(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        uint256 deadline,\\n        address payable to,\\n        address srcToken,\\n        bytes calldata bytePath,\\n        bytes calldata permitData\\n    ) external payable returns (uint256 amountOut) {\\n        _permit(srcToken, permitData);\\n        return\\n            uniswapV3MultiSwap(\\n                amountIn,\\n                amountOutMin,\\n                deadline,\\n                to,\\n                srcToken,\\n                bytePath\\n            );\\n    }\\n\\n    function swapBalancerPermit(\\n        IBalancerRouter.BatchSwapStep[] memory swaps,\\n        address[] calldata assets,\\n        int256[] calldata limits,\\n        BalancerMultiInputs calldata inputs,\\n        bytes calldata permitData\\n    ) external payable returns (int256[] memory amountOut) {\\n        _permit(inputs.srcToken, permitData);\\n        return balancerMultiSwap(swaps, assets, limits, inputs);\\n    }\\n\\n    function swapCurvePermit(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[9] memory path,\\n        address to,\\n        uint256[3][4] calldata swapParams,\\n        address[4] calldata pools,\\n        bytes calldata permitData\\n    ) external payable returns (uint256 amountOut) {\\n        _permit(path[0], permitData);\\n        return\\n            CurveMultiSwap(amountIn, amountOutMin, path, to, swapParams, pools);\\n    }\\n\\n    ////////////////////////////////////////// ADMIN FUNCTIONS //////////////////////////////////////////\\n    /// @notice Flushes the balance of the contract for a token to an address\\n    /// @param _token The address of the token to be flushed\\n    /// @param _to The address to which the balance will be flushed\\n    function flush(ERC20 _token, address _to) external {\\n        uint256 amount = _token.balanceOf(address(this));\\n        assembly {\\n            if iszero(\\n                eq(caller(), 0x123CB0304c7f65B0D48276b9857F4DF4733d1dd8) // Required address to flush\\n            ) {\\n                revert(0, 0)\\n            }\\n            // We'll write our calldata to this slot.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with function selector\\n            mstore(0x00, 0xa9059cbb)\\n            mstore(0x20, _to) // append the 'to' argument\\n            mstore(0x40, amount) // append the 'amount' argument\\n\\n            if iszero(\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    // We use 0x64 because that's the total length of our call data (0x04 + 0x20 * 3)\\n                    // Counterintuitively, this call() must be positioned after the or() in the\\n                    // surrounding and() because and() evaluates its arguments from right to left.\\n                    call(gas(), _token, 0, 0x1c, 0x60, 0x00, 0x20)\\n                    // Adjusted above by changing 0x64 to 0x60\\n                )\\n            ) {\\n                // Store the function selector of TransferFromFailed()\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size)\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero\\n            mstore(0x40, memPointer) // Restore the mempointer\\n        }\\n    }\\n\\n    /// @notice Flushes the ETH balance of the contract to an address\\n    /// @param to The address to which the balance will be flushed\\n    function flushETH(address to) external {\\n        uint256 amount = address(this).balance;\\n        assembly {\\n            if iszero(\\n                eq(caller(), 0x123CB0304c7f65B0D48276b9857F4DF4733d1dd8) // Required address to flush\\n            ) {\\n                revert(0, 0)\\n            }\\n            if iszero(\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    // We use 0x64 because that's the total length of our call data (0x04 + 0x20 * 3)\\n                    // Counterintuitively, this call() must be positioned after the or() in the\\n                    // surrounding and() because and() evaluates its arguments from right to left.\\n                    call(gas(), to, amount, 0, 0, 0, 0)\\n                    // Adjusted above by changing 0x64 to 0x60\\n                )\\n            ) {\\n                // Store the function selector of TransferFromFailed()\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @notice receive fallback function for empty call data\\n    receive() external payable {}\\n\\n    /// @notice fallback function when no other function matches\\n    fallback() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/router/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IUniswapV2Router {\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/router/IUniswapV3Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// import \\\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface IUniswapV3Router {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    \\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n    }\\n\\n    function exactInput(ExactInputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/router/IBalancerRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IBalancerRouter {\\n    enum SwapKind {\\n        GIVEN_IN,\\n        GIVEN_OUT\\n    }\\n\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    struct Asset {\\n        string symbol;\\n        uint8 decimals;\\n        uint256 limit;\\n    }\\n\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    function swap(\\n        SingleSwap memory swap,\\n        FundManagement memory fund,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] calldata swaps,\\n        address[] calldata assets,\\n        FundManagement memory fund,\\n        int256[] calldata limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] calldata assetDeltas);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/router/ICurveTC1Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface ICurveTC1Router {\\n    function exchange_with_best_rate(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _expected,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function exchange(\\n        address pool,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _expected,\\n        address _receiver\\n    ) payable external returns (uint256);\\n\\n    function exchange_multiple(\\n        address[9] calldata _route,\\n        uint256[3][4] calldata _swap_params,\\n        uint256 _amount,\\n        uint256 _expected,\\n        address[4] calldata _pools,\\n        address _receiver\\n    ) external payable returns (uint256);\\n\\n    function is_killed() external view returns (bool);\\n\\n    function registry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/routers/Permitable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\n\\ninterface IDaiLikePermit {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ncontract Permitable {\\n    function _permit(address token, bytes calldata permit) internal {\\n        if (permit.length > 0) {\\n            bool success;\\n            bytes memory result;\\n            if (permit.length == 32 * 7) {\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (success, result) = token.call(\\n                    abi.encodePacked(IERC20Permit.permit.selector, permit)\\n                );\\n            } else if (permit.length == 32 * 8) {\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (success, result) = token.call(\\n                    abi.encodePacked(IDaiLikePermit.permit.selector, permit)\\n                );\\n            } else {\\n                revert(\\\"Wrong permit length\\\");\\n            }\\n            if (!success) {\\n                revert(\\\"Permit failed: \\\");\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUniswapV3Router\",\"name\":\"_uniswapV3Router\",\"type\":\"address\"},{\"internalType\":\"contract IBalancerRouter\",\"name\":\"_balancer\",\"type\":\"address\"},{\"internalType\":\"contract ICurveTC1Router\",\"name\":\"_curveTC1Router\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_WETHAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"fee\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[9]\",\"name\":\"path\",\"type\":\"address[9]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"swapParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"address[4]\",\"name\":\"pools\",\"type\":\"address[4]\"}],\"name\":\"CurveMultiSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assetInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IBalancerRouter.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"limits\",\"type\":\"int256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"}],\"internalType\":\"struct MainnetMultiHopRouter.BalancerMultiInputs\",\"name\":\"inputs\",\"type\":\"tuple\"}],\"name\":\"balancerMultiSwap\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"amountOut\",\"type\":\"int256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"flush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"flushETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assetInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IBalancerRouter.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"limits\",\"type\":\"int256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"}],\"internalType\":\"struct MainnetMultiHopRouter.BalancerMultiInputs\",\"name\":\"inputs\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"swapBalancerPermit\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"amountOut\",\"type\":\"int256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[9]\",\"name\":\"path\",\"type\":\"address[9]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"swapParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"address[4]\",\"name\":\"pools\",\"type\":\"address[4]\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"swapCurvePermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"swapUniV2Permit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"bytePath\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"swapUniV3Permit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"uniswapV2MultiSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"bytePath\",\"type\":\"bytes\"}],\"name\":\"uniswapV3MultiSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "MainnetMultiHopRouter",
    "CompilerVersion": "v0.8.9+commit.e5eed63a",
    "OptimizationUsed": "0",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c800000000000000000000000081c46feca27b31f3adc2b91ee4be9717d1cd3dd7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000270e",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}