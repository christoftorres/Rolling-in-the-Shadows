{
    "SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.9;\r\n// import 'hardhat/console.sol';\r\n\r\ninterface IUniswapV3Pair {\r\n    function token0(\r\n    ) external view returns (address);\r\n\r\n    function token1(\r\n    ) external view returns (address);\r\n\r\n    function swap(\r\n        address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes calldata data\r\n    ) external returns (int256 amount0, int256 amount1);\r\n\r\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\r\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\r\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\r\n    /// @param recipient The address which will receive the token0 and token1 amounts\r\n    /// @param amount0 The amount of token0 to send\r\n    /// @param amount1 The amount of token1 to send\r\n    /// @param data Any data to be passed through to the callback\r\n    function flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\r\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\r\n    /// the input observationCardinalityNext.\r\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\r\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function name() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV3SwapCallback {\r\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\r\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ncontract uniswap_flashswapV3 {\r\n\r\n    // From openzeppelin ownable.sol\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    // Main contract\r\n\r\n    // Fallback must be payable\r\n    fallback() external payable {}\r\n    receive() external payable  {}\r\n\r\n    // @notice This function is used when either the tokenBorrow or tokenBase is WETH or ETH\r\n    // @dev Since ~all tokens trade against WETH (if they trade at all), we can use a single UniswapV2 pair to\r\n    //     flash-borrow and repay with the requested tokens.\r\n    // @dev This initiates the flash borrow. See `simpleFlashSwapExecute` for the code that executes after the borrow.\r\n    // @param pool1 is the dex that execute flash swap (cheaper token), pool2 is the dex that sells the token to weth\r\n    // @param borrowAmount is the amount of token borrowed from flashswap, repayAmount is the amount repay to flashswap, swapoutAmount is the amount swap from the other DEX\r\n    // @param pool1BorrowToken\r\n    // @param pool1type\r\n    function simpleFlashSwap(\r\n        address tokenBorrow,\r\n        address tokenBase,\r\n        address pool1,\r\n        address pool2,\r\n        uint borrowAmount,\r\n        uint repayAmount,\r\n        uint swapOutAmount,\r\n        bytes calldata data\r\n    ) public onlyOwner {\r\n        // decode data\r\n        (\r\n            uint pool1Type,\r\n            uint pool2Type,\r\n            uint pool1sqrtPriceLimitX96,\r\n            uint pool2sqrtPriceLimitX96\r\n        ) = abi.decode(data, (uint, uint, uint, uint));\r\n        // console.log('calling simpleFlashSwap');\r\n        // console.log('pooltype');\r\n        // console.log(pool1Type);\r\n        // console.log(pool2Type);\r\n\r\n        bytes memory _data = abi.encode(\r\n            tokenBorrow,\r\n            tokenBase,\r\n            pool1,\r\n            pool2,\r\n            pool2Type,\r\n            pool2sqrtPriceLimitX96,\r\n            borrowAmount,\r\n            repayAmount,\r\n            swapOutAmount\r\n        );\r\n\r\n        \r\n        address _tokenBorrow = tokenBorrow;\r\n        address _pool1 = pool1;\r\n        uint _borrowAmount = borrowAmount;\r\n\r\n        if(pool1Type==1){\r\n            \r\n            address token0 = IUniswapV3Pair(pool1).token0();\r\n\r\n            // console.log('pool1 callingV3 swap');\r\n            // console.log(pool1sqrtPriceLimitX96);\r\n            IUniswapV3Pair(_pool1).swap(\r\n                address(this),\r\n                _tokenBorrow == token0?false:true,\r\n                -int(_borrowAmount), \r\n                uint160(pool1sqrtPriceLimitX96), \r\n                _data\r\n                );\r\n        }else{\r\n            // console.log('pool1 callingV2 swap');\r\n            address token0 = IUniswapV2Pair(_pool1).token0();\r\n            address token1 = IUniswapV2Pair(_pool1).token1();\r\n            uint amount0Out = _tokenBorrow == token0 ? _borrowAmount : 0;\r\n            uint amount1Out = _tokenBorrow == token1 ? _borrowAmount : 0;\r\n            IUniswapV2Pair(_pool1).swap(amount0Out, amount1Out, address(this), _data);\r\n        }\r\n        \r\n        \r\n    }\r\n\r\n    // @notice Function is called by the Uniswap V2 pair's `swap` function\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata data) external {\r\n        // access control\r\n        require(_sender == address(this), \"only this contract may initiate\");\r\n\r\n        // decode data\r\n        (,,address pool1,address pool2,,,,,) = abi.decode(data, (address, address, address, address, uint, uint, uint, uint, uint));\r\n\r\n\r\n        simpleFlashSwapExecute(pool1,pool2,msg.sender,data);\r\n       \r\n        // NOOP to silence compiler \"unused parameter\" warning\r\n        if (false) {\r\n            _amount0;\r\n            _amount1;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // @notice Function is called by the Uniswap V3 pair's `swap` function\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external {\r\n        // access control\r\n        // require(_sender == address(this), \"only this contract may initiate\");\r\n\r\n        // console.log('uniswapV3 call');\r\n        // console.log(msg.sender);\r\n        // decode data\r\n        (,,address pool1,address pool2,,,,,) = abi.decode(data, (address, address, address, address, uint, uint, uint, uint, uint));\r\n\r\n        simpleFlashSwapExecute(pool1,pool2,msg.sender,data);   \r\n       \r\n        // NOOP to silence compiler \"unused parameter\" warning\r\n        if (false) {\r\n            amount0Delta;\r\n            amount1Delta;\r\n        }\r\n        return;\r\n    }\r\n\r\n    function simpleFlashSwapExecute(\r\n        address pool1,\r\n        address pool2,\r\n        address pairAddress,\r\n        bytes calldata data\r\n    ) private {\r\n        require(pairAddress==pool1 || pairAddress==pool2,\"Only LP pool can call this function\");\r\n        \r\n        // console.log('calling simpleFlashSwapExecute');\r\n        // console.log(msg.sender);\r\n\r\n        (\r\n            address tokenBorrow,\r\n            address tokenBase,\r\n            ,\r\n            ,\r\n            uint pool2Type,\r\n            uint pool2sqrtPriceLimitX96,\r\n            uint borrowAmount,\r\n            uint repayAmount,\r\n            uint swapOutAmount\r\n        ) = abi.decode(data, (address, address, address, address, uint, uint, uint, uint, uint));\r\n\r\n        \r\n        address _pool2 = pool2;\r\n        address _tokenBorrow = tokenBorrow;\r\n\r\n        if (msg.sender==pool1){\r\n            uint baseBalanceBefore = IERC20(tokenBase).balanceOf(address(this));\r\n        \r\n            \r\n            address _pool1 = pool1;\r\n            \r\n            bytes memory _data = data;\r\n            // swap on pool2\r\n            // If pool2Type=1, pool2 is uniswapv3\r\n\r\n            if (pool2Type==1){\r\n                // console.log('Swap pool2 V3');\r\n                IUniswapV3Pair(pool2).swap(\r\n                    address(this),\r\n                    _tokenBorrow == (IUniswapV3Pair(_pool2).token0())?true:false,\r\n                    int(borrowAmount), \r\n                    uint160(pool2sqrtPriceLimitX96), \r\n                    _data\r\n                    );\r\n                // console.log('Swap pool2 V3 Done');\r\n            }else{\r\n                // swap on pool2\r\n                // console.log('Swap pool2 V2');\r\n                swapPool2_V2(_tokenBorrow, tokenBase, _pool2, borrowAmount, repayAmount, swapOutAmount);\r\n                // console.log('Swap pool2 V2 Done');\r\n            }\r\n            uint baseBalanceAfter = IERC20(tokenBase).balanceOf(address(this));\r\n            require(baseBalanceAfter>=baseBalanceBefore+swapOutAmount, \"Pool 2 not returning enough token\");\r\n            // payback loan\r\n            // console.log('Paying back loan');\r\n            // console.log(repayAmount);\r\n            IERC20(tokenBase).transfer(_pool1, repayAmount);\r\n        }\r\n\r\n        if (msg.sender==_pool2) {\r\n            require(IERC20(_tokenBorrow).balanceOf(address(this)) >= borrowAmount, 'Pool 1 not returning enough token');\r\n            // console.log('Transfer token to pool2');\r\n            // console.log('Balance of tokenBorrow in wallet');\r\n            IERC20(_tokenBorrow).transfer(_pool2, borrowAmount); // Transfer the borrow token to pool2\r\n            // console.log('Transfer Done');\r\n        }\r\n\r\n    }\r\n\r\n    // @notice This is where the user's custom logic goes\r\n    // @dev When this function executes, this contract will hold _amount of _tokenBorrow\r\n    // @dev It is important that, by the end of the execution of this function, this contract holds the necessary\r\n    //     amount of the original _tokenBase needed to pay back the flash-loan.\r\n    // @dev Paying back the flash-loan happens automatically by the calling function -- do not pay back the loan in this function\r\n    // @dev If you entered `0x0` for _tokenBase when you called `flashSwap`, then make sure this contract hols _amount ETH before this\r\n    //     finishes executing\r\n    // @dev User will override this function on the inheriting contract\r\n    function swapPool2_V2(\r\n        address tokenBorrow, \r\n        address tokenBase,\r\n        address pool2,\r\n        uint borrowAmount, \r\n        uint repayAmount,\r\n        uint swapoutAmount\r\n        ) internal {\r\n        \r\n        IERC20(tokenBorrow).transfer(pool2, borrowAmount); // Transfer the borrow token first then swap\r\n        \r\n        require(swapoutAmount>repayAmount,\"Not enough token to repay due to bad rate from pool2\");\r\n\r\n        address token0 = IUniswapV2Pair(pool2).token0();\r\n        address token1 = IUniswapV2Pair(pool2).token1();\r\n        uint amount0Out = tokenBase == token0 ? swapoutAmount : 0;\r\n        uint amount1Out = tokenBase == token1 ? swapoutAmount : 0;\r\n        \r\n        IUniswapV2Pair(pool2).swap(amount0Out, amount1Out, address(this),\"\");\r\n\r\n    }\r\n\r\n\r\n    function withdraw(address _tokenContract) external onlyOwner {\r\n        IERC20 tokenContract = IERC20(_tokenContract);\r\n        uint tokenBalance = IERC20(_tokenContract).balanceOf(address(this));\r\n        \r\n        // transfer the token from address of this contract\r\n        // to address of the user (executing the withdrawToken() function)\r\n        tokenContract.transfer(msg.sender, tokenBalance);\r\n    }\r\n\r\n}",
    "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenBase\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"simpleFlashSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "uniswap_flashswapV3",
    "CompilerVersion": "v0.8.9+commit.e5eed63a",
    "OptimizationUsed": "0",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "Unlicense",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://e1fb62124c0e62c07dca2815f4c0d34ac2cf4e33486e449e3759c4014644f4bd"
}