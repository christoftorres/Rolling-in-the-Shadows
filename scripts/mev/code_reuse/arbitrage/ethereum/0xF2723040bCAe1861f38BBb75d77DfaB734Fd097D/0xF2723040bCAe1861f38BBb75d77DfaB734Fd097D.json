{
    "SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\"},\"SimpleArbitrage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract SimpleArbitrage {\\r\\n    address public owner;\\r\\n\\r\\n    address public wethAddress;\\r\\n    address public daiAddress;\\r\\n    address public uniswapRouterAddress;\\r\\n    address public sushiswapRouterAddress;\\r\\n\\r\\n    uint256 public arbitrageAmount;\\r\\n    uint256 public contractbalance;\\r\\n\\r\\n    enum Exchange {\\r\\n        UNI,\\r\\n        SUSHI,\\r\\n        NONE\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _uniswapRouterAddress,\\r\\n        address _sushiswapRouterAddress,\\r\\n        address _weth,\\r\\n        address _dai\\r\\n    ) {\\r\\n        uniswapRouterAddress = _uniswapRouterAddress;\\r\\n        sushiswapRouterAddress = _sushiswapRouterAddress;\\r\\n        owner = msg.sender;\\r\\n        wethAddress = _weth;\\r\\n        daiAddress = _dai;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"only owner can call this\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function changeOwner(address newOwner) public onlyOwner {\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    function deposit() public payable{\\r\\n        contractbalance += msg.value;\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount, address receiveaddress)  public onlyOwner {\\r\\n        require(amount \\u003c= contractbalance, \\\"Not enough amount deposited\\\");\\r\\n        payable(receiveaddress).transfer(amount);\\r\\n        contractbalance -= amount;\\r\\n    }\\r\\n\\r\\n    function setabitrigeamount(uint256 abt_amount) public onlyOwner{\\r\\n        arbitrageAmount = abt_amount;\\r\\n    }\\r\\n\\r\\n    function makeArbitrage(address temptoken) public {\\r\\n        uint256 amountIn = arbitrageAmount;\\r\\n        Exchange result = _comparePrice(amountIn, temptoken);\\r\\n        if (result == Exchange.UNI) {\\r\\n            // sell ETH in uniswap for DAI with high price and buy ETH from sushiswap with lower price\\r\\n            uint256 amountOut = _swap(\\r\\n                amountIn,\\r\\n                uniswapRouterAddress,\\r\\n                wethAddress,\\r\\n                temptoken\\r\\n            );\\r\\n            uint256 amountFinal = _swap(\\r\\n                amountOut,\\r\\n                sushiswapRouterAddress,\\r\\n                temptoken,\\r\\n                wethAddress\\r\\n            );\\r\\n            contractbalance -= arbitrageAmount;\\r\\n            contractbalance += amountFinal;\\r\\n        } else if (result == Exchange.SUSHI) {\\r\\n            // sell ETH in sushiswap for DAI with high price and buy ETH from uniswap with lower price\\r\\n            uint256 amountOut = _swap(\\r\\n                amountIn,\\r\\n                sushiswapRouterAddress,\\r\\n                wethAddress,\\r\\n                temptoken\\r\\n            );\\r\\n            uint256 amountFinal = _swap(\\r\\n                amountOut,\\r\\n                uniswapRouterAddress,\\r\\n                temptoken,\\r\\n                wethAddress\\r\\n            );\\r\\n            contractbalance -= arbitrageAmount;\\r\\n            contractbalance += amountFinal;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //test\\r\\n\\r\\n    function makeabtsu(address temptoken) public onlyOwner returns(uint256) {\\r\\n\\r\\n            uint256 amountIn = arbitrageAmount;\\r\\n            uint256 amountOut = _swap(\\r\\n                amountIn,\\r\\n                sushiswapRouterAddress,\\r\\n                wethAddress,\\r\\n                temptoken\\r\\n            );\\r\\n\\r\\n            uint256 amountFinal = _swap(\\r\\n                amountOut,\\r\\n                uniswapRouterAddress,\\r\\n                temptoken,\\r\\n                wethAddress\\r\\n            );\\r\\n            return amountFinal;\\r\\n            \\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    function makeabtus(address temptoken) public onlyOwner returns(uint256) {\\r\\n\\r\\n            uint256 amountIn = arbitrageAmount;\\r\\n            uint256 amountOut = _swap(\\r\\n                amountIn,\\r\\n                uniswapRouterAddress,\\r\\n                wethAddress,\\r\\n                temptoken\\r\\n            );\\r\\n\\r\\n            uint256 amountFinal = _swap(\\r\\n                amountOut,\\r\\n                sushiswapRouterAddress,\\r\\n                temptoken,\\r\\n                wethAddress\\r\\n            );\\r\\n            return amountFinal;\\r\\n            \\r\\n    }\\r\\n\\r\\n\\r\\n \\r\\n    \\r\\n    function _swap(\\r\\n        uint256 amountIn,\\r\\n        address routerAddress,\\r\\n        address sell_token,\\r\\n        address buy_token\\r\\n    ) public returns (uint256) {\\r\\n\\r\\n        uint256 amountOutMin = (_getPrice(\\r\\n            routerAddress,\\r\\n            sell_token,\\r\\n            buy_token,\\r\\n            amountIn\\r\\n        ) * 95) / 100;\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = sell_token;\\r\\n        path[1] = buy_token;\\r\\n        if(sell_token == wethAddress){\\r\\n        uint256 amountOut = IUniswapV2Router02(routerAddress)\\r\\n            .swapExactETHForTokens{value:amountIn}(\\r\\n                amountOutMin,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp + 300\\r\\n            )[1];\\r\\n        return amountOut;\\r\\n        }\\r\\n        else{\\r\\n        require(IERC20(sell_token).approve(routerAddress, amountIn + 10000), \\u0027approval failed\\u0027);\\r\\n        uint256 amountOut = IUniswapV2Router02(routerAddress)\\r\\n            .swapExactTokensForTokens(\\r\\n                amountIn,\\r\\n                amountOutMin,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp + 300\\r\\n            )[1];\\r\\n        return amountOut;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _comparePrice(uint256 amount, address temptoken) internal view returns (Exchange) {\\r\\n        uint256 uniswapPrice = _getPrice(\\r\\n            uniswapRouterAddress,\\r\\n            wethAddress,\\r\\n            temptoken,\\r\\n            amount\\r\\n        );\\r\\n        uint256 sushiswapPrice = _getPrice(\\r\\n            sushiswapRouterAddress,\\r\\n            wethAddress,\\r\\n            temptoken,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        // we try to sell ETH with higher price and buy it back with low price to make profit\\r\\n        if (uniswapPrice \\u003e sushiswapPrice) {\\r\\n            require(\\r\\n                _checkIfArbitrageIsProfitable(\\r\\n                    uniswapPrice,\\r\\n                    sushiswapPrice\\r\\n                ),\\r\\n                \\\"Arbitrage not profitable\\\"\\r\\n            );\\r\\n            return Exchange.UNI;\\r\\n        } else if (uniswapPrice \\u003c sushiswapPrice) {\\r\\n            require(\\r\\n                _checkIfArbitrageIsProfitable(\\r\\n                    sushiswapPrice,\\r\\n                    uniswapPrice\\r\\n                ),\\r\\n                \\\"Arbitrage not profitable\\\"\\r\\n            );\\r\\n            return Exchange.SUSHI;\\r\\n        } else {\\r\\n            return Exchange.NONE;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkIfArbitrageIsProfitable(\\r\\n        uint256 higherPrice,\\r\\n        uint256 lowerPrice\\r\\n    ) internal pure returns (bool) {\\r\\n        // uniswap \\u0026 sushiswap have 0.3% fee for every exchange\\r\\n        // so gain made must be greater than 2 * 0.3% * arbitrage_amount\\r\\n\\r\\n        // difference in ETH\\r\\n        uint256 difference = higherPrice - lowerPrice;\\r\\n\\r\\n        uint256 payed_fee = (2 * (lowerPrice * 3)) / 1000;  \\r\\n\\r\\n        if (difference \\u003e payed_fee) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getPrice(\\r\\n        address routerAddress,\\r\\n        address sell_token,\\r\\n        address buy_token,\\r\\n        uint256 amount\\r\\n    ) internal view returns (uint256) {\\r\\n        address[] memory pairs = new address[](2);\\r\\n        pairs[0] = sell_token;\\r\\n        pairs[1] = buy_token;\\r\\n        uint256 price = IUniswapV2Router02(routerAddress).getAmountsOut(\\r\\n            amount,\\r\\n            pairs\\r\\n        )[1];\\r\\n        return price;\\r\\n    }\\r\\n}\\r\\n\"}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiswapRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"}],\"name\":\"_swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbitrageAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"temptoken\",\"type\":\"address\"}],\"name\":\"makeArbitrage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"temptoken\",\"type\":\"address\"}],\"name\":\"makeabtsu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"temptoken\",\"type\":\"address\"}],\"name\":\"makeabtus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"abt_amount\",\"type\":\"uint256\"}],\"name\":\"setabitrigeamount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiveaddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "SimpleArbitrage",
    "CompilerVersion": "v0.8.7+commit.e28d00a7",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006b175474e89094c44da98b954eedeac495271d0f",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "None",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://3221bbab90dbf401b51dea3f8a16f18cdc7d3fdca5218e4ad5e70e3cb08e902b"
}