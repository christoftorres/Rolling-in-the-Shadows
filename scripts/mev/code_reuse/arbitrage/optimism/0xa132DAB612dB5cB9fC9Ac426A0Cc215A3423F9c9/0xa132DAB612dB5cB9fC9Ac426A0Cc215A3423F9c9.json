{
    "SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.13;\r\n\r\nlibrary Math {\r\n    function max(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n    function cbrt(uint256 n) internal pure returns (uint256) { unchecked {\r\n        uint256 x = 0;\r\n        for (uint256 y = 1 << 255; y > 0; y >>= 3) {\r\n            x <<= 1;\r\n            uint256 z = 3 * x * (x + 1) + 1;\r\n            if (n / y >= z) {\r\n                n -= y * z;\r\n                x += 1;\r\n            }\r\n        }\r\n        return x;\r\n    }}\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IPair {\r\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\r\n    function claimFees() external returns (uint, uint);\r\n    function tokens() external returns (address, address);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\r\n    function getAmountOut(uint, address) external view returns (uint);\r\n}\r\n\r\ninterface IPairFactory {\r\n    function allPairsLength() external view returns (uint);\r\n    function isPair(address pair) external view returns (bool);\r\n    function pairCodeHash() external pure returns (bytes32);\r\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\r\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\r\n}\r\n\r\ninterface IRouter {\r\n    function pairFor(address tokenA, address tokenB, bool stable) external view returns (address pair);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external returns (uint);\r\n}\r\n\r\ncontract Router is IRouter {\r\n\r\n    struct route {\r\n        address from;\r\n        address to;\r\n        bool stable;\r\n    }\r\n\r\n    address public immutable factory;\r\n    IWETH public immutable weth;\r\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\r\n    bytes32 immutable pairCodeHash;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _weth) {\r\n        factory = _factory;\r\n        pairCodeHash = IPairFactory(_factory).pairCodeHash();\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'Router: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'Router: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\r\n            hex'ff',\r\n            factory,\r\n            keccak256(abi.encodePacked(token0, token1, stable)),\r\n            pairCodeHash // init code hash\r\n        )))));\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'Router: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'Router: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA * reserveB / reserveA;\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IPair(pairFor(tokenA, tokenB, stable)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\r\n        address pair = pairFor(tokenIn, tokenOut, true);\r\n        uint amountStable;\r\n        uint amountVolatile;\r\n        if (IPairFactory(factory).isPair(pair)) {\r\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\r\n        }\r\n        pair = pairFor(tokenIn, tokenOut, false);\r\n        if (IPairFactory(factory).isPair(pair)) {\r\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\r\n        }\r\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\r\n        require(routes.length >= 1, 'Router: INVALID_PATH');\r\n        amounts = new uint[](routes.length+1);\r\n        amounts[0] = amountIn;\r\n        for (uint i = 0; i < routes.length; i++) {\r\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].stable);\r\n            if (IPairFactory(factory).isPair(pair)) {\r\n                amounts[i+1] = IPair(pair).getAmountOut(amounts[i], routes[i].from);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isPair(address pair) external view returns (bool) {\r\n        return IPairFactory(factory).isPair(pair);\r\n    }\r\n\r\n    function quoteAddLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint amountADesired,\r\n        uint amountBDesired\r\n    ) external view returns (uint amountA, uint amountB, uint liquidity) {\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\r\n        (uint reserveA, uint reserveB) = (0,0);\r\n        uint _totalSupply = 0;\r\n        if (_pair != address(0)) {\r\n            _totalSupply = IERC20(_pair).totalSupply();\r\n            (reserveA, reserveB) = getReserves(tokenA, tokenB, stable);\r\n        }\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\r\n        } else {\r\n\r\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\r\n            } else {\r\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\r\n            }\r\n        }\r\n    }\r\n\r\n    function quoteRemoveLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint liquidity\r\n    ) external view returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\r\n\r\n        if (_pair == address(0)) {\r\n            return (0,0);\r\n        }\r\n\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\r\n        uint _totalSupply = IERC20(_pair).totalSupply();\r\n\r\n        amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\r\n        amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\r\n\r\n    }\r\n\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal returns (uint amountA, uint amountB) {\r\n        require(amountADesired >= amountAMin);\r\n        require(amountBDesired >= amountBMin);\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\r\n        if (_pair == address(0)) {\r\n            _pair = IPairFactory(factory).createPair(tokenA, tokenB, stable);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, stable, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = pairFor(tokenA, tokenB, stable);\r\n        _safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        _safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IPair(pair).mint(to);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        bool stable,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            address(weth),\r\n            stable,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = pairFor(token, address(weth), stable);\r\n        _safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        weth.deposit{value: amountETH}();\r\n        assert(weth.transfer(pair, amountETH));\r\n        liquidity = IPair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) _safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB, stable);\r\n        require(IPair(pair).transferFrom(msg.sender, pair, liquidity)); // send liquidity to pair\r\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        bool stable,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            address(weth),\r\n            stable,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        _safeTransfer(token, to, amountToken);\r\n        weth.withdraw(amountETH);\r\n        _safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB, stable);\r\n        {\r\n            uint value = approveMax ? type(uint).max : liquidity;\r\n            IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        }\r\n\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, stable, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        bool stable,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH) {\r\n        address pair = pairFor(token, address(weth), stable);\r\n        uint value = approveMax ? type(uint).max : liquidity;\r\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, stable, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, route[] memory routes, address _to) internal virtual {\r\n        for (uint i = 0; i < routes.length; i++) {\r\n            (address token0,) = sortTokens(routes[i].from, routes[i].to);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < routes.length - 1 ? pairFor(routes[i+1].from, routes[i+1].to, routes[i+1].stable) : _to;\r\n            IPair(pairFor(routes[i].from, routes[i].to, routes[i].stable)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSimple(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address tokenFrom,\r\n        address tokenTo,\r\n        bool stable,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory amounts) {\r\n        route[] memory routes = new route[](1);\r\n        routes[0].from = tokenFrom;\r\n        routes[0].to = tokenTo;\r\n        routes[0].stable = stable;\r\n        amounts = getAmountsOut(amountIn, routes);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        _safeTransferFrom(\r\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\r\n        );\r\n        _swap(amounts, routes, to);\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        route[] calldata routes,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = getAmountsOut(amountIn, routes);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        _safeTransferFrom(\r\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\r\n        );\r\n        _swap(amounts, routes, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, route[] calldata routes, address to, uint deadline)\r\n    external\r\n    payable\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(routes[0].from == address(weth), 'Router: INVALID_PATH');\r\n        amounts = getAmountsOut(msg.value, routes);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        weth.deposit{value: amounts[0]}();\r\n        assert(weth.transfer(pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]));\r\n        _swap(amounts, routes, to);\r\n    }\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, route[] calldata routes, address to, uint deadline)\r\n    external\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(routes[routes.length - 1].to == address(weth), 'Router: INVALID_PATH');\r\n        amounts = getAmountsOut(amountIn, routes);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        _safeTransferFrom(\r\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\r\n        );\r\n        _swap(amounts, routes, address(this));\r\n        weth.withdraw(amounts[amounts.length - 1]);\r\n        _safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function UNSAFE_swapExactTokensForTokens(\r\n        uint[] memory amounts,\r\n        route[] calldata routes,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory) {\r\n        _safeTransferFrom(routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]);\r\n        _swap(amounts, routes, to);\r\n        return amounts;\r\n    }\r\n\r\n    function _safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) =\r\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) =\r\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"UNSAFE_swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"}],\"name\":\"quoteAddLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"quoteRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"sortTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSimple\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "Router",
    "CompilerVersion": "v0.8.13+commit.abaa5c0e",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "00000000000000000000000025cbddb98b35ab1ff77413456b31ec81a6b6b7460000000000000000000000004200000000000000000000000000000000000006",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://6e4900dfdd039707da891ddd17657c281f314f0146e14f58f3ea39ce3ebd3f3e"
}