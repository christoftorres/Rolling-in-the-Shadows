{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.5/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.5/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n  function raiseFlag(address) external;\\n  function raiseFlags(address[] calldata) external;\\n  function lowerFlags(address[] calldata) external;\\n  function setRaisingAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerCommonImpl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../ErrorReporter.sol\\\";\\r\\nimport \\\"../Utils/ExponentialNoError.sol\\\";\\r\\nimport \\\"./ComptrollerInterfaces.sol\\\";\\r\\n\\r\\ncontract ComptrollerNoNFTCommonImpl is ComptrollerNoNFTCommonInterface, ComptrollerErrorReporter, ExponentialNoError {\\r\\n    constructor() internal {\\r\\n        admin = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function, part of the upgradable contracts system, use to set the implementation contract\\r\\n     * @param unitrollerAddress The unitroller storage contract that this contract is supposed to be implementation of\\r\\n     */\\r\\n    function _become(address unitrollerAddress) external {\\r\\n        onlyAdmin();\\r\\n        UnitrollerInterface unitroller = UnitrollerInterface(unitrollerAddress);\\r\\n        require(msg.sender == unitroller.admin(), \\\"only unitroller admin can change brains\\\");\\r\\n        unitroller._acceptImplementation();\\r\\n    }\\r\\n\\r\\n    function getBlockNumber() internal view returns (uint) {\\r\\n        return block.number;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks caller is admin, or this contract is becoming the new implementation\\r\\n    function adminOrInitializing() internal view {\\r\\n        require(msg.sender == admin || msg.sender == comptrollerPart1Implementation || msg.sender == comptrollerPart2Implementation, \\\"only admin or initializing\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Checks caller is admin\\r\\n    function onlyAdmin() internal view {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection). Partial implementation should never return true here (see isComptrollerPart1, isComptrollerPart2)\\r\\n    function isComptroller() external pure returns (bool) {\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ComptrollerNFTCommonImpl is ComptrollerNoNFTCommonImpl, ComptrollerNFTCommonInterface { }\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./ComptrollerStorage.sol\\\";\\r\\n\\r\\ncontract UnitrollerInterface is UnitrollerAdminStorage {\\r\\n    /// @notice Emitted when pendingComptrollerImplementation is changed\\r\\n    event NewPendingImplementations(address oldPendingPart1Implementation, address newPendingPart1Implementation, address oldPendingPart2Implementation, address newPendingPart2Implementation);\\r\\n\\r\\n    /// @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\\r\\n    event NewImplementation(address oldPart1Implementation, address newPart1Implementation, address oldPart2Implementation, address newPart2Implementation);\\r\\n\\r\\n    /// @notice Emitted when pendingAdmin is changed\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\r\\n    function isComptroller() external pure returns (bool);\\r\\n\\r\\n    function _setPendingImplementations(address newPendingPart1Implementation, address newPendingPart2Implementation) external;\\r\\n\\r\\n    function _acceptImplementation() external;\\r\\n\\r\\n    function _setPendingAdmin(address newPendingAdmin) external;\\r\\n\\r\\n    function _acceptAdmin() external;\\r\\n}\\r\\n\\r\\ncontract ComptrollerNoNFTCommonInterface is ComptrollerNoNFTStorage {\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\r\\n    function isComptroller() external pure returns (bool);\\r\\n\\r\\n    /// @notice Emitted when an admin supports a market (marketType 0 == standard assets, 1 == nfts)\\r\\n    event MarketListed(address indexed pToken, uint indexed marketType, address underlying);\\r\\n\\r\\n    /// @notice Emitted when an account enters a market\\r\\n    event MarketEntered(address indexed pToken, address indexed account);\\r\\n\\r\\n    /// @notice Emitted when an account exits a market\\r\\n    event MarketExited(address indexed pToken, address indexed account);\\r\\n\\r\\n    /// @notice Emitted when close factor is changed by admin\\r\\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\\r\\n\\r\\n    /// @notice Emitted when a collateral factor is changed by admin\\r\\n    event NewCollateralFactor(address indexed pToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\\r\\n\\r\\n    /// @notice Emitted when liquidation incentive is changed by admin\\r\\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\\r\\n\\r\\n    /// @notice Emitted when price oracle is changed\\r\\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\\r\\n\\r\\n    /// @notice Emitted when pause guardian is changed\\r\\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\r\\n\\r\\n    /// @notice Emitted when an action is paused on a market or globally (pToken == 0)\\r\\n    event ActionPaused(address indexed pToken, string indexed action, bool pauseState);\\r\\n\\r\\n    /// @notice Emitted when a new borrow-side PBX speed is calculated for a market\\r\\n    event PBXBorrowSpeedUpdated(PToken indexed pToken, uint newSpeed);\\r\\n\\r\\n    /// @notice Emitted when a new supply-side PBX speed is calculated for a market\\r\\n    event PBXSupplySpeedUpdated(PToken indexed pToken, uint newSpeed);\\r\\n\\r\\n    /// @notice Emitted when a new PBX speed is set for a contributor\\r\\n    event ContributorPBXSpeedUpdated(address indexed contributor, uint newSpeed);\\r\\n\\r\\n    /// @notice Emitted when PBX is distributed to a supplier\\r\\n    event DistributedSupplierPBX(PToken indexed pToken, address indexed supplier, uint compDelta, uint PBXSupplyIndex);\\r\\n\\r\\n    /// @notice Emitted when PBX is distributed to a borrower\\r\\n    event DistributedBorrowerPBX(PToken indexed pToken, address indexed borrower, uint compDelta, uint PBXBorrowIndex);\\r\\n\\r\\n    /// @notice Emitted when borrow cap for a pToken is changed\\r\\n    event NewBorrowCap(PToken indexed pToken, uint newBorrowCap);\\r\\n\\r\\n    /// @notice Emitted when borrow cap guardian is changed\\r\\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\\r\\n\\r\\n    /// @notice Emitted when PBX is granted by admin\\r\\n    event PBXGranted(address indexed recipient, uint amount);\\r\\n\\r\\n    event NewPBXToken(address oldPBXToken, address newPBXToken);\\r\\n\\r\\n    function _become(address unitrollerAddress) external;\\r\\n}\\r\\n\\r\\ncontract ComptrollerNFTCommonInterface is ComptrollerNoNFTCommonInterface, ComptrollerNFTStorage {\\r\\n    event NFTLiquidationExchangePTokenSet(PToken indexed pToken, bool indexed enabled);\\r\\n\\r\\n    event NewNFTCollateralLiquidationIncentive(uint oldNFTCollateralLiquidationIncentiveMantissa, uint newNFTCollateralLiquidationIncentiveMantissa);\\r\\n\\r\\n    event NewNFTCollateralLiquidationBonusPBXIncentive(uint oldNFTCollateralLiquidationBonusPBXIncentiveMantissa, uint newNFTCollateralLiquidationBonusPBXIncentiveMantissa);\\r\\n\\r\\n    event NewNFTCollateralSeizeLiquidationFactor(uint oldNFTCollateralSeizeLiquidationFactorMantissa, uint newNFTCollateralSeizeLiquidationFactorMantissa);\\r\\n}\\r\\n\\r\\ncontract ComptrollerNoNFTPart1Interface is ComptrollerNoNFTCommonInterface {\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\r\\n    bool public constant isComptrollerPart1 = true;\\r\\n\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function getAssetsIn(address account) external view returns (PToken[] memory);\\r\\n    function checkMembership(address account, address pToken) external view returns (bool);\\r\\n    function getDepositBorrowValues(address account) external view returns (uint, uint, uint);\\r\\n    function getAllMarkets() external view returns (PToken[] memory);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setPriceOracle(address newOracle) external;\\r\\n    function _setCloseFactor(uint newCloseFactorMantissa) external;\\r\\n    function _setCollateralFactor(PToken pToken, uint newCollateralFactorMantissa) external returns (uint);\\r\\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external;\\r\\n    function _supportMarket(PToken pToken) external returns (uint);\\r\\n    function _setMarketBorrowCaps(PToken[] calldata pTokens, uint[] calldata newBorrowCaps) external;\\r\\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\\r\\n    function _setPauseGuardian(address newPauseGuardian) external;\\r\\n    function _setMintPaused(address pToken, bool state) external returns (bool);\\r\\n    function _setMintPausedGlobal(bool state) public returns (bool);\\r\\n    function _setBorrowPaused(address pToken, bool state) external returns (bool);\\r\\n    function _setBorrowPausedGlobal(bool state) public returns (bool);\\r\\n    function _setTransferPaused(bool state) public returns (bool);\\r\\n    function _setSeizePaused(bool state) public returns (bool);\\r\\n    function _setAllPausedGlobal(bool state) external returns (bool);\\r\\n    function _setPBXToken(address newPBXTokenAddress) external;\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function mintVerify(address pToken, address minter, uint mintAmount, uint mintTokens) external;\\r\\n    function redeemVerify(address pToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\\r\\n    function borrowVerify(address pToken, address borrower, uint borrowAmount) external;\\r\\n    function repayBorrowVerify(address pToken, address payer, address borrower, uint repayAmount, uint borrowerIndex) external;\\r\\n    function liquidateBorrowVerify(address pTokenBorrowed, address pTokenCollateral, address liquidator, address borrower, uint repayAmount, uint seizeTokens) external;\\r\\n    function seizeVerify(address pTokenCollateral, address pTokenBorrowed, address liquidator, address borrower, uint seizeTokens) external;\\r\\n    function transferVerify(address pToken, address src, address dst, uint transferTokens) external;\\r\\n\\r\\n    /*** PBX Distribution Admin ***/\\r\\n\\r\\n    function _setContributorPBXSpeed(address contributor, uint PBXSpeed) external;\\r\\n\\r\\n    /*** PBX Distribution ***/\\r\\n\\r\\n    function updateContributorRewards(address contributor) public;\\r\\n}\\r\\n\\r\\ncontract ComptrollerNFTPart1Interface is ComptrollerNoNFTPart1Interface, ComptrollerNFTCommonInterface {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function getNFTAssetsIn(address account) external view returns (PNFTToken[] memory);\\r\\n    function getNFTDepositValue(address account) public view returns (uint);\\r\\n    function getAllNFTMarkets() external view returns (PNFTToken[] memory);\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    function nftLiquidateCalculateValues(address PNFTTokenAddress, uint tokenId, address NFTLiquidationExchangePToken) external view returns (uint, uint, uint, uint);\\r\\n    function nftLiquidateCalculatePBXBonusIncentive(uint nftMinimumSellValueUSD) public view returns (uint);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setNFTCollateralFactor(PNFTToken pNFTToken, uint newCollateralFactorMantissa) external returns (uint);\\r\\n    function _setNFTCollateralLiquidationIncentive(uint newNFTCollateralLiquidationIncentiveMantissa) external;\\r\\n    function _setNFTCollateralLiquidationBonusPBX(uint newNFTCollateralLiquidationBonusPBXIncentiveMantissa) external;\\r\\n    function _setNFTCollateralSeizeLiquidationFactor(uint newNFTCollateralSeizeLiquidationFactorMantissa) external;\\r\\n    function _supportNFTMarket(PNFTToken pNFTToken) external returns (uint);\\r\\n    function _setNFTLiquidationExchangePToken(address _NFTLiquidationExchangePToken, bool enabled) external;\\r\\n    function _setNFTXioMarketplaceZapAddress(address _NFTXioMarketplaceZapAddress) external;\\r\\n    function _setSudoswapPairRouterAddress(address _SudoswapPairRouterAddress) external;\\r\\n    function _setNFTModuleClosedBeta(bool _NFTModuleClosedBeta) external;\\r\\n    function _NFTModuleWhitelistUser(address[] calldata whitelistedUsers) external;\\r\\n    function _NFTModuleRemoveWhitelistUser(address[] calldata removedUsers) external;\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function mintNFTVerify(address pNFTToken, address minter, uint tokenId) external;\\r\\n    function redeemNFTVerify(address pNFTToken, address redeemer, uint tokenId) external;\\r\\n    function transferNFTVerify(address pNFTToken, address src, address dst, uint tokenId) external;\\r\\n    function liquidateNFTCollateralVerify(address pNFTTokenCollateral, address liquidator, address borrower, uint tokenId) external;\\r\\n}\\r\\n\\r\\ncontract ComptrollerNoNFTPart2Interface is ComptrollerNoNFTCommonInterface {\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\r\\n    bool public constant isComptrollerPart2 = true;\\r\\n\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function enterMarkets(address[] calldata pTokens) external returns (uint[] memory);\\r\\n    function exitMarket(address pToken) external returns (uint);\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    function liquidateCalculateSeizeTokens(address pTokenBorrowed, address pTokenCollateral, uint repayAmount) external view returns (uint, uint);\\r\\n    function getHypotheticalAccountLiquidity(address account, address pTokenModify, uint redeemTokens, uint borrowAmount, uint redeemTokenId) external view returns (uint, uint, uint);\\r\\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\\r\\n    function getCollateralBorrowValues(address account) external view returns (uint, uint, uint);\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function mintAllowed(address pToken, address minter, uint mintAmount) external returns (uint);\\r\\n    function redeemAllowed(address pToken, address redeemer, uint redeemTokens) external returns (uint);\\r\\n    function borrowAllowed(address pToken, address borrower, uint borrowAmount) external returns (uint);\\r\\n    function transferAllowed(address pToken, address src, address dst, uint transferTokens) external returns (uint);\\r\\n    function repayBorrowAllowed(address pToken, address payer, address borrower, uint repayAmount) external returns (uint);\\r\\n    function seizeAllowed(address pTokenCollateral, address pTokenBorrowed, address liquidator, address borrower, uint seizeTokens) external returns (uint);\\r\\n    function liquidateBorrowAllowed(address pTokenBorrowed, address pTokenCollateral, address liquidator, address borrower, uint repayAmount) external returns (uint);\\r\\n\\r\\n    /*** PBX Distribution ***/\\r\\n\\r\\n    function claimPBXReward(address holder) external;\\r\\n    function claimPBXSingle(address holder, PToken[] memory pTokens) public;\\r\\n    function claimPBX(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public;\\r\\n    function PBXAccrued(address holder) public view returns (uint);\\r\\n\\r\\n    /*** PBX Distribution Admin ***/\\r\\n\\r\\n    function _grantPBX(address recipient, uint amount) external;\\r\\n    function _setPBXSpeeds(PToken[] calldata pTokens, uint[] calldata supplySpeeds, uint[] calldata borrowSpeeds) external;\\r\\n}\\r\\n\\r\\ncontract ComptrollerNFTPart2Interface is ComptrollerNoNFTPart2Interface, ComptrollerNFTCommonInterface {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function enterNFTMarkets(address[] calldata pNFTTokens) external returns (uint[] memory);\\r\\n    function exitNFTMarket(address pNFTToken) external returns (uint);\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    function nftLiquidateSendPBXBonusIncentive(uint bonusIncentive, address liquidator) external;\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function mintNFTAllowed(address pNFTToken, address minter, uint tokenId) external returns (uint);\\r\\n    function redeemNFTAllowed(address pToken, address redeemer, uint tokenId) external returns (uint);\\r\\n    function transferNFTAllowed(address pToken, address src, address dst, uint tokenId) external returns (uint);\\r\\n    function liquidateNFTCollateralAllowed(address pNFTTokenCollateral, address liquidator, address borrower, uint tokenId, address NFTLiquidationExchangePToken) external returns (uint);\\r\\n}\\r\\n\\r\\ncontract ComptrollerNFTInterface is ComptrollerNFTPart1Interface, ComptrollerNFTPart2Interface { }\\r\\ncontract ComptrollerNoNFTInterface is ComptrollerNoNFTPart1Interface, ComptrollerNoNFTPart2Interface { }\\r\\ncontract ComptrollerNFTUnitrollerMergedInterface is UnitrollerInterface, ComptrollerNFTInterface { }\\r\\ncontract ComptrollerNoNFTUnitrollerMergedInterface is UnitrollerInterface, ComptrollerNoNFTInterface { }\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerNFTPart1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./ComptrollerNoNFTPart1.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus Comptroller Part1 Contract\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract ComptrollerNFTPart1 is ComptrollerNoNFTPart1, ComptrollerNFTCommonImpl {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function getNFTAssetsIn(address account) external view returns (PNFTToken[] memory) {\\r\\n        return accountNFTAssets[account];\\r\\n    }\\r\\n\\r\\n    function getAllNFTMarkets() external view returns (PNFTToken[] memory) {\\r\\n        return allNFTMarkets;\\r\\n    }\\r\\n\\r\\n    function getDepositBorrowValues(address account) external view returns (uint, uint, uint) {\\r\\n        (uint standardAssetsSumDeposit, uint sumBorrowPlusEffects) = getStandardAssetsDepositBorrowValuesInternal(account);\\r\\n        return (standardAssetsSumDeposit, getNFTDepositValue(account), sumBorrowPlusEffects);\\r\\n    }\\r\\n\\r\\n    function getNFTDepositValue(address account) public view returns (uint) {\\r\\n        uint sumDeposit = 0;\\r\\n\\r\\n        // For every supported NFT market (no matter whether user is in (enter market) or not)\\r\\n        PNFTToken[] memory nftAssets = allNFTMarkets;\\r\\n\\r\\n        for (uint i = 0; i < nftAssets.length; i++) {\\r\\n            PNFTToken nftAsset = nftAssets[i];\\r\\n\\r\\n            // Read the balances from the pToken\\r\\n            uint pTokenBalance = nftAsset.balanceOf(account);\\r\\n\\r\\n            // For each tokenId in nftAsset\\r\\n            for (uint j = 0; j < pTokenBalance; j++) {\\r\\n                uint256 tokenId = nftAsset.tokenOfOwnerByIndex(account, j);\\r\\n\\r\\n                // Get the normalized price of the tokenId\\r\\n                uint oraclePriceMantissa = PriceOracleInterface(oracle).getUnderlyingNFTPrice(nftAsset, tokenId);\\r\\n                require(oraclePriceMantissa > 0, \\\"Error.PRICE_ERROR\\\");\\r\\n\\r\\n                // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\r\\n                Exp memory tokensToDenom = mul_(Exp({mantissa : oraclePriceMantissa}), Exp({mantissa : 1e36}));\\r\\n\\r\\n                // sumDeposit += tokensToDenom\\r\\n                sumDeposit = add_(truncate(tokensToDenom), sumDeposit);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return sumDeposit;\\r\\n    }\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    /// @return (nft minimum sell value, liquidation incentive, bonus pbx incentive, liquidate seize value)\\r\\n    function nftLiquidateCalculateValues(address PNFTTokenAddress, uint tokenId, address NFTLiquidationExchangePToken) external view returns (uint, uint, uint, uint) {\\r\\n        require(PNFTToken(PNFTTokenAddress).isPNFTToken());\\r\\n        require(markets[PNFTTokenAddress].isListed, \\\"market not listed\\\");\\r\\n\\r\\n        require(NFTLiquidationExchangePToken != address(0), \\\"invalid argument\\\");\\r\\n        require(PToken(NFTLiquidationExchangePToken).isPToken());\\r\\n        require(markets[NFTLiquidationExchangePToken].isListed, \\\"NFTLiquidationExchangePToken market not listed\\\");\\r\\n        require(isNFTLiquidationExchangePToken[NFTLiquidationExchangePToken], \\\"NFTLiquidationExchangePToken not supported\\\");\\r\\n\\r\\n        // get NFT price\\r\\n        Exp memory nftOraclePriceUSD = mul_(Exp({mantissa : 1e36}), Exp({mantissa : PriceOracleInterface(oracle).getUnderlyingNFTPrice(PNFTToken(PNFTTokenAddress), tokenId)})); // USD, 36 decimals\\r\\n        require(truncate(nftOraclePriceUSD) > 0, \\\"Error.PRICE_ERROR\\\");\\r\\n\\r\\n        // calculate nft liquidate seize price\\r\\n        // can be 0 if NFTCollateralSeizeLiquidationFactorMantissa is not set!\\r\\n        Exp memory nftLiquidateSeizeValueUSD = mul_(Exp({mantissa : NFTCollateralSeizeLiquidationFactorMantissa}), nftOraclePriceUSD); // USD, 36 decimals\\r\\n\\r\\n        // calculate nft minimum sell value\\r\\n        // include NFT collateral factor\\r\\n        Exp memory nftTokenCollateralWorthUSD = mul_(Exp({mantissa : markets[PNFTTokenAddress].collateralFactorMantissa}), nftOraclePriceUSD); // USD, 36 decimals\\r\\n\\r\\n        // include exchange token collateral factor\\r\\n        Exp memory minSellValueUSD = div_(nftTokenCollateralWorthUSD, Exp({mantissa : markets[NFTLiquidationExchangePToken].collateralFactorMantissa})); // USD, 36 decimals\\r\\n\\r\\n        // add 0.001 USD because of fixed-point arithmetic, so after selling NFT the account liquidity IS NEVER lower\\r\\n        minSellValueUSD = add_(minSellValueUSD, Exp({mantissa : 1e33}));\\r\\n\\r\\n        // calculate collateral liquidation incentive\\r\\n        Exp memory minSellValueUSDWithIncentive = mul_(Exp({mantissa : NFTCollateralLiquidationIncentiveMantissa}), minSellValueUSD); // USD, 36 decimals\\r\\n\\r\\n        // get NFTLiquidationExchangePToken price\\r\\n        Exp memory exchangeTokenOraclePrice = Exp({mantissa : PriceOracleInterface(oracle).getUnderlyingPrice(PToken(NFTLiquidationExchangePToken))});\\r\\n        require(truncate(exchangeTokenOraclePrice) > 0, \\\"Error.PRICE_ERROR\\\");\\r\\n\\r\\n        {\\r\\n            // convert results in USD to NFTLiquidationExchangeTokens and adjust decimals\\r\\n            Exp memory minSellValue = div_(minSellValueUSD, exchangeTokenOraclePrice); // NFTLiquidationExchangeTokens\\r\\n            Exp memory minSellValueWithIncentive = div_(minSellValueUSDWithIncentive, exchangeTokenOraclePrice); // NFTLiquidationExchangeTokens\\r\\n            uint liquidationIncentive = truncate(sub_(minSellValueWithIncentive, minSellValue));\\r\\n            uint nftLiquidateSeizeValue = truncate(div_(nftLiquidateSeizeValueUSD, exchangeTokenOraclePrice)); // NFTLiquidationExchangeTokens\\r\\n\\r\\n            require(NFTCollateralSeizeLiquidationFactorMantissa == 0 || nftLiquidateSeizeValue >= truncate(minSellValueWithIncentive), \\\"invalid NFTCollateralSeizeLiquidationFactorMantissa parameter, nftLiquidateSeizeValue too low\\\");\\r\\n            require(truncate(minSellValueWithIncentive) > 0, \\\"minSellValueWithIncentive too low\\\");\\r\\n\\r\\n            return (truncate(minSellValueWithIncentive), liquidationIncentive, nftLiquidateCalculatePBXBonusIncentive(truncate(minSellValueUSDWithIncentive)), nftLiquidateSeizeValue);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function nftLiquidateCalculatePBXBonusIncentive(uint nftMinimumSellValueUSD) public view returns (uint) {\\r\\n        // calculate bonus PBX incentive\\r\\n        Exp memory resultUSDWithBonusIncentive = mul_(Exp({mantissa : NFTCollateralLiquidationBonusPBXIncentiveMantissa}), Exp({mantissa : nftMinimumSellValueUSD})); // USD, 18 decimals\\r\\n        Exp memory bonusIncentiveUSD = sub_(resultUSDWithBonusIncentive, Exp({mantissa : nftMinimumSellValueUSD}), 'INCENTIVE_TOO_MUCH'); // USD, 18 decimals\\r\\n\\r\\n        // treat this as amount in PBX, adjust decimals\\r\\n        uint PBXDecimals = EIP20Interface(PBXToken).decimals();\\r\\n        require(PBXDecimals <= 18, \\\"unexpected PBX token decimals\\\");\\r\\n        Exp memory bonusIncentivePBX = div_(bonusIncentiveUSD, 10 ** (18 - PBXDecimals));\\r\\n\\r\\n        return bonusIncentivePBX.mantissa; // NFT TODO use truncate?\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setNFTCollateralFactor(PNFTToken pNFTToken, uint newCollateralFactorMantissa) external returns (uint) {\\r\\n        require(newCollateralFactorMantissa <= 10 ** 18, \\\"invalid argument\\\");\\r\\n        require(pNFTToken.isPNFTToken());\\r\\n\\r\\n        // If collateral factor != 0, fail if nft collection not supported\\r\\n        if (newCollateralFactorMantissa != 0 && !PriceOracleInterface(oracle).isNFTCollectionSupported(pNFTToken.underlying())) {\\r\\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\\r\\n        }\\r\\n\\r\\n        return _setCollateralFactorInternal(address(pNFTToken), newCollateralFactorMantissa);\\r\\n    }\\r\\n\\r\\n    function _setNFTCollateralLiquidationIncentive(uint newNFTCollateralLiquidationIncentiveMantissa) external {\\r\\n        onlyAdmin();\\r\\n        require(newNFTCollateralLiquidationIncentiveMantissa >= 10 ** 18, \\\"invalid argument\\\");\\r\\n\\r\\n        emit NewNFTCollateralLiquidationIncentive(NFTCollateralLiquidationIncentiveMantissa, newNFTCollateralLiquidationIncentiveMantissa);\\r\\n        NFTCollateralLiquidationIncentiveMantissa = newNFTCollateralLiquidationIncentiveMantissa;\\r\\n    }\\r\\n\\r\\n    function _setNFTCollateralSeizeLiquidationFactor(uint newNFTCollateralSeizeLiquidationFactorMantissa) external {\\r\\n        onlyAdmin();\\r\\n        require(newNFTCollateralSeizeLiquidationFactorMantissa < 10 ** 18, \\\"invalid argument\\\");\\r\\n\\r\\n        emit NewNFTCollateralSeizeLiquidationFactor(NFTCollateralSeizeLiquidationFactorMantissa, newNFTCollateralSeizeLiquidationFactorMantissa);\\r\\n        NFTCollateralSeizeLiquidationFactorMantissa = newNFTCollateralSeizeLiquidationFactorMantissa;\\r\\n    }\\r\\n\\r\\n    function _setNFTCollateralLiquidationBonusPBX(uint newNFTCollateralLiquidationBonusPBXIncentiveMantissa) external {\\r\\n        onlyAdmin();\\r\\n        require(newNFTCollateralLiquidationBonusPBXIncentiveMantissa >= 10 ** 18, \\\"invalid argument\\\");\\r\\n\\r\\n        emit NewNFTCollateralLiquidationBonusPBXIncentive(NFTCollateralLiquidationBonusPBXIncentiveMantissa, newNFTCollateralLiquidationBonusPBXIncentiveMantissa);\\r\\n        NFTCollateralLiquidationBonusPBXIncentiveMantissa = newNFTCollateralLiquidationBonusPBXIncentiveMantissa;\\r\\n    }\\r\\n\\r\\n    function _supportNFTMarket(PNFTToken pNFTToken) external returns (uint) {\\r\\n        require(pNFTToken.isPNFTToken());\\r\\n\\r\\n        uint err = _supportMarketInternal(address(pNFTToken));\\r\\n        if (err != uint(Error.NO_ERROR)) return err;\\r\\n\\r\\n        for (uint i = 0; i < allNFTMarkets.length; i++) {\\r\\n            require(allNFTMarkets[i] != pNFTToken, \\\"market already added\\\");\\r\\n        }\\r\\n\\r\\n        allNFTMarkets.push(pNFTToken);\\r\\n\\r\\n        _initializeMarket(address(pNFTToken));\\r\\n        emit MarketListed(address(pNFTToken), 1, pNFTToken.underlying());\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function _setNFTLiquidationExchangePToken(address _NFTLiquidationExchangePToken, bool enabled) external {\\r\\n        onlyAdmin();\\r\\n        require(PErc20Interface(_NFTLiquidationExchangePToken).isPToken());\\r\\n        require(PErc20Interface(_NFTLiquidationExchangePToken).underlying() != address(0)); // sanity check\\r\\n        require(markets[_NFTLiquidationExchangePToken].isListed, \\\"NFTLiquidationExchangePToken not listed as market\\\");\\r\\n\\r\\n        isNFTLiquidationExchangePToken[_NFTLiquidationExchangePToken] = enabled;\\r\\n\\r\\n        emit NFTLiquidationExchangePTokenSet(PToken(_NFTLiquidationExchangePToken), enabled);\\r\\n    }\\r\\n\\r\\n    function _setNFTXioMarketplaceZapAddress(address _NFTXioMarketplaceZapAddress) external {\\r\\n        onlyAdmin();\\r\\n        NFTXioMarketplaceZapAddress = _NFTXioMarketplaceZapAddress;\\r\\n    }\\r\\n\\r\\n    function _setSudoswapPairRouterAddress(address _SudoswapPairRouterAddress) external {\\r\\n        onlyAdmin();\\r\\n        SudoswapPairRouterAddress = _SudoswapPairRouterAddress;\\r\\n    }\\r\\n\\r\\n    function _setNFTModuleClosedBeta(bool _NFTModuleClosedBeta) external {\\r\\n        onlyAdmin();\\r\\n        NFTModuleClosedBeta = _NFTModuleClosedBeta;\\r\\n    }\\r\\n\\r\\n    function _NFTModuleWhitelistUser(address[] calldata whitelistedUsers) external {\\r\\n        onlyAdmin();\\r\\n\\r\\n        for (uint i = 0; i < whitelistedUsers.length; i++)\\r\\n            NFTModuleWhitelistedUsers[whitelistedUsers[i]] = true;\\r\\n    }\\r\\n\\r\\n    function _NFTModuleRemoveWhitelistUser(address[] calldata removedUsers) external {\\r\\n        onlyAdmin();\\r\\n\\r\\n        for (uint i = 0; i < removedUsers.length; i++)\\r\\n            NFTModuleWhitelistedUsers[removedUsers[i]] = false;\\r\\n    }\\r\\n\\r\\n    /*** Policy Hooks, should not be marked as pure, view ***/\\r\\n    /*** Now empty, reserved for potential future use ***/\\r\\n\\r\\n    function mintNFTVerify(address pNFTToken, address minter, uint tokenId) external { }\\r\\n\\r\\n    function redeemNFTVerify(address pNFTToken, address redeemer, uint tokenId) external { }\\r\\n\\r\\n    function transferNFTVerify(address pNFTToken, address src, address dst, uint tokenId) external { }\\r\\n\\r\\n    function liquidateNFTCollateralVerify(address pNFTTokenCollateral, address liquidator, address borrower, uint tokenId) external { }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerNFTPart2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./ComptrollerNoNFTPart2.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus Comptroller Part2 Contract\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract ComptrollerNFTPart2 is ComptrollerNoNFTPart2, ComptrollerNFTCommonImpl {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function enterNFTMarkets(address[] calldata pNFTTokens) external returns (uint[] memory) {\\r\\n        uint len = pNFTTokens.length;\\r\\n\\r\\n        uint[] memory results = new uint[](len);\\r\\n        for (uint i = 0; i < len; i++) {\\r\\n            PNFTToken pNFTToken = PNFTToken(pNFTTokens[i]);\\r\\n            results[i] = uint(addToNFTMarketInternal(pNFTToken, msg.sender));\\r\\n        }\\r\\n\\r\\n        return results;\\r\\n    }\\r\\n\\r\\n    function exitNFTMarket(address pNFTTokenAddress) external returns (uint) {\\r\\n        PNFTToken pNFTToken = PNFTToken(pNFTTokenAddress);\\r\\n        require(pNFTToken.isPNFTToken());\\r\\n\\r\\n        // Fail if the sender is not permitted to redeem all of their tokens\\r\\n        uint allowed = redeemNFTAllowedInternal(pNFTTokenAddress, msg.sender);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        Market storage marketToExit = markets[address(pNFTToken)];\\r\\n\\r\\n        // Return true if the sender is not already \u00e2\u20ac\u02dcin\u00e2\u20ac\u2122 the market\\r\\n        if (!marketToExit.accountMembership[msg.sender]) {\\r\\n            return uint(Error.NO_ERROR);\\r\\n        }\\r\\n\\r\\n        // Set pToken account membership to false\\r\\n        delete marketToExit.accountMembership[msg.sender];\\r\\n\\r\\n        // Delete pToken from the account\u00e2\u20ac\u2122s list of assets\\r\\n        // load into memory for faster iteration\\r\\n        PNFTToken[] memory userAssetList = accountNFTAssets[msg.sender];\\r\\n        uint len = userAssetList.length;\\r\\n        uint assetIndex = len;\\r\\n        for (uint i = 0; i < len; i++) {\\r\\n            if (userAssetList[i] == pNFTToken) {\\r\\n                assetIndex = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\r\\n        assert(assetIndex < len);\\r\\n\\r\\n        // copy last item in list to location of item to be removed, reduce length by 1\\r\\n        PNFTToken[] storage storedList = accountNFTAssets[msg.sender];\\r\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\r\\n        storedList.length--;\\r\\n\\r\\n        emit MarketExited(address(pNFTToken), msg.sender);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function addToNFTMarketInternal(PNFTToken pNFTToken, address borrower) internal returns (Error) {\\r\\n        require(pNFTToken.isPNFTToken());\\r\\n        Market storage marketToJoin = markets[address(pNFTToken)];\\r\\n\\r\\n        if (!marketToJoin.isListed) { // market is not listed, cannot join\\r\\n            return Error.MARKET_NOT_LISTED;\\r\\n        }\\r\\n\\r\\n        if (marketToJoin.accountMembership[borrower]) { // already joined\\r\\n            return Error.NO_ERROR;\\r\\n        }\\r\\n\\r\\n        marketToJoin.accountMembership[borrower] = true;\\r\\n        accountNFTAssets[borrower].push(pNFTToken);\\r\\n\\r\\n        emit MarketEntered(address(pNFTToken), borrower);\\r\\n        return Error.NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    /**\\r\\n    * @return (standard assets collateral worth sum including collateral factor,\\r\\n    *          NFT collateral worth sum including collateral factor,\\r\\n    *          borrow value)\\r\\n    */\\r\\n    function getCollateralBorrowValues(address account) external view returns (uint, uint, uint) {\\r\\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\r\\n\\r\\n        Error err = getHypotheticalAccountLiquidityInternalNFTImpl(account, address(0), 0, vars);\\r\\n        require(err == Error.NO_ERROR, \\\"getHypotheticalAccountLiquidity error\\\");\\r\\n\\r\\n        uint nftCollateralSum = vars.sumCollateral;\\r\\n\\r\\n        err = getHypotheticalAccountLiquidityInternalImpl(account, address(0), 0, 0, vars);\\r\\n        require(err == Error.NO_ERROR, \\\"getHypotheticalAccountLiquidity error\\\");\\r\\n\\r\\n        return (sub_(vars.sumCollateral, nftCollateralSum), nftCollateralSum, vars.sumBorrowPlusEffects);\\r\\n    }\\r\\n\\r\\n    function nftLiquidateSendPBXBonusIncentive(uint bonusIncentive, address liquidator) external {\\r\\n        require(PNFTToken(msg.sender).isPNFTToken());\\r\\n        require(markets[msg.sender].isListed, \\\"market not listed\\\");\\r\\n\\r\\n        grantPBXInternal(liquidator, bonusIncentive);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\r\\n     * @param pTokenModify The market to hypothetically redeem/borrow in\\r\\n     * @param account The account to determine liquidity for\\r\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\r\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\r\\n     * @dev Note that we calculate the exchangeRateStored for each collateral pToken using stored data, without calculating accumulated interest.\\r\\n     * @return (possible error code,\\r\\n                hypothetical account liquidity in excess of collateral requirements,\\r\\n     *          hypothetical account shortfall below collateral requirements)\\r\\n     */\\r\\n    function getHypotheticalAccountLiquidityInternal(address account, address pTokenModify, uint redeemTokens, uint borrowAmount, uint redeemTokenId) internal view returns (uint, uint, uint) {\\r\\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\r\\n\\r\\n        Error err = getHypotheticalAccountLiquidityInternalImpl(account, pTokenModify, redeemTokens, borrowAmount, vars);\\r\\n        if (err != Error.NO_ERROR) return (uint(err), 0, 0);\\r\\n\\r\\n        err = getHypotheticalAccountLiquidityInternalNFTImpl(account, pTokenModify, redeemTokenId, vars);\\r\\n        if (err != Error.NO_ERROR) return (uint(err), 0, 0);\\r\\n\\r\\n        // These are safe, as the underflow condition is checked first\\r\\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\\r\\n            return (uint(Error.NO_ERROR), sub_(vars.sumCollateral, vars.sumBorrowPlusEffects), 0);\\r\\n        } else {\\r\\n            return (uint(Error.NO_ERROR), 0, sub_(vars.sumBorrowPlusEffects, vars.sumCollateral));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getHypotheticalAccountLiquidityInternalNFTImpl(address account, address pTokenModify, uint redeemTokenId, AccountLiquidityLocalVars memory vars) internal view returns (Error) {\\r\\n        // For each NFT asset the account is in\\r\\n        PNFTToken[] memory nftAssets = accountNFTAssets[account];\\r\\n\\r\\n        for (uint i = 0; i < nftAssets.length; i++) {\\r\\n            PNFTToken nftAsset = nftAssets[i];\\r\\n\\r\\n            // Read the balances from the pToken\\r\\n            vars.pTokenBalance = nftAsset.balanceOf(account);\\r\\n            vars.collateralFactor = Exp({mantissa : markets[address(nftAsset)].collateralFactorMantissa});\\r\\n\\r\\n            // For each tokenId in nftAsset\\r\\n            for (uint j = 0; j < vars.pTokenBalance; j++) {\\r\\n                uint256 tokenId = nftAsset.tokenOfOwnerByIndex(account, j);\\r\\n\\r\\n                // Get the normalized price of the tokenId\\r\\n                vars.oraclePriceMantissa = PriceOracleInterface(oracle).getUnderlyingNFTPrice(nftAsset, tokenId);\\r\\n                if (vars.oraclePriceMantissa == 0) {\\r\\n                    return Error.PRICE_ERROR;\\r\\n                }\\r\\n                vars.oraclePrice = Exp({mantissa : vars.oraclePriceMantissa});\\r\\n\\r\\n                // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\r\\n                vars.tokensToDenom = mul_(mul_(vars.collateralFactor, Exp({mantissa : 1e36})), vars.oraclePrice);\\r\\n\\r\\n                // sumCollateral += tokensToDenom\\r\\n                vars.sumCollateral = add_(truncate(vars.tokensToDenom), vars.sumCollateral);\\r\\n\\r\\n                // Calculate effects of interacting with pTokenModify tokenId\\r\\n                if (redeemTokenId == tokenId && address(nftAsset) == pTokenModify) {\\r\\n                    require(PNFTToken(pTokenModify).isPNFTToken());\\r\\n\\r\\n                    // redeem effect\\r\\n                    // sumBorrowPlusEffects += tokensToDenom\\r\\n                    vars.sumBorrowPlusEffects = add_(truncate(vars.tokensToDenom), vars.sumBorrowPlusEffects);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return Error.NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /*** Policy Hooks, should not be marked as pure, view ***/\\r\\n\\r\\n    function redeemNFTAllowed(address pNFTToken, address redeemer, uint tokenId) external returns (uint) {\\r\\n        tokenId; // Shh - currently unused\\r\\n        require(PNFTToken(pNFTToken).isPNFTToken());\\r\\n\\r\\n        uint allowed = redeemNFTAllowedInternal(pNFTToken, redeemer);\\r\\n        if (allowed != uint(Error.NO_ERROR)) {\\r\\n            return allowed;\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pNFTToken);\\r\\n        distributeSupplierPBX(pNFTToken, redeemer);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function redeemNFTAllowedInternal(address pNFTToken, address redeemer) internal view returns (uint) {\\r\\n        require(PNFTToken(pNFTToken).isPNFTToken());\\r\\n\\r\\n        if (!markets[pNFTToken].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        // If the redeemer is not 'in' the market, then we can bypass the liquidity check\\r\\n        if (!markets[pNFTToken].accountMembership[redeemer]) {\\r\\n            return uint(Error.NO_ERROR);\\r\\n        }\\r\\n\\r\\n        // Otherwise, perform a hypothetical liquidity check to guard against shortfall\\r\\n        // (uint err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, pNFTToken, 0, 0, tokenId);\\r\\n        // if (err != uint(Error.NO_ERROR)) {\\r\\n        //     return uint(err);\\r\\n        // }\\r\\n        // if (shortfall > 0) {\\r\\n        //     return uint(Error.INSUFFICIENT_LIQUIDITY);\\r\\n        // }\\r\\n\\r\\n        if (hasAnyBorrow(redeemer)) {\\r\\n            return uint(Error.NONZERO_BORROW_BALANCE);\\r\\n        }\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function hasAnyBorrow(address account) internal view returns (bool) {\\r\\n        // For each asset the account is in\\r\\n        PToken[] memory assets = accountAssets[account];\\r\\n\\r\\n        for (uint i = 0; i < assets.length; i++) {\\r\\n            // Read the borrow balance from the pToken\\r\\n            (, uint borrowBalance, ) = assets[i].getAccountSnapshot(account);\\r\\n\\r\\n            if (borrowBalance > 0) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function transferNFTAllowed(address pNFTToken, address src, address dst, uint tokenId) external returns (uint) {\\r\\n        tokenId; // Shh - currently unused\\r\\n        require(PNFTToken(pNFTToken).isPNFTToken());\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!transferGuardianPausedGlobal, \\\"transfer is paused\\\");\\r\\n\\r\\n        // Currently the only consideration is whether or not the src is allowed to redeem this token\\r\\n        uint allowed = redeemNFTAllowedInternal(pNFTToken, src);\\r\\n        if (allowed != uint(Error.NO_ERROR)) {\\r\\n            return allowed;\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pNFTToken);\\r\\n        distributeSupplierPBX(pNFTToken, src);\\r\\n        distributeSupplierPBX(pNFTToken, dst);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function mintNFTAllowed(address pNFTToken, address minter, uint tokenId) external returns (uint) {\\r\\n        require(PNFTToken(pNFTToken).isPNFTToken());\\r\\n        require((NFTXioMarketplaceZapAddress != address(0) && PNFTToken(pNFTToken).NFTXioVaultId() >= 0) ||                   // NFTXio liquidation\\r\\n                (SudoswapPairRouterAddress != address(0) && PNFTToken(pNFTToken).SudoswapLSSVMPairAddress() != address(0)) || // sudoswap liquidation\\r\\n                (NFTCollateralSeizeLiquidationFactorMantissa > 0), \\\"NFT liquidation not configured\\\");                         // liquidator seize liquidation\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!mintGuardianPaused[pNFTToken] && !mintGuardianPausedGlobal, \\\"mint is paused\\\");\\r\\n\\r\\n        minter; // Shh - currently unused\\r\\n\\r\\n        if (!markets[pNFTToken].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        if (PriceOracleInterface(oracle).getUnderlyingNFTPrice(PNFTToken(pNFTToken), tokenId) == 0) {\\r\\n            return uint(Error.PRICE_ERROR);\\r\\n        }\\r\\n\\r\\n        if (NFTModuleClosedBeta && !NFTModuleWhitelistedUsers[minter]) {\\r\\n            return uint(Error.NFT_USER_NOT_ALLOWED);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pNFTToken);\\r\\n        distributeSupplierPBX(pNFTToken, minter);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function liquidateNFTCollateralAllowed(address pNFTTokenCollateral, address liquidator, address borrower, uint tokenId, address NFTLiquidationExchangePToken) external returns (uint) {\\r\\n        require(PNFTToken(pNFTTokenCollateral).isPNFTToken());\\r\\n        require(NFTLiquidationExchangePToken != address(0), \\\"invalid argument\\\");\\r\\n        require(PToken(NFTLiquidationExchangePToken).isPToken());\\r\\n\\r\\n        require((NFTXioMarketplaceZapAddress != address(0) && PNFTToken(pNFTTokenCollateral).NFTXioVaultId() >= 0) || // NFTio liquidation\\r\\n                (SudoswapPairRouterAddress != address(0) && PNFTToken(pNFTTokenCollateral).SudoswapLSSVMPairAddress() != address(0)) || // sudoswap liquidation\\r\\n                (NFTCollateralSeizeLiquidationFactorMantissa > 0), \\\"NFT liquidation not configured\\\"); // liquidator seize liquidation\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!seizeGuardianPausedGlobal, \\\"seize is paused\\\");\\r\\n\\r\\n        tokenId; // Shh - currently unused\\r\\n\\r\\n        if (!markets[NFTLiquidationExchangePToken].isListed) { // NFT TODO require?\\r\\n            return uint(Error.REJECTION);\\r\\n        }\\r\\n\\r\\n        if (!isNFTLiquidationExchangePToken[NFTLiquidationExchangePToken]) {\\r\\n            return uint(Error.REJECTION);\\r\\n        }\\r\\n\\r\\n        if (!markets[pNFTTokenCollateral].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        if (!markets[pNFTTokenCollateral].accountMembership[borrower]) {\\r\\n            return uint(Error.MARKET_NOT_ENTERED);\\r\\n        }\\r\\n\\r\\n        if (NFTModuleClosedBeta && !NFTModuleWhitelistedUsers[liquidator]) {\\r\\n            return uint(Error.NFT_USER_NOT_ALLOWED);\\r\\n        }\\r\\n\\r\\n        // First, check if borrower is liquidatable\\r\\n        (uint err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, address(0), 0, 0, 0);\\r\\n        if (err != uint(Error.NO_ERROR)) {\\r\\n            return uint(err);\\r\\n        }\\r\\n\\r\\n        if (shortfall == 0) {\\r\\n            return uint(Error.INSUFFICIENT_SHORTFALL);\\r\\n        }\\r\\n\\r\\n        if (PNFTToken(pNFTTokenCollateral).ownerOf(tokenId) != borrower) { // double-check that borrower is the owner of tokenId\\r\\n            return uint(Error.REJECTION);\\r\\n        }\\r\\n\\r\\n        // If borrower is liquidatable, we can add NFTLiquidationExchangePToken to his collateral\\r\\n        require(addToMarketInternal(PToken(NFTLiquidationExchangePToken), borrower) == Error.NO_ERROR, \\\"sellNFTAllowed addToMarketInternal failed\\\");\\r\\n\\r\\n        // No revert failures beyond this point!\\r\\n\\r\\n        /* The borrower must have shortfall in order to be liquidatable\\r\\n         * Check again after adding NFTLiquidationExchangePToken to borrower's collateral\\r\\n         */\\r\\n        (err, , shortfall) = getHypotheticalAccountLiquidityInternal(borrower, address(0), 0, 0, 0);\\r\\n        if (err != uint(Error.NO_ERROR)) {\\r\\n            return uint(err);\\r\\n        }\\r\\n        if (shortfall == 0) {\\r\\n            return uint(Error.INSUFFICIENT_SHORTFALL);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pNFTTokenCollateral);\\r\\n        distributeSupplierPBX(pNFTTokenCollateral, borrower);\\r\\n        distributeSupplierPBX(pNFTTokenCollateral, liquidator);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerNoNFTPart1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\nimport \\\"./ComptrollerCommonImpl.sol\\\";\\r\\nimport \\\"../PriceOracle/PriceOracleInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus Comptroller Part1 Contract with no NFT functionalities except common storage, to make no-NFT version easily upgradable to NFT one\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract ComptrollerNoNFTPart1 is ComptrollerNoNFTPart1Interface, ComptrollerNoNFTCommonImpl {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the assets an account has entered\\r\\n     * @param account The address of the account to pull assets for\\r\\n     * @return A dynamic list with the assets the account has entered\\r\\n     */\\r\\n    function getAssetsIn(address account) external view returns (PToken[] memory) {\\r\\n        return accountAssets[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether the given account is entered in the given asset\\r\\n     * @param account The address of the account to check\\r\\n     * @param pToken The pToken to check\\r\\n     * @return True if the account is in the asset, otherwise false.\\r\\n     */\\r\\n    function checkMembership(address account, address pToken) external view returns (bool) {\\r\\n        return markets[pToken].accountMembership[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return all of the markets\\r\\n     * @dev The automatic getter may be used to access an individual market.\\r\\n     * @return The list of market addresses\\r\\n     */\\r\\n    function getAllMarkets() external view returns (PToken[] memory) {\\r\\n        return allMarkets;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns deposit, borrow balance for a given account\\r\\n     * @param account The address of the account to check\\r\\n     * @return (deposit value, 0, borrow value)\\r\\n     */\\r\\n    function getDepositBorrowValues(address account) external view returns (uint, uint, uint) {\\r\\n        (uint standardAssetsSumDeposit, uint sumBorrowPlusEffects) = getStandardAssetsDepositBorrowValuesInternal(account);\\r\\n        return (standardAssetsSumDeposit, 0, sumBorrowPlusEffects);\\r\\n    }\\r\\n\\r\\n    function getStandardAssetsDepositBorrowValuesInternal(address account) internal view returns (uint, uint) {\\r\\n        uint sumDeposit = 0;\\r\\n        uint sumBorrowPlusEffects = 0;\\r\\n\\r\\n        // For every supported market (no matter whether user is in (enter market) or not)\\r\\n        PToken[] memory assets = allMarkets;\\r\\n        for (uint i = 0; i < assets.length; i++) {\\r\\n            PToken asset = assets[i];\\r\\n\\r\\n            // Read the balances and exchange rate from the pToken\\r\\n            (uint pTokenBalance, uint borrowBalance, uint exchangeRateMantissa) = asset.getAccountSnapshot(account);\\r\\n            Exp memory exchangeRate = Exp({mantissa : exchangeRateMantissa});\\r\\n\\r\\n            // Get the normalized price of the asset\\r\\n            uint oraclePriceMantissa = PriceOracleNoNFTInterface(oracle).getUnderlyingPrice(asset);\\r\\n            require(oraclePriceMantissa > 0, \\\"Error.PRICE_ERROR\\\");\\r\\n\\r\\n            Exp memory oraclePrice = Exp({mantissa : oraclePriceMantissa});\\r\\n\\r\\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\r\\n            Exp memory tokensToDenom = mul_(oraclePrice, exchangeRate);\\r\\n\\r\\n            // sumDeposit += tokensToDenom * pTokenBalance\\r\\n            sumDeposit = mul_ScalarTruncateAddUInt(tokensToDenom, pTokenBalance, sumDeposit);\\r\\n\\r\\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\\r\\n            sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrowPlusEffects);\\r\\n        }\\r\\n\\r\\n        return (sumDeposit, sumBorrowPlusEffects);\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    /**\\r\\n      * @notice Sets a new price oracle for the comptroller\\r\\n      * @dev Admin function to set a new price oracle\\r\\n      */\\r\\n    function _setPriceOracle(address newOracle) external {\\r\\n        onlyAdmin();\\r\\n        require(PriceOracleNoNFTInterface(newOracle).isPriceOracle());\\r\\n\\r\\n        emit NewPriceOracle(oracle, newOracle);\\r\\n        oracle = newOracle;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets the closeFactor used when liquidating borrows\\r\\n      * @dev Admin function to set closeFactor\\r\\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\\r\\n      */\\r\\n    function _setCloseFactor(uint newCloseFactorMantissa) external {\\r\\n        onlyAdmin();\\r\\n        require(newCloseFactorMantissa >= closeFactorMinMantissa && newCloseFactorMantissa <= closeFactorMaxMantissa, \\\"invalid argument\\\");\\r\\n\\r\\n        emit NewCloseFactor(closeFactorMantissa, newCloseFactorMantissa);\\r\\n        closeFactorMantissa = newCloseFactorMantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets the collateralFactor for a market\\r\\n      * @dev Admin function to set per-market collateralFactor\\r\\n      * @param pToken The market to set the factor on\\r\\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\r\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\r\\n      */\\r\\n    function _setCollateralFactor(PToken pToken, uint newCollateralFactorMantissa) external returns (uint) {\\r\\n        require(newCollateralFactorMantissa <= 10 ** 18, \\\"invalid argument\\\");\\r\\n        require(pToken.isPToken());\\r\\n\\r\\n        // If collateral factor != 0, fail if price == 0\\r\\n        if (newCollateralFactorMantissa != 0 && PriceOracleNoNFTInterface(oracle).getUnderlyingPrice(pToken) == 0) {\\r\\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\\r\\n        }\\r\\n\\r\\n        return _setCollateralFactorInternal(address(pToken), newCollateralFactorMantissa);\\r\\n    }\\r\\n\\r\\n    function _setCollateralFactorInternal(address pToken, uint newCollateralFactorMantissa) internal returns (uint) {\\r\\n        onlyAdmin();\\r\\n\\r\\n        // Verify market is listed\\r\\n        Market storage market = markets[pToken];\\r\\n        if (!market.isListed) {\\r\\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\\r\\n        }\\r\\n\\r\\n        Exp memory newCollateralFactorExp = Exp({mantissa : newCollateralFactorMantissa});\\r\\n\\r\\n        // Check collateral factor <= 0.9\\r\\n        Exp memory highLimit = Exp({mantissa : collateralFactorMaxMantissa});\\r\\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\\r\\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\\r\\n        }\\r\\n\\r\\n        emit NewCollateralFactor(pToken, market.collateralFactorMantissa, newCollateralFactorMantissa);\\r\\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets liquidationIncentive\\r\\n      * @dev Admin function to set liquidationIncentive\\r\\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\r\\n      */\\r\\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external {\\r\\n        onlyAdmin();\\r\\n        require(newLiquidationIncentiveMantissa >= 10 ** 18, \\\"invalid argument\\\");\\r\\n\\r\\n        emit NewLiquidationIncentive(liquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\r\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Add the market to the markets mapping and set it as listed\\r\\n      * @dev Admin function to set isListed and add support for the market\\r\\n      * @param pToken The address of the market (token) to list\\r\\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\\r\\n      */\\r\\n    function _supportMarket(PToken pToken) external returns (uint) {\\r\\n        require(pToken.isPToken());\\r\\n\\r\\n        uint err = _supportMarketInternal(address(pToken));\\r\\n        if (err != uint(Error.NO_ERROR)) return err;\\r\\n\\r\\n        for (uint i = 0; i < allMarkets.length; i++) {\\r\\n            require(allMarkets[i] != pToken, \\\"market already added\\\");\\r\\n        }\\r\\n\\r\\n        allMarkets.push(pToken);\\r\\n\\r\\n        _initializeMarket(address(pToken));\\r\\n        emit MarketListed(address(pToken), 0, address(0));\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function _supportMarketInternal(address pToken) internal returns (uint) {\\r\\n        onlyAdmin();\\r\\n\\r\\n        if (markets[pToken].isListed) {\\r\\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\\r\\n        }\\r\\n\\r\\n        markets[pToken] = Market({isListed : true, collateralFactorMantissa : 0});\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function _initializeMarket(address pToken) internal {\\r\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\r\\n\\r\\n        PBXMarketState storage supplyState = PBXSupplyState[pToken];\\r\\n        PBXMarketState storage borrowState = PBXBorrowState[pToken];\\r\\n\\r\\n        // Update market state indices\\r\\n        if (supplyState.index == 0) {\\r\\n            // Initialize supply state index with default value\\r\\n            supplyState.index = PBXInitialIndex;\\r\\n        }\\r\\n\\r\\n        if (borrowState.index == 0) {\\r\\n            // Initialize borrow state index with default value\\r\\n            borrowState.index = PBXInitialIndex;\\r\\n        }\\r\\n\\r\\n        // Update market state block numbers\\r\\n        supplyState.block = borrowState.block = blockNumber;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Set the given borrow caps for the given pToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\r\\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\\r\\n      * @param pTokens The addresses of the markets (tokens) to change the borrow caps for\\r\\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\\r\\n      */\\r\\n    function _setMarketBorrowCaps(PToken[] calldata pTokens, uint[] calldata newBorrowCaps) external {\\r\\n    \\trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \\\"only admin or borrow cap guardian can set borrow caps\\\");\\r\\n\\r\\n        uint numMarkets = pTokens.length;\\r\\n        uint numBorrowCaps = newBorrowCaps.length;\\r\\n\\r\\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \\\"invalid input\\\");\\r\\n\\r\\n        for (uint i = 0; i < numMarkets; i++) {\\r\\n            require(pTokens[i].isPToken());\\r\\n            borrowCaps[address(pTokens[i])] = newBorrowCaps[i];\\r\\n            emit NewBorrowCap(pTokens[i], newBorrowCaps[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to change the Borrow Cap Guardian\\r\\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\\r\\n     */\\r\\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\\r\\n        onlyAdmin();\\r\\n\\r\\n        emit NewBorrowCapGuardian(borrowCapGuardian, newBorrowCapGuardian);\\r\\n        borrowCapGuardian = newBorrowCapGuardian;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to change the Pause Guardian\\r\\n     * @param newPauseGuardian The address of the new Pause Guardian\\r\\n     */\\r\\n    function _setPauseGuardian(address newPauseGuardian) external {\\r\\n        onlyAdmin();\\r\\n        \\r\\n        emit NewPauseGuardian(pauseGuardian, newPauseGuardian);\\r\\n        pauseGuardian = newPauseGuardian;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to pause / unpause the token mint feature for all markets\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setMintPausedGlobal(bool state) public returns (bool) {\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        mintGuardianPausedGlobal = state;\\r\\n        emit ActionPaused(address(0), \\\"Mint\\\", state);\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to pause / unpause the token mint feature for a given market\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @param pToken the market to pause / unpause\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setMintPaused(address pToken, bool state) external returns (bool) {\\r\\n        require(markets[pToken].isListed, \\\"cannot pause a market that is not listed\\\");\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        mintGuardianPaused[pToken] = state;\\r\\n        emit ActionPaused(pToken, \\\"Mint\\\", state);\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to pause / unpause the token borrow feature for a given market\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @param pToken the market to pause / unpause\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setBorrowPaused(address pToken, bool state) external returns (bool) {\\r\\n        require(markets[pToken].isListed, \\\"cannot pause a market that is not listed\\\");\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        borrowGuardianPaused[pToken] = state;\\r\\n        emit ActionPaused(pToken, \\\"Borrow\\\", state);\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to pause / unpause the token borrow feature for all markets\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setBorrowPausedGlobal(bool state) public returns (bool) {\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        borrowGuardianPausedGlobal = state;\\r\\n        emit ActionPaused(address(0), \\\"Borrow\\\", state);\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to pause / unpause the token transfer feature for all markets\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setTransferPaused(bool state) public returns (bool) {\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        transferGuardianPausedGlobal = state;\\r\\n        emit ActionPaused(address(0), \\\"Transfer\\\", state);\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to pause / unpause the token liquidation feature for all markets\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setSeizePaused(bool state) public returns (bool) {\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        seizeGuardianPausedGlobal = state;\\r\\n        emit ActionPaused(address(0), \\\"Seize\\\", state);\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Emergency admin function to pause / unpause all the operations in one tx\\r\\n     * @param state true if paused, false if unpaused\\r\\n     * @return new state\\r\\n     */\\r\\n    function _setAllPausedGlobal(bool state) external returns (bool) {\\r\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\r\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\r\\n\\r\\n        _setMintPausedGlobal(state);\\r\\n        _setBorrowPausedGlobal(state);\\r\\n        _setTransferPaused(state);\\r\\n        _setSeizePaused(state);\\r\\n\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to set the PBX token. Can be set only once.\\r\\n     * @param newPBXTokenAddress new PBX token address\\r\\n     */\\r\\n    function _setPBXToken(address newPBXTokenAddress) external {\\r\\n        onlyAdmin();\\r\\n        require(newPBXTokenAddress != address(0), \\\"invalid argument\\\");\\r\\n        require(PBXToken == address(0), \\\"PBXToken already set\\\");\\r\\n\\r\\n        emit NewPBXToken(PBXToken, newPBXTokenAddress);\\r\\n        PBXToken = newPBXTokenAddress;\\r\\n    }\\r\\n\\r\\n    /*** Policy Hooks, should not be marked as pure, view ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Validates mint and reverts on rejection. May emit logs. Now empty, reserved for potential future use.\\r\\n     * @param pToken Asset being minted\\r\\n     * @param minter The address minting the tokens\\r\\n     * @param actualMintAmount The amount of the underlying asset being minted\\r\\n     * @param mintTokens The number of tokens being minted\\r\\n     */\\r\\n    function mintVerify(address pToken, address minter, uint actualMintAmount, uint mintTokens) external { }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates redeem and reverts on rejection. May emit logs.\\r\\n     * @param pToken Asset being redeemed\\r\\n     * @param redeemer The address redeeming the tokens\\r\\n     * @param redeemAmount The amount of the underlying asset being redeemed\\r\\n     * @param redeemTokens The number of tokens being redeemed\\r\\n     */\\r\\n    function redeemVerify(address pToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\\r\\n        // Shh - currently unused\\r\\n        pToken;\\r\\n        redeemer;\\r\\n\\r\\n        // Require tokens is zero or amount is also zero\\r\\n        require(!(redeemTokens == 0 && redeemAmount > 0), \\\"redeemTokens zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates borrow and reverts on rejection. May emit logs. Now empty, reserved for potential future use.\\r\\n     * @param pToken Asset whose underlying is being borrowed\\r\\n     * @param borrower The address borrowing the underlying\\r\\n     * @param borrowAmount The amount of the underlying asset requested to borrow\\r\\n     */\\r\\n    function borrowVerify(address pToken, address borrower, uint borrowAmount) external { }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs. Now empty, reserved for potential future use.\\r\\n     * @param pToken Asset being repaid\\r\\n     * @param payer The address repaying the borrow\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param actualRepayAmount The amount of underlying being repaid\\r\\n     */\\r\\n    function repayBorrowVerify(address pToken, address payer, address borrower, uint actualRepayAmount, uint borrowerIndex) external { }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs. Now empty, reserved for potential future use.\\r\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param actualRepayAmount The amount of underlying being repaid\\r\\n     */\\r\\n    function liquidateBorrowVerify(address pTokenBorrowed, address pTokenCollateral, address liquidator, address borrower, uint actualRepayAmount, uint seizeTokens) external { }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates seize and reverts on rejection. May emit logs. Now empty, reserved for potential future use.\\r\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param seizeTokens The number of collateral tokens to seize\\r\\n     */\\r\\n    function seizeVerify(address pTokenCollateral, address pTokenBorrowed, address liquidator, address borrower, uint seizeTokens) external { }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates transfer and reverts on rejection. May emit logs. Now empty, reserved for potential future use.\\r\\n     * @param pToken Asset being transferred\\r\\n     * @param src The account which sources the tokens\\r\\n     * @param dst The account which receives the tokens\\r\\n     * @param transferTokens The number of pTokens to transfer\\r\\n     */\\r\\n    function transferVerify(address pToken, address src, address dst, uint transferTokens) external { }\\r\\n\\r\\n    /*** PBX Distribution Admin ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Set PBX speed for a single contributor\\r\\n     * @param contributor The contributor whose PBX speed to update\\r\\n     * @param PBXSpeed New PBX speed for contributor\\r\\n     */\\r\\n    function _setContributorPBXSpeed(address contributor, uint PBXSpeed) external {\\r\\n        adminOrInitializing();\\r\\n\\r\\n        // note that PBX speed could be set to 0 to halt liquidity rewards for a contributor\\r\\n        updateContributorRewards(contributor);\\r\\n\\r\\n        if (PBXSpeed == 0) {\\r\\n            delete lastContributorBlock[contributor]; // release storage\\r\\n        } else {\\r\\n            lastContributorBlock[contributor] = getBlockNumber();\\r\\n        }\\r\\n\\r\\n        PBXContributorSpeeds[contributor] = PBXSpeed;\\r\\n        emit ContributorPBXSpeedUpdated(contributor, PBXSpeed);\\r\\n    }\\r\\n\\r\\n    /*** PBX Distribution ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate additional accrued PBX for a contributor since last accrual\\r\\n     * @param contributor The address to calculate contributor rewards for\\r\\n     */\\r\\n    function updateContributorRewards(address contributor) public {\\r\\n        uint PBXSpeed = PBXContributorSpeeds[contributor];\\r\\n        uint blockNumber = getBlockNumber();\\r\\n        uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\\r\\n\\r\\n        if (deltaBlocks > 0 && PBXSpeed > 0) {\\r\\n            uint newAccrued = mul_(deltaBlocks, PBXSpeed);\\r\\n            uint contributorAccrued = add_(PBXAccruedStored[contributor], newAccrued);\\r\\n\\r\\n            PBXAccruedStored[contributor] = contributorAccrued;\\r\\n            lastContributorBlock[contributor] = blockNumber;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Delegates execution to an part 2 implementation contract. It returns to the external caller whatever the implementation returns or forwards reverts.\\r\\n    function() external payable {\\r\\n        // delegate all other functions to part 2 implementation\\r\\n        (bool success,) = comptrollerPart2Implementation.delegatecall(msg.data);\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 {revert(free_mem_ptr, returndatasize)}\\r\\n            default {return (free_mem_ptr, returndatasize)}\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerNoNFTPart2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\nimport \\\"./ComptrollerCommonImpl.sol\\\";\\r\\nimport \\\"../PriceOracle/PriceOracleInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus Comptroller Part2 Contract with no NFT functionalities except common storage, to make no-NFT version easily upgradable to NFT one\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract ComptrollerNoNFTPart2 is ComptrollerNoNFTPart2Interface, ComptrollerNoNFTCommonImpl {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Add assets to be included in account liquidity calculation\\r\\n     * @param pTokens The list of addresses of the pToken markets to be enabled\\r\\n     * @return Success indicator for whether each corresponding market was entered\\r\\n     */\\r\\n    function enterMarkets(address[] calldata pTokens) external returns (uint[] memory) {\\r\\n        uint len = pTokens.length;\\r\\n\\r\\n        uint[] memory results = new uint[](len);\\r\\n        for (uint i = 0; i < len; i++) {\\r\\n            PToken pToken = PToken(pTokens[i]);\\r\\n            results[i] = uint(addToMarketInternal(pToken, msg.sender));\\r\\n        }\\r\\n\\r\\n        return results;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes asset from sender's account liquidity calculation\\r\\n     * @dev Sender must not have an outstanding borrow balance in the asset, or be providing necessary collateral for an outstanding borrow.\\r\\n     * @param pTokenAddress The address of the asset to be removed\\r\\n     * @return Whether or not the account successfully exited the market\\r\\n     */\\r\\n    function exitMarket(address pTokenAddress) external returns (uint) {\\r\\n        PToken pToken = PToken(pTokenAddress);\\r\\n        require(pToken.isPToken());\\r\\n\\r\\n        // Get sender tokensHeld and amountOwed underlying from the pToken\\r\\n        (uint tokensHeld, uint borrowBalance, ) = pToken.getAccountSnapshot(msg.sender);\\r\\n\\r\\n        // Fail if the sender has a borrow balance\\r\\n        if (borrowBalance != 0) {\\r\\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\\r\\n        }\\r\\n\\r\\n        // Fail if the sender is not permitted to redeem all of their tokens\\r\\n        uint allowed = redeemAllowedInternal(pTokenAddress, msg.sender, tokensHeld);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        Market storage marketToExit = markets[address(pToken)];\\r\\n\\r\\n        // Return true if the sender is not already \u00e2\u20ac\u02dcin\u00e2\u20ac\u2122 the market\\r\\n        if (!marketToExit.accountMembership[msg.sender]) {\\r\\n            return uint(Error.NO_ERROR);\\r\\n        }\\r\\n\\r\\n        // Set pToken account membership to false\\r\\n        delete marketToExit.accountMembership[msg.sender];\\r\\n\\r\\n        // Delete pToken from the account\u00e2\u20ac\u2122s list of assets\\r\\n        // load into memory for faster iteration\\r\\n        PToken[] memory userAssetList = accountAssets[msg.sender];\\r\\n        uint len = userAssetList.length;\\r\\n        uint assetIndex = len;\\r\\n        for (uint i = 0; i < len; i++) {\\r\\n            if (userAssetList[i] == pToken) {\\r\\n                assetIndex = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\r\\n        assert(assetIndex < len);\\r\\n\\r\\n        // copy last item in list to location of item to be removed, reduce length by 1\\r\\n        PToken[] storage storedList = accountAssets[msg.sender];\\r\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\r\\n        storedList.length--;\\r\\n\\r\\n        emit MarketExited(address(pToken), msg.sender);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\r\\n     * @param pToken The market to enter\\r\\n     * @param borrower The address of the account to modify\\r\\n     * @return Success indicator for whether the market was entered\\r\\n     */\\r\\n    function addToMarketInternal(PToken pToken, address borrower) internal returns (Error) {\\r\\n        require(pToken.isPToken());\\r\\n        Market storage marketToJoin = markets[address(pToken)];\\r\\n\\r\\n        if (!marketToJoin.isListed) { // market is not listed, cannot join\\r\\n            return Error.MARKET_NOT_LISTED;\\r\\n        }\\r\\n\\r\\n        if (marketToJoin.accountMembership[borrower]) { // already joined\\r\\n            return Error.NO_ERROR;\\r\\n        }\\r\\n\\r\\n        // survived the gauntlet, add to list\\r\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\r\\n        //  this avoids having to iterate through the list for the most common use cases\\r\\n        //  that is, only when we need to perform liquidity checks\\r\\n        //  and not whenever we want to check if an account is in a particular market\\r\\n        marketToJoin.accountMembership[borrower] = true;\\r\\n        accountAssets[borrower].push(pToken);\\r\\n\\r\\n        emit MarketEntered(address(pToken), borrower);\\r\\n        return Error.NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    /**\\r\\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\\r\\n     *  Note that `pTokenBalance` is the number of pTokens the account owns in the market,\\r\\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\\r\\n     */\\r\\n    struct AccountLiquidityLocalVars {\\r\\n        uint sumCollateral;\\r\\n        uint sumBorrowPlusEffects;\\r\\n        uint pTokenBalance;\\r\\n        uint borrowBalance;\\r\\n        uint exchangeRateMantissa;\\r\\n        uint oraclePriceMantissa;\\r\\n        Exp collateralFactor;\\r\\n        Exp exchangeRate;\\r\\n        Exp oraclePrice;\\r\\n        Exp tokensToDenom;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine the current account liquidity wrt collateral requirements\\r\\n     * @return (possible error code (semi-opaque),\\r\\n                account liquidity in excess of collateral requirements,\\r\\n     *          account shortfall below collateral requirements)\\r\\n     */\\r\\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint) {\\r\\n        return getHypotheticalAccountLiquidityInternal(account, address(0), 0, 0, 0);\\r\\n    }\\r\\n\\r\\n    /// @return (standard assets collateral worth sum including collateral factor, 0, borrow value)\\r\\n    function getCollateralBorrowValues(address account) external view returns (uint, uint, uint) {\\r\\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\r\\n\\r\\n        Error err = getHypotheticalAccountLiquidityInternalImpl(account, address(0), 0, 0, vars);\\r\\n        require(err == Error.NO_ERROR, \\\"getHypotheticalAccountLiquidity error\\\");\\r\\n\\r\\n        return (vars.sumCollateral, 0, vars.sumBorrowPlusEffects);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\r\\n     * @param pTokenModify The market to hypothetically redeem/borrow in\\r\\n     * @param account The account to determine liquidity for\\r\\n     * @param redeemTokens The number of tokens to hypothetically redeem (if PToken)\\r\\n     * @param borrowAmount The amount of underlying to hypothetically borrow (if PToken)\\r\\n     * @param redeemTokenId The token ID to hypothetically redeem (if PNFTToken)\\r\\n     * @return (possible error code (semi-opaque),\\r\\n                hypothetical account liquidity in excess of collateral requirements,\\r\\n     *          hypothetical account shortfall below collateral requirements)\\r\\n     */\\r\\n    function getHypotheticalAccountLiquidity(address account, address pTokenModify, uint redeemTokens, uint borrowAmount, uint redeemTokenId) external view returns (uint, uint, uint) {\\r\\n        return getHypotheticalAccountLiquidityInternal(account, pTokenModify, redeemTokens, borrowAmount, redeemTokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\r\\n     * @param pTokenModify The market to hypothetically redeem/borrow in\\r\\n     * @param account The account to determine liquidity for\\r\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\r\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\r\\n     * @dev Note that we calculate the exchangeRateStored for each collateral pToken using stored data, without calculating accumulated interest.\\r\\n     * @return (possible error code,\\r\\n                hypothetical account liquidity in excess of collateral requirements,\\r\\n     *          hypothetical account shortfall below collateral requirements)\\r\\n     */\\r\\n    function getHypotheticalAccountLiquidityInternal(address account, address pTokenModify, uint redeemTokens, uint borrowAmount, uint redeemTokenId) internal view returns (uint, uint, uint) {\\r\\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\r\\n\\r\\n        Error err = getHypotheticalAccountLiquidityInternalImpl(account, pTokenModify, redeemTokens, borrowAmount, vars);\\r\\n        if (err != Error.NO_ERROR) return (uint(err), 0, 0);\\r\\n\\r\\n        // These are safe, as the underflow condition is checked first\\r\\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\\r\\n            return (uint(Error.NO_ERROR), sub_(vars.sumCollateral, vars.sumBorrowPlusEffects), 0);\\r\\n        } else {\\r\\n            return (uint(Error.NO_ERROR), 0, sub_(vars.sumBorrowPlusEffects, vars.sumCollateral));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev returns liquidity for standard assets (by vars param)\\r\\n    function getHypotheticalAccountLiquidityInternalImpl(address account, address pTokenModify, uint redeemTokens, uint borrowAmount, AccountLiquidityLocalVars memory vars) internal view returns (Error) {\\r\\n        // For each asset the account is in\\r\\n        PToken[] memory assets = accountAssets[account];\\r\\n        for (uint i = 0; i < assets.length; i++) {\\r\\n            PToken asset = assets[i];\\r\\n\\r\\n            // Read the balances and exchange rate from the pToken\\r\\n            (vars.pTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\\r\\n            vars.collateralFactor = Exp({mantissa : markets[address(asset)].collateralFactorMantissa});\\r\\n            vars.exchangeRate = Exp({mantissa : vars.exchangeRateMantissa});\\r\\n\\r\\n            // Get the normalized price of the asset\\r\\n            vars.oraclePriceMantissa = PriceOracleNoNFTInterface(oracle).getUnderlyingPrice(asset);\\r\\n            if (vars.oraclePriceMantissa == 0) {\\r\\n                return Error.PRICE_ERROR;\\r\\n            }\\r\\n            vars.oraclePrice = Exp({mantissa : vars.oraclePriceMantissa});\\r\\n\\r\\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\r\\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\\r\\n\\r\\n            // sumCollateral += tokensToDenom * pTokenBalance\\r\\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.pTokenBalance, vars.sumCollateral);\\r\\n\\r\\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\\r\\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\\r\\n\\r\\n            // Calculate effects of interacting with pTokenModify\\r\\n            if (address(asset) == pTokenModify) {\\r\\n                // redeem effect\\r\\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\\r\\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\\r\\n\\r\\n                // borrow effect\\r\\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\\r\\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return Error.NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\r\\n     * @dev Used in liquidation (called in pToken.liquidateBorrowFresh)\\r\\n     * @param pTokenBorrowed The address of the borrowed pToken\\r\\n     * @param pTokenCollateral The address of the collateral pToken\\r\\n     * @param actualRepayAmount The amount of pTokenBorrowed underlying to convert into pTokenCollateral tokens\\r\\n     * @return (errorCode, number of pTokenCollateral tokens to be seized in a liquidation)\\r\\n     */\\r\\n    function liquidateCalculateSeizeTokens(address pTokenBorrowed, address pTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\\r\\n        require(PToken(pTokenBorrowed).isPToken());\\r\\n        require(PToken(pTokenCollateral).isPToken());\\r\\n\\r\\n        // Read oracle prices for borrowed and collateral markets\\r\\n        uint priceBorrowedMantissa = PriceOracleNoNFTInterface(oracle).getUnderlyingPrice(PToken(pTokenBorrowed));\\r\\n        uint priceCollateralMantissa = PriceOracleNoNFTInterface(oracle).getUnderlyingPrice(PToken(pTokenCollateral));\\r\\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\\r\\n            return (uint(Error.PRICE_ERROR), 0);\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\\r\\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\r\\n         *  seizeTokens = seizeAmount / exchangeRate\\r\\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\r\\n         */\\r\\n        uint exchangeRateMantissa = PToken(pTokenCollateral).exchangeRateStored();\\r\\n\\r\\n        // Note: reverts on error\\r\\n        Exp memory numerator = mul_(Exp({mantissa : liquidationIncentiveMantissa}), Exp({mantissa : priceBorrowedMantissa}));\\r\\n        Exp memory denominator = mul_(Exp({mantissa : priceCollateralMantissa}), Exp({mantissa : exchangeRateMantissa}));\\r\\n        Exp memory ratio = div_(numerator, denominator);\\r\\n        uint seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\r\\n\\r\\n        return (uint(Error.NO_ERROR), seizeTokens);\\r\\n    }\\r\\n\\r\\n    /*** Policy Hooks, should not be marked as pure, view ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the liquidation should be allowed to occur\\r\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param repayAmount The amount of underlying being repaid\\r\\n     */\\r\\n    function liquidateBorrowAllowed(address pTokenBorrowed, address pTokenCollateral, address liquidator, address borrower, uint repayAmount) external returns (uint) {\\r\\n        require(PToken(pTokenBorrowed).isPToken());\\r\\n\\r\\n        liquidator; // Shh - currently unused\\r\\n\\r\\n        if (!markets[pTokenBorrowed].isListed || !markets[pTokenCollateral].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        // The borrower must have shortfall in order to be liquidatable\\r\\n        (uint err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, address(0), 0, 0, 0);\\r\\n        if (err != uint(Error.NO_ERROR)) {\\r\\n            return uint(err);\\r\\n        }\\r\\n        if (shortfall == 0) {\\r\\n            return uint(Error.INSUFFICIENT_SHORTFALL);\\r\\n        }\\r\\n\\r\\n        // The liquidator may not repay more than what is allowed by the closeFactor\\r\\n        uint borrowBalance = PToken(pTokenBorrowed).borrowBalanceStored(borrower);\\r\\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa : closeFactorMantissa}), borrowBalance);\\r\\n        if (repayAmount > maxClose) {\\r\\n            return uint(Error.TOO_MUCH_REPAY);\\r\\n        }\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\r\\n     * @param pToken The market to verify the redeem against\\r\\n     * @param redeemer The account which would redeem the tokens\\r\\n     * @param redeemTokens The number of pTokens to exchange for the underlying asset in the market\\r\\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\r\\n     */\\r\\n    function redeemAllowed(address pToken, address redeemer, uint redeemTokens) external returns (uint) {\\r\\n        require(PToken(pToken).isPToken());\\r\\n\\r\\n        uint allowed = redeemAllowedInternal(pToken, redeemer, redeemTokens);\\r\\n        if (allowed != uint(Error.NO_ERROR)) {\\r\\n            return allowed;\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pToken);\\r\\n        distributeSupplierPBX(pToken, redeemer);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\r\\n     * @param pToken The market to verify the borrow against\\r\\n     * @param borrower The account which would borrow the asset\\r\\n     * @param borrowAmount The amount of underlying the account would borrow\\r\\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\r\\n     */\\r\\n    function borrowAllowed(address pToken, address borrower, uint borrowAmount) external returns (uint) {\\r\\n        require(PToken(pToken).isPToken());\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!borrowGuardianPaused[pToken] && !borrowGuardianPausedGlobal, \\\"borrow is paused\\\");\\r\\n\\r\\n        if (!markets[pToken].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        if (!markets[pToken].accountMembership[borrower]) {\\r\\n            // only pTokens may call borrowAllowed if borrower not in market\\r\\n            require(msg.sender == pToken, \\\"sender must be pToken\\\");\\r\\n\\r\\n            // attempt to add borrower to the market\\r\\n            Error err = addToMarketInternal(PToken(msg.sender), borrower);\\r\\n            if (err != Error.NO_ERROR) {\\r\\n                return uint(err);\\r\\n            }\\r\\n\\r\\n            // it should be impossible to break the important invariant\\r\\n            assert(markets[pToken].accountMembership[borrower]);\\r\\n        }\\r\\n\\r\\n        if (PriceOracleNoNFTInterface(oracle).getUnderlyingPrice(PToken(pToken)) == 0) {\\r\\n            return uint(Error.PRICE_ERROR);\\r\\n        }\\r\\n\\r\\n        uint borrowCap = borrowCaps[pToken];\\r\\n        if (borrowCap != 0) { // Borrow cap of 0 corresponds to unlimited borrowing\\r\\n            uint totalBorrows = PToken(pToken).totalBorrows();\\r\\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\\r\\n            require(nextTotalBorrows < borrowCap, \\\"market borrow cap reached\\\");\\r\\n        }\\r\\n\\r\\n        (uint err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, pToken, 0, borrowAmount, 0);\\r\\n        if (err != uint(Error.NO_ERROR)) {\\r\\n            return uint(err);\\r\\n        }\\r\\n\\r\\n        if (shortfall > 0) {\\r\\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        Exp memory borrowIndex = Exp({mantissa : PToken(pToken).borrowIndex()});\\r\\n        updatePBXBorrowIndex(pToken, borrowIndex);\\r\\n        distributeBorrowerPBX(pToken, borrower, borrowIndex);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\r\\n     * @param pToken The market to verify the transfer against\\r\\n     * @param src The account which sources the tokens\\r\\n     * @param dst The account which receives the tokens\\r\\n     * @param transferTokens The number of pTokens to transfer\\r\\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\r\\n     */\\r\\n    function transferAllowed(address pToken, address src, address dst, uint transferTokens) external returns (uint) {\\r\\n        require(PToken(pToken).isPToken());\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!transferGuardianPausedGlobal, \\\"transfer is paused\\\");\\r\\n\\r\\n        // Currently the only consideration is whether or not the src is allowed to redeem this many tokens\\r\\n        uint allowed = redeemAllowedInternal(pToken, src, transferTokens);\\r\\n        if (allowed != uint(Error.NO_ERROR)) {\\r\\n            return allowed;\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pToken);\\r\\n        distributeSupplierPBX(pToken, src);\\r\\n        distributeSupplierPBX(pToken, dst);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\r\\n     * @param pToken The market to verify the mint against\\r\\n     * @param minter The account which would get the minted tokens\\r\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\r\\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\r\\n     */\\r\\n    function mintAllowed(address pToken, address minter, uint mintAmount) external returns (uint) {\\r\\n        require(PToken(pToken).isPToken());\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!mintGuardianPaused[pToken] && !mintGuardianPausedGlobal, \\\"mint is paused\\\");\\r\\n\\r\\n        // Shh - currently unused\\r\\n        minter;\\r\\n        mintAmount;\\r\\n\\r\\n        if (!markets[pToken].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pToken);\\r\\n        distributeSupplierPBX(pToken, minter);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\r\\n     * @param pToken The market to verify the repay against\\r\\n     * @param payer The account which would repay the asset\\r\\n     * @param borrower The account which would borrowed the asset\\r\\n     * @param repayAmount The amount of the underlying asset the account would repay\\r\\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\r\\n     */\\r\\n    function repayBorrowAllowed(address pToken, address payer, address borrower, uint repayAmount) external returns (uint) {\\r\\n        require(PToken(pToken).isPToken());\\r\\n\\r\\n        // Shh - currently unused\\r\\n        payer;\\r\\n        borrower;\\r\\n        repayAmount;\\r\\n\\r\\n        if (!markets[pToken].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        Exp memory borrowIndex = Exp({mantissa : PToken(pToken).borrowIndex()});\\r\\n        updatePBXBorrowIndex(pToken, borrowIndex);\\r\\n        distributeBorrowerPBX(pToken, borrower, borrowIndex);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the seizing of assets should be allowed to occur\\r\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param seizeTokens The number of collateral tokens to seize\\r\\n     */\\r\\n    function seizeAllowed(address pTokenCollateral, address pTokenBorrowed, address liquidator, address borrower, uint seizeTokens) external returns (uint) {\\r\\n        require(PToken(pTokenCollateral).isPToken());\\r\\n        require(PToken(pTokenBorrowed).isPToken());\\r\\n\\r\\n        // Pausing is a very serious situation - we revert to sound the alarms\\r\\n        require(!seizeGuardianPausedGlobal, \\\"seize is paused\\\");\\r\\n\\r\\n        seizeTokens; // Shh - currently unused\\r\\n\\r\\n        if (!markets[pTokenCollateral].isListed || !markets[pTokenBorrowed].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        if (PToken(pTokenCollateral).comptroller() != PToken(pTokenBorrowed).comptroller()) {\\r\\n            return uint(Error.COMPTROLLER_MISMATCH);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        updatePBXSupplyIndex(pTokenCollateral);\\r\\n        distributeSupplierPBX(pTokenCollateral, borrower);\\r\\n        distributeSupplierPBX(pTokenCollateral, liquidator);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market. Integral part of the redeemAllowed() function.\\r\\n     * @param pToken The market to verify the redeem against=\\r\\n     * @param redeemer The account which would redeem the tokens\\r\\n     * @param redeemTokens The number of pTokens to exchange for the underlying asset in the market\\r\\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\r\\n     */\\r\\n    function redeemAllowedInternal(address pToken, address redeemer, uint redeemTokens) internal view returns (uint) {\\r\\n        require(PToken(pToken).isPToken());\\r\\n\\r\\n        if (!markets[pToken].isListed) {\\r\\n            return uint(Error.MARKET_NOT_LISTED);\\r\\n        }\\r\\n\\r\\n        // If the redeemer is not 'in' the market, then we can bypass the liquidity check\\r\\n        if (markets[pToken].accountMembership[redeemer]) {\\r\\n            // Otherwise, perform a hypothetical liquidity check to guard against shortfall\\r\\n            (uint err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, pToken, redeemTokens, 0, 0);\\r\\n            if (err != uint(Error.NO_ERROR)) {\\r\\n                return uint(err);\\r\\n            }\\r\\n\\r\\n            if (shortfall > 0) {\\r\\n                return uint(Error.INSUFFICIENT_LIQUIDITY);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /*** PBX Distribution ***/\\r\\n\\r\\n    /**\\r\\n    * @notice Claim all the PBX accrued by holder in all markets\\r\\n    * @param holder The address to claim PBX for\\r\\n    */\\r\\n    function claimPBXReward(address holder) external {\\r\\n        return claimPBXSingle(holder, allMarkets);\\r\\n        // NFT TODO PBX reward for NFT markets?\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim all the PBX accrued by holder in the specified markets\\r\\n     * @param holder The address to claim PBX for\\r\\n     * @param pTokens The list of markets to claim PBX in\\r\\n     */\\r\\n    function claimPBXSingle(address holder, PToken[] memory pTokens) public {\\r\\n        address[] memory holders = new address[](1);\\r\\n        holders[0] = holder;\\r\\n        claimPBX(holders, pTokens, true, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim all PBX accrued by the holders\\r\\n     * @param holders The addresses to claim PBX for\\r\\n     * @param pTokens The list of markets to claim PBX in\\r\\n     * @param borrowers Whether or not to claim PBX earned by borrowing\\r\\n     * @param suppliers Whether or not to claim PBX earned by supplying\\r\\n     */\\r\\n    function claimPBX(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {\\r\\n        for (uint i = 0; i < pTokens.length; i++) {\\r\\n            PToken pToken = pTokens[i];\\r\\n            require(markets[address(pToken)].isListed, \\\"market must be listed\\\");\\r\\n\\r\\n            if (borrowers) {\\r\\n                Exp memory borrowIndex = Exp({mantissa: pToken.borrowIndex()});\\r\\n                updatePBXBorrowIndex(address(pToken), borrowIndex);\\r\\n                for (uint j = 0; j < holders.length; j++) {\\r\\n                    distributeBorrowerPBX(address(pToken), holders[j], borrowIndex);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (suppliers) {\\r\\n                updatePBXSupplyIndex(address(pToken));\\r\\n                for (uint j = 0; j < holders.length; j++) {\\r\\n                    distributeSupplierPBX(address(pToken), holders[j]);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (uint j = 0; j < holders.length; j++) {\\r\\n            PBXAccruedStored[holders[j]] = grantPBXInternal(holders[j], PBXAccruedStored[holders[j]]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The PBX accrued but not yet transferred to each user. Calculated live, for current block\\r\\n     * @param holder The addresses to calculate accrued PBX for\\r\\n     */\\r\\n    function PBXAccrued(address holder) public view returns (uint) {\\r\\n        uint result = 0;\\r\\n\\r\\n        for (uint i = 0; i < allMarkets.length; i++) {\\r\\n            PToken pToken = allMarkets[i];\\r\\n            require(markets[address(pToken)].isListed, \\\"market must be listed\\\");\\r\\n\\r\\n            Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});\\r\\n            PBXMarketState memory updatedBorrowSpeed = getUpdatedPBXBorrowIndex(address(pToken), borrowIndex);\\r\\n            result = add_(result, calculateTotalBorrowerPBXAccrued(address(pToken), holder, borrowIndex, updatedBorrowSpeed));\\r\\n\\r\\n            PBXMarketState memory updatedSupplySpeed = getUpdatedPBXSupplyIndex(address(pToken));\\r\\n            result = add_(result, calculateTotalSupplierPBXAccrued(address(pToken), holder, updatedSupplySpeed));\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer PBX to the user\\r\\n     * @dev Note: If there is not enough PBX, we do not perform the transfer all.\\r\\n     * @param user The address of the user to transfer PBX to\\r\\n     * @param amount The amount of PBX to (possibly) transfer\\r\\n     * @return The amount of PBX which was NOT transferred to the user\\r\\n     */\\r\\n    function grantPBXInternal(address user, uint amount) internal returns (uint) {\\r\\n        EIP20Interface PBX = EIP20Interface(PBXToken);\\r\\n        uint PBXRemaining = PBX.balanceOf(address(this));\\r\\n\\r\\n        if (amount > 0 && amount <= PBXRemaining) {\\r\\n            require(PBX.transfer(user, amount), \\\"transfer failed\\\");\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /*** PBX Distribution Admin ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Set PBX speed for a single market\\r\\n     * @param pToken The market whose PBX speed to update\\r\\n     * @param supplySpeed New supply-side PBX speed for market\\r\\n     * @param borrowSpeed New borrow-side PBX speed for market\\r\\n     */\\r\\n    function setPBXSpeedInternal(PToken pToken, uint supplySpeed, uint borrowSpeed) internal {\\r\\n        Market storage market = markets[address(pToken)];\\r\\n        require(market.isListed, \\\"market is not listed\\\");\\r\\n\\r\\n        if (PBXSupplySpeeds[address(pToken)] != supplySpeed) {\\r\\n            // Supply speed updated so let's update supply state to ensure that\\r\\n            //  1. PBX accrued properly for the old speed, and\\r\\n            //  2. PBX accrued at the new speed starts after this block.\\r\\n            updatePBXSupplyIndex(address(pToken));\\r\\n\\r\\n            // Update speed and emit event\\r\\n            PBXSupplySpeeds[address(pToken)] = supplySpeed;\\r\\n            emit PBXSupplySpeedUpdated(pToken, supplySpeed);\\r\\n        }\\r\\n\\r\\n        if (PBXBorrowSpeeds[address(pToken)] != borrowSpeed) {\\r\\n            // Borrow speed updated so let's update borrow state to ensure that\\r\\n            //  1. PBX accrued properly for the old speed, and\\r\\n            //  2. PBX accrued at the new speed starts after this block.\\r\\n            Exp memory borrowIndex = Exp({mantissa: pToken.borrowIndex()});\\r\\n            updatePBXBorrowIndex(address(pToken), borrowIndex);\\r\\n\\r\\n            // Update speed and emit event\\r\\n            PBXBorrowSpeeds[address(pToken)] = borrowSpeed;\\r\\n            emit PBXBorrowSpeedUpdated(pToken, borrowSpeed);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer PBX to the recipient\\r\\n     * @dev Note: If there is not enough PBX, we do not perform the transfer all.\\r\\n     * @param recipient The address of the recipient to transfer PBX to\\r\\n     * @param amount The amount of PBX to (possibly) transfer\\r\\n     */\\r\\n    function _grantPBX(address recipient, uint amount) external {\\r\\n        adminOrInitializing();\\r\\n\\r\\n        uint amountLeft = grantPBXInternal(recipient, amount);\\r\\n        require(amountLeft == 0, \\\"insufficient PBX for grant\\\");\\r\\n        emit PBXGranted(recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set PBX borrow and supply speeds for the specified markets.\\r\\n     * @param pTokens The market whose PBX speed to update\\r\\n     * @param supplySpeeds New supply-side PBX speed for the corresponding market.\\r\\n     * @param borrowSpeeds New borrow-side PBX speed for the corresponding market.\\r\\n     */\\r\\n    function _setPBXSpeeds(PToken[] calldata pTokens, uint[] calldata supplySpeeds, uint[] calldata borrowSpeeds) external {\\r\\n        adminOrInitializing();\\r\\n\\r\\n        uint numTokens = pTokens.length;\\r\\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \\\"invalid argument\\\");\\r\\n\\r\\n        for (uint i = 0; i < numTokens; ++i) {\\r\\n            setPBXSpeedInternal(pTokens[i], supplySpeeds[i], borrowSpeeds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue PBX to the market by updating the supply index\\r\\n     * @param pToken The market whose supply index to update\\r\\n     * @dev Index is a cumulative sum of the PBX per pToken accrued\\r\\n     */\\r\\n    function updatePBXSupplyIndex(address pToken) internal {\\r\\n        PBXSupplyState[pToken] = getUpdatedPBXSupplyIndex(pToken);\\r\\n    }\\r\\n\\r\\n    function getUpdatedPBXSupplyIndex(address pToken) internal view returns (PBXMarketState memory) {\\r\\n        PBXMarketState memory supplyState = PBXSupplyState[pToken];\\r\\n\\r\\n        uint supplySpeed = PBXSupplySpeeds[pToken];\\r\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\r\\n        uint deltaBlocks = sub_(uint(blockNumber), uint(supplyState.block));\\r\\n\\r\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\r\\n            uint totalSupply = PToken(pToken).totalSupply();\\r\\n            uint supplyTokens = totalSupply > 0 ? sub_(totalSupply, PToken(pToken).MINIMUM_LIQUIDITY()) : 0;\\r\\n            uint newPBXAccrued = mul_(deltaBlocks, supplySpeed);\\r\\n            Double memory ratio = supplyTokens > 0 ? fraction(newPBXAccrued, supplyTokens) : Double({mantissa : 0});\\r\\n            supplyState.index = safe224(add_(Double({mantissa : supplyState.index}), ratio).mantissa, \\\"new index exceeds 224 bits\\\");\\r\\n            supplyState.block = blockNumber;\\r\\n        } else if (deltaBlocks > 0) {\\r\\n            supplyState.block = blockNumber;\\r\\n        }\\r\\n\\r\\n        return supplyState;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate PBX accrued by a supplier and possibly transfer it to them\\r\\n     * @param pToken The market in which the supplier is interacting\\r\\n     * @param supplier The address of the supplier to distribute PBX to\\r\\n     */\\r\\n    function distributeSupplierPBX(address pToken, address supplier) internal {\\r\\n        uint supplyIndex = PBXSupplyState[pToken].index;\\r\\n        uint supplierAccrued = calculateTotalSupplierPBXAccrued(pToken, supplier, PBXSupplyState[pToken]);\\r\\n        emit DistributedSupplierPBX(PToken(pToken), supplier, sub_(supplierAccrued, PBXAccruedStored[supplier]), supplyIndex);\\r\\n        PBXAccruedStored[supplier] = supplierAccrued;\\r\\n\\r\\n        // Update supplier's index to the current index since we are distributing accrued PBX\\r\\n        PBXSupplierIndex[pToken][supplier] = supplyIndex;\\r\\n    }\\r\\n\\r\\n    function calculateTotalSupplierPBXAccrued(address pToken, address supplier, PBXMarketState memory supplyState) internal view returns (uint) {\\r\\n        // TODO: Don't distribute supplier PBX if the user is not in the supplier market.\\r\\n        // This check should be as gas efficient as possible as distributeSupplierPBX is called in many places.\\r\\n        // - We really don't want to call an external contract as that's quite expensive.\\r\\n\\r\\n        uint supplyIndex = supplyState.index;\\r\\n        uint supplierIndex = PBXSupplierIndex[pToken][supplier];\\r\\n\\r\\n        if (supplierIndex == 0 && supplyIndex >= PBXInitialIndex) {\\r\\n            // Covers the case where users supplied tokens before the market's supply state index was set.\\r\\n            // Rewards the user with PBX accrued from the start of when supplier rewards were first\\r\\n            // set for the market.\\r\\n            supplierIndex = PBXInitialIndex;\\r\\n        }\\r\\n\\r\\n        // Calculate change in the cumulative sum of the PBX per pToken accrued\\r\\n        Double memory deltaIndex = Double({mantissa : sub_(supplyIndex, supplierIndex)});\\r\\n\\r\\n        uint supplierTokens = PToken(pToken).balanceOf(supplier);\\r\\n\\r\\n        // Calculate PBX accrued: pTokenAmount * accruedPerPToken\\r\\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\\r\\n\\r\\n        return add_(PBXAccruedStored[supplier], supplierDelta);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue PBX to the market by updating the borrow index\\r\\n     * @param pToken The market whose borrow index to update\\r\\n     * @dev Index is a cumulative sum of the PBX per pToken accrued.\\r\\n     */\\r\\n    function updatePBXBorrowIndex(address pToken, Exp memory marketBorrowIndex) internal {\\r\\n        PBXBorrowState[pToken] = getUpdatedPBXBorrowIndex(pToken, marketBorrowIndex);\\r\\n    }\\r\\n\\r\\n    function getUpdatedPBXBorrowIndex(address pToken, Exp memory marketBorrowIndex) internal view returns (PBXMarketState memory) {\\r\\n        PBXMarketState memory borrowState = PBXBorrowState[pToken];\\r\\n\\r\\n        uint borrowSpeed = PBXBorrowSpeeds[pToken];\\r\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\r\\n        uint deltaBlocks = sub_(uint(blockNumber), uint(borrowState.block));\\r\\n\\r\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\r\\n            uint borrowAmount = div_(PToken(pToken).totalBorrows(), marketBorrowIndex);\\r\\n            uint newPBXAccrued = mul_(deltaBlocks, borrowSpeed);\\r\\n            Double memory ratio = borrowAmount > 0 ? fraction(newPBXAccrued, borrowAmount) : Double({mantissa: 0});\\r\\n            borrowState.index = safe224(add_(Double({mantissa: borrowState.index}), ratio).mantissa, \\\"new index exceeds 224 bits\\\");\\r\\n            borrowState.block = blockNumber;\\r\\n        } else if (deltaBlocks > 0) {\\r\\n            borrowState.block = blockNumber;\\r\\n        }\\r\\n\\r\\n        return borrowState;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Calculate PBX accrued by a borrower and possibly transfer it to them\\r\\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\\r\\n     * @param pToken The market in which the borrower is interacting\\r\\n     * @param borrower The address of the borrower to distribute PBX to\\r\\n     */\\r\\n    function distributeBorrowerPBX(address pToken, address borrower, Exp memory marketBorrowIndex) internal {\\r\\n        uint borrowIndex = PBXBorrowState[pToken].index;\\r\\n        uint borrowerAccrued = calculateTotalBorrowerPBXAccrued(pToken, borrower, marketBorrowIndex, PBXBorrowState[pToken]);\\r\\n        emit DistributedBorrowerPBX(PToken(pToken), borrower, sub_(borrowerAccrued, PBXAccruedStored[borrower]), borrowIndex);\\r\\n        PBXAccruedStored[borrower] = borrowerAccrued;\\r\\n\\r\\n        // Update borrower's index to the current index since we are distributing accrued PBX\\r\\n        PBXBorrowerIndex[pToken][borrower] = borrowIndex;\\r\\n    }\\r\\n\\r\\n    function calculateTotalBorrowerPBXAccrued(address pToken, address borrower, Exp memory marketBorrowIndex, PBXMarketState memory borrowState) internal view returns (uint) {\\r\\n        // TODO: Don't distribute supplier PBX if the user is not in the borrower market.\\r\\n        // This check should be as gas efficient as possible as distributeBorrowerPBX is called in many places.\\r\\n        // - We really don't want to call an external contract as that's quite expensive.\\r\\n\\r\\n        uint borrowIndex = borrowState.index;\\r\\n        uint borrowerIndex = PBXBorrowerIndex[pToken][borrower];\\r\\n\\r\\n        if (borrowerIndex == 0 && borrowIndex >= PBXInitialIndex) {\\r\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\r\\n            // Rewards the user with PBX accrued from the start of when borrower rewards were first\\r\\n            // set for the market.\\r\\n            borrowerIndex = PBXInitialIndex;\\r\\n        }\\r\\n\\r\\n        // Calculate change in the cumulative sum of the PBX per borrowed unit accrued\\r\\n        Double memory deltaIndex = Double({mantissa: sub_(borrowIndex, borrowerIndex)});\\r\\n\\r\\n        uint borrowerAmount = div_(PToken(pToken).borrowBalanceStored(borrower), marketBorrowIndex);\\r\\n\\r\\n        // Calculate PBX accrued: pTokenAmount * accruedPerBorrowedUnit\\r\\n        uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\\r\\n\\r\\n        return add_(PBXAccruedStored[borrower], borrowerDelta);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/ComptrollerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PToken/PToken.sol\\\";\\r\\nimport \\\"../PNFTToken/PNFTToken.sol\\\";\\r\\n\\r\\ncontract UnitrollerAdminStorage {\\r\\n    /// @notice Administrator for this contract\\r\\n    address public admin;\\r\\n\\r\\n    /// @notice Pending administrator for this contract\\r\\n    address public pendingAdmin;\\r\\n\\r\\n    /// @notice Active brains of Unitroller\\r\\n    address public comptrollerPart1Implementation;\\r\\n    address public comptrollerPart2Implementation;\\r\\n\\r\\n    /// @notice Pending brains of Unitroller\\r\\n    address public pendingComptrollerPart1Implementation;\\r\\n    address public pendingComptrollerPart2Implementation;\\r\\n}\\r\\n\\r\\ncontract ComptrollerNoNFTStorage is UnitrollerAdminStorage {\\r\\n    /// @notice Oracle which gives the price of any given asset\\r\\n    address public oracle;\\r\\n\\r\\n    /// @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\r\\n    uint public closeFactorMantissa;\\r\\n\\r\\n    /// @notice Multiplier representing the discount on collateral that a liquidator receives\\r\\n    uint public liquidationIncentiveMantissa;\\r\\n\\r\\n    /// @notice Per-account mapping of \\\"assets you are in\\\"\\r\\n    mapping(address => PToken[]) public accountAssets;\\r\\n\\r\\n    struct Market {\\r\\n        /// @notice Whether or not this market is listed\\r\\n        bool isListed;\\r\\n\\r\\n        /**\\r\\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\\r\\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\\r\\n         *  Must be between 0 and 1, and stored as a mantissa.\\r\\n         */\\r\\n        uint collateralFactorMantissa;\\r\\n\\r\\n        /// @notice Per-market mapping of \\\"accounts in this asset\\\"\\r\\n        mapping(address => bool) accountMembership;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Official mapping of pTokens -> Market metadata\\r\\n     * @dev Used e.g. to determine if a market is supported\\r\\n     */\\r\\n    mapping(address => Market) public markets;\\r\\n\\r\\n    /**\\r\\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\r\\n     *  Actions which allow users to remove their own assets cannot be paused.\\r\\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\\r\\n     */\\r\\n    address public pauseGuardian;\\r\\n    bool public mintGuardianPausedGlobal;\\r\\n    bool public borrowGuardianPausedGlobal;\\r\\n    bool public transferGuardianPausedGlobal;\\r\\n    bool public seizeGuardianPausedGlobal;\\r\\n    mapping(address => bool) public mintGuardianPaused;\\r\\n    mapping(address => bool) public borrowGuardianPaused;\\r\\n\\r\\n    struct PBXMarketState {\\r\\n        /// @notice The market's last updated PBXBorrowIndex or PBXSupplyIndex\\r\\n        uint224 index;\\r\\n\\r\\n        /// @notice The block number the index was last updated at\\r\\n        uint32 block;\\r\\n    }\\r\\n\\r\\n    /// @notice A list of all markets\\r\\n    PToken[] public allMarkets;\\r\\n\\r\\n    /// @notice The PBX market supply state for each market\\r\\n    mapping(address => PBXMarketState) public PBXSupplyState;\\r\\n\\r\\n    /// @notice The PBX market borrow state for each market\\r\\n    mapping(address => PBXMarketState) public PBXBorrowState;\\r\\n\\r\\n    /// @notice The PBX borrow index for each market for each supplier as of the last time they accrued PBX\\r\\n    mapping(address => mapping(address => uint)) public PBXSupplierIndex;\\r\\n\\r\\n    /// @notice The PBX borrow index for each market for each borrower as of the last time they accrued PBX\\r\\n    mapping(address => mapping(address => uint)) public PBXBorrowerIndex;\\r\\n\\r\\n    /// @notice The PBX accrued but not yet transferred to each user\\r\\n    mapping(address => uint) public PBXAccruedStored;\\r\\n\\r\\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\\r\\n    address public borrowCapGuardian;\\r\\n\\r\\n    /// @notice Borrow caps enforced by borrowAllowed for each pToken address. Defaults to zero which corresponds to unlimited borrowing.\\r\\n    mapping(address => uint) public borrowCaps;\\r\\n\\r\\n    /// @notice The portion of PBX that each contributor receives per block\\r\\n    mapping(address => uint) public PBXContributorSpeeds;\\r\\n\\r\\n    /// @notice Last block at which a contributor's PBX rewards have been allocated\\r\\n    mapping(address => uint) public lastContributorBlock;\\r\\n\\r\\n    /// @notice The PBX governance token\\r\\n    address public PBXToken;\\r\\n\\r\\n    /// @notice The rate at which PBX is distributed to the corresponding borrow market (per block)\\r\\n    mapping(address => uint) public PBXBorrowSpeeds;\\r\\n\\r\\n    /// @notice The rate at which PBX is distributed to the corresponding supply market (per block)\\r\\n    mapping(address => uint) public PBXSupplySpeeds;\\r\\n\\r\\n    /// @notice The initial PBX index for a market\\r\\n    uint224 public constant PBXInitialIndex = 1e36;\\r\\n\\r\\n    /// @dev closeFactorMantissa must be strictly greater than this value\\r\\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\\r\\n\\r\\n    /// @dev closeFactorMantissa must not exceed this value\\r\\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\\r\\n\\r\\n    /// @dev market collateral factor must not exceed this value\\r\\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\\r\\n}\\r\\n\\r\\ncontract ComptrollerNFTStorage is ComptrollerNoNFTStorage {\\r\\n    /// @notice A list of all NFT markets\\r\\n    PNFTToken[] public allNFTMarkets;\\r\\n\\r\\n    /// @notice Per-account mapping of \\\"assets you are in\\\"\\r\\n    mapping(address => PNFTToken[]) public accountNFTAssets;\\r\\n\\r\\n    uint public NFTCollateralLiquidationIncentiveMantissa;\\r\\n\\r\\n    uint public NFTCollateralLiquidationBonusPBXIncentiveMantissa;\\r\\n\\r\\n    address public NFTXioMarketplaceZapAddress;\\r\\n\\r\\n    address public SudoswapPairRouterAddress; // LSSVMRouter contract\\r\\n\\r\\n    uint public NFTCollateralSeizeLiquidationFactorMantissa;\\r\\n\\r\\n    /// @notice whether PToken can be used as a part of NFT liquidation process\\r\\n    mapping(address => bool) public isNFTLiquidationExchangePToken;\\r\\n\\r\\n    bool public NFTModuleClosedBeta = false;\\r\\n\\r\\n    mapping(address => bool) public NFTModuleWhitelistedUsers;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Comptroller/Unitroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../ErrorReporter.sol\\\";\\r\\nimport \\\"./ComptrollerInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ComptrollerCore\\r\\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\\r\\n * PTokens should reference this contract as their comptroller.\\r\\n */\\r\\ncontract Unitroller is UnitrollerInterface {\\r\\n    constructor() public {\\r\\n        admin = msg.sender;\\r\\n    }\\r\\n\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\r\\n    function isComptroller() external pure returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n    function _setPendingImplementations(address newPendingPart1Implementation, address newPendingPart2Implementation) external {\\r\\n        require(newPendingPart1Implementation != address(0) && newPendingPart2Implementation != address(0), \\\"invalid argument\\\");\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n\\r\\n        {\\r\\n            ComptrollerNoNFTInterface part1 = ComptrollerNoNFTInterface(newPendingPart1Implementation);\\r\\n            ComptrollerNoNFTInterface part2 = ComptrollerNoNFTInterface(newPendingPart2Implementation);\\r\\n            require(part1.isComptrollerPart1() && !part1.isComptroller());\\r\\n            require(part2.isComptrollerPart2() && !part2.isComptroller());\\r\\n        }\\r\\n\\r\\n        _setPendingImplementationsInternal(newPendingPart1Implementation, newPendingPart2Implementation);\\r\\n    }\\r\\n\\r\\n    function _setPendingImplementationsInternal(address newPendingPart1Implementation, address newPendingPart2Implementation) internal {\\r\\n        emit NewPendingImplementations(pendingComptrollerPart1Implementation, newPendingPart1Implementation, pendingComptrollerPart2Implementation, newPendingPart2Implementation);\\r\\n\\r\\n        pendingComptrollerPart1Implementation = newPendingPart1Implementation;\\r\\n        pendingComptrollerPart2Implementation = newPendingPart2Implementation;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingPart1Implementation or pendingPart2Implementation\\r\\n    * @dev Admin function for new implementation to accept it's role as implementation\\r\\n    */\\r\\n    function _acceptImplementation() external {\\r\\n        if (msg.sender == pendingComptrollerPart1Implementation) {\\r\\n            emit NewImplementation(comptrollerPart1Implementation, pendingComptrollerPart1Implementation, comptrollerPart2Implementation, comptrollerPart2Implementation);\\r\\n            comptrollerPart1Implementation = pendingComptrollerPart1Implementation;\\r\\n\\r\\n            _setPendingImplementationsInternal(address(0), pendingComptrollerPart2Implementation);\\r\\n\\r\\n        } else if (msg.sender == pendingComptrollerPart2Implementation) {\\r\\n            emit NewImplementation(comptrollerPart1Implementation, comptrollerPart1Implementation, comptrollerPart2Implementation, pendingComptrollerPart2Implementation);\\r\\n            comptrollerPart2Implementation = pendingComptrollerPart2Implementation;\\r\\n\\r\\n            _setPendingImplementationsInternal(pendingComptrollerPart1Implementation, address(0));\\r\\n\\r\\n        } else {\\r\\n            require(false, \\\"only pending implementation\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @param newPendingAdmin New pending admin.\\r\\n      */\\r\\n    function _setPendingAdmin(address newPendingAdmin) external {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n\\r\\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin);\\r\\n        pendingAdmin = newPendingAdmin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\r\\n      * @dev Admin function for pending admin to accept role and update admin\\r\\n      */\\r\\n    function _acceptAdmin() external {\\r\\n        require(msg.sender == pendingAdmin, \\\"only pending admin\\\");\\r\\n\\r\\n        emit NewAdmin(admin, pendingAdmin);\\r\\n        emit NewPendingAdmin(pendingAdmin, address(0));\\r\\n        admin = pendingAdmin;\\r\\n        pendingAdmin = address(0);\\r\\n    }\\r\\n\\r\\n    /// @dev Delegates execution to an implementation contract. It returns to the external caller whatever the implementation returns or forwards reverts.\\r\\n    function() external payable {\\r\\n        // delegate all other functions to current implementation. ComptrollerPart1 fallback function delegates to ComptrollerPart2\\r\\n        (bool success,) = comptrollerPart1Implementation.delegatecall(msg.data);\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 {revert(free_mem_ptr, returndatasize)}\\r\\n            default {return (free_mem_ptr, returndatasize)}\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ErrorReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\ncontract ComptrollerErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR, // 0\\r\\n        COMPTROLLER_MISMATCH, // 1\\r\\n        INSUFFICIENT_SHORTFALL, // 2\\r\\n        INSUFFICIENT_LIQUIDITY, // 3\\r\\n        INVALID_COLLATERAL_FACTOR, // 4\\r\\n        MARKET_NOT_ENTERED, // 5\\r\\n        MARKET_NOT_LISTED, // 6\\r\\n        MARKET_ALREADY_LISTED, // 7\\r\\n        NONZERO_BORROW_BALANCE, // 8\\r\\n        PRICE_ERROR, // 9\\r\\n        REJECTION, // 10\\r\\n        TOO_MUCH_REPAY, // 11\\r\\n        NFT_USER_NOT_ALLOWED // 12\\r\\n    }\\r\\n\\r\\n    enum FailureInfo {\\r\\n        EXIT_MARKET_BALANCE_OWED, // 0\\r\\n        EXIT_MARKET_REJECTION, // 1\\r\\n        SET_COLLATERAL_FACTOR_NO_EXISTS, // 2\\r\\n        SET_COLLATERAL_FACTOR_VALIDATION, // 3\\r\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE, // 4\\r\\n        SUPPORT_MARKET_EXISTS // 5\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\r\\n      */\\r\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), opaqueError);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR, // 0\\r\\n        BAD_INPUT, // 1\\r\\n        COMPTROLLER_REJECTION, // 2\\r\\n        INVALID_ACCOUNT_PAIR, // 3\\r\\n        INVALID_CLOSE_AMOUNT_REQUESTED, // 4\\r\\n        MARKET_NOT_FRESH, // 5\\r\\n        TOKEN_INSUFFICIENT_CASH // 6\\r\\n    }\\r\\n\\r\\n    enum FailureInfo {\\r\\n        BORROW_CASH_NOT_AVAILABLE, // 0\\r\\n        BORROW_FRESHNESS_CHECK, // 1\\r\\n        BORROW_COMPTROLLER_REJECTION, // 2\\r\\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK, // 3\\r\\n        LIQUIDATE_COMPTROLLER_REJECTION, // 4\\r\\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX, // 5\\r\\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO, // 6\\r\\n        LIQUIDATE_FRESHNESS_CHECK, // 7\\r\\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER, // 8\\r\\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED, // 9\\r\\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, // 10\\r\\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER, // 11\\r\\n        MINT_COMPTROLLER_REJECTION, // 12\\r\\n        MINT_FRESHNESS_CHECK, // 13\\r\\n        REDEEM_COMPTROLLER_REJECTION, // 14\\r\\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE, // 15\\r\\n        REDEEM_FRESHNESS_CHECK, // 16\\r\\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE, // 17\\r\\n        REDUCE_RESERVES_FRESH_CHECK, // 18\\r\\n        REDUCE_RESERVES_VALIDATION, // 19\\r\\n        REPAY_BORROW_COMPTROLLER_REJECTION, // 20\\r\\n        REPAY_BORROW_FRESHNESS_CHECK, // 21\\r\\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK, // 22\\r\\n        SET_RESERVE_FACTOR_FRESH_CHECK, // 23\\r\\n        SET_RESERVE_FACTOR_BOUNDS_CHECK, // 24\\r\\n        TRANSFER_COMPTROLLER_REJECTION, // 25\\r\\n        TRANSFER_NOT_ALLOWED, // 26\\r\\n        ADD_RESERVES_FRESH_CHECK // 27\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\r\\n      */\\r\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), opaqueError);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/InterestRateModels/BaseJumpRateModelV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"../Utils/SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n  * @title Logic for Compound's JumpRateModel Contract V2.\\r\\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\\r\\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\\r\\n  */\\r\\ncontract BaseJumpRateModelV2 {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\\r\\n\\r\\n    /// @notice Emitted when pendingAdmin is changed\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /// @notice The address of the owner\\r\\n    address public owner;\\r\\n\\r\\n    /// @notice Pending owner for this contract\\r\\n    address public pendingOwner;\\r\\n\\r\\n    /// @notice The approximate number of blocks per year that is assumed by the interest rate model\\r\\n    uint public blocksPerYear;\\r\\n\\r\\n    /// @notice The multiplier of utilization rate that gives the slope of the interest rate\\r\\n    uint public multiplierPerBlock;\\r\\n\\r\\n    /// @notice The base interest rate which is the y-intercept when utilization rate is 0\\r\\n    uint public baseRatePerBlock;\\r\\n\\r\\n    /// @notice The multiplierPerBlock after hitting a specified utilization point\\r\\n    uint public jumpMultiplierPerBlock;\\r\\n\\r\\n    /// @notice The utilization point at which the jump multiplier is applied\\r\\n    uint public kink;\\r\\n\\r\\n    /**\\r\\n     * @notice Construct an interest rate model\\r\\n     * @param blocksPerYear_ The approximate number of blocks per year that is assumed by the interest rate model\\r\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\\r\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\\r\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\r\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\r\\n     * @param owner_ The address of the owner\\r\\n     */\\r\\n    constructor(uint blocksPerYear_, uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal {\\r\\n        owner = owner_;\\r\\n        blocksPerYear = blocksPerYear_;\\r\\n\\r\\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Begins transfer of owner rights. The newPendingOwner must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @dev Admin function to begin change of owner. The newPendingOwner must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @param newPendingOwner New pending owner.\\r\\n      */\\r\\n    function _setPendingAdmin(address newPendingOwner) external {\\r\\n        require(msg.sender == owner, \\\"only admin\\\");\\r\\n\\r\\n        emit NewPendingAdmin(pendingOwner, newPendingOwner);\\r\\n        pendingOwner = newPendingOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Accepts transfer of owner rights. msg.sender must be pendingOwner\\r\\n      * @dev Admin function for pending owner to accept role and update owner\\r\\n      */\\r\\n    function _acceptAdmin() external {\\r\\n        require(msg.sender == pendingOwner, \\\"only pending admin\\\");\\r\\n\\r\\n        emit NewAdmin(owner, pendingOwner);\\r\\n        emit NewPendingAdmin(pendingOwner, address(0));\\r\\n        owner = pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\\r\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\\r\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\\r\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\r\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\r\\n     */\\r\\n    function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) external {\\r\\n        require(msg.sender == owner, \\\"only admin\\\");\\r\\n\\r\\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\\r\\n     * @param cash The amount of cash in the market\\r\\n     * @param borrows The amount of borrows in the market\\r\\n     * @param reserves The amount of reserves in the market (currently unused)\\r\\n     * @return The utilization rate as a mantissa between [0, 1e18]\\r\\n     */\\r\\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\\r\\n        // Utilization rate is 0 when there are no borrows\\r\\n        if (borrows == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\\r\\n     * @param cash The amount of cash in the market\\r\\n     * @param borrows The amount of borrows in the market\\r\\n     * @param reserves The amount of reserves in the market\\r\\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\\r\\n     */\\r\\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\\r\\n        uint util = utilizationRate(cash, borrows, reserves);\\r\\n\\r\\n        if (util <= kink) {\\r\\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\\r\\n        } else {\\r\\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\\r\\n            uint excessUtil = util.sub(kink);\\r\\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current supply rate per block\\r\\n     * @param cash The amount of cash in the market\\r\\n     * @param borrows The amount of borrows in the market\\r\\n     * @param reserves The amount of reserves in the market\\r\\n     * @param reserveFactorMantissa The current reserve factor for the market\\r\\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\\r\\n     */\\r\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {\\r\\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\\r\\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\\r\\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\\r\\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to update the parameters of the interest rate model\\r\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\\r\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\\r\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\r\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\r\\n     */\\r\\n    function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {\\r\\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\\r\\n        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(blocksPerYear.mul(kink_));\\r\\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\\r\\n        kink = kink_;\\r\\n\\r\\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/InterestRateModels/InterestRateModelInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n  * @title Compound's InterestRateModel Interface\\r\\n  * @author Compound\\r\\n  */\\r\\ncontract InterestRateModelInterface {\\r\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\r\\n    bool public constant isInterestRateModel = true;\\r\\n\\r\\n    /**\\r\\n      * @notice Calculates the current borrow interest rate per block\\r\\n      * @param cash The total amount of cash the market has\\r\\n      * @param borrows The total amount of borrows the market has outstanding\\r\\n      * @param reserves The total amount of reserves the market has\\r\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\r\\n      */\\r\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\\r\\n\\r\\n    /**\\r\\n      * @notice Calculates the current supply interest rate per block\\r\\n      * @param cash The total amount of cash the market has\\r\\n      * @param borrows The total amount of borrows the market has outstanding\\r\\n      * @param reserves The total amount of reserves the market has\\r\\n      * @param reserveFactorMantissa The current reserve factor the market has\\r\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\r\\n      */\\r\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/InterestRateModels/JumpRateModelV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./BaseJumpRateModelV2.sol\\\";\\r\\nimport \\\"./InterestRateModelInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n  * @title Compound's JumpRateModel Contract V2 for V2 pTokens\\r\\n  * @author Arr00\\r\\n  * @notice Supports only for V2 pTokens\\r\\n  */\\r\\ncontract JumpRateModelV2 is InterestRateModelInterface, BaseJumpRateModelV2 {\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current borrow rate per block\\r\\n     * @param cash The amount of cash in the market\\r\\n     * @param borrows The amount of borrows in the market\\r\\n     * @param reserves The amount of reserves in the market\\r\\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\\r\\n     */\\r\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint) {\\r\\n        return getBorrowRateInternal(cash, borrows, reserves);\\r\\n    }\\r\\n\\r\\n    constructor(uint blocksPerYear_, uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_)\\r\\n    BaseJumpRateModelV2(blocksPerYear_, baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_, owner_) public { }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/AaveInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\ninterface AaveIPool {\\r\\n    /**\\r\\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\r\\n     * as long as the amount taken plus a fee is returned.\\r\\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\r\\n     * into consideration. For further details please visit https://developers.aave.com\\r\\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\r\\n     * @param asset The address of the asset being flash-borrowed\\r\\n     * @param amount The amount of the asset being flash-borrowed\\r\\n     * @param params Variadic packed params to pass to the receiver as extra information\\r\\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\r\\n     *   0 if the action is executed directly by the user, without any middle-man\\r\\n     **/\\r\\n    function flashLoanSimple(address receiverAddress, address asset, uint256 amount, bytes calldata params, uint16 referralCode) external;\\r\\n}\\r\\n\\r\\ninterface AaveIPoolAddressesProvider {\\r\\n    function getPool() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface AaveIFlashLoanSimpleReceiver {\\r\\n    /**\\r\\n     * @notice Executes an operation after receiving the flash-borrowed asset\\r\\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\\r\\n     *      enough funds to repay and has approved the Pool to pull the total amount\\r\\n     * @param asset The address of the flash-borrowed asset\\r\\n     * @param amount The amount of the flash-borrowed asset\\r\\n     * @param premium The fee of the flash-borrowed asset\\r\\n     * @param initiator The address of the flashloan initiator\\r\\n     * @param params The byte-encoded params passed when initiating the flashloan\\r\\n     * @return True if the execution of the operation succeeds, false otherwise\\r\\n     */\\r\\n    function executeOperation(address asset, uint256 amount, uint256 premium, address initiator, bytes calldata params) external returns (bool);\\r\\n    function ADDRESSES_PROVIDER() external view returns (AaveIPoolAddressesProvider);\\r\\n    function POOL() external view returns (AaveIPool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/Api3Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface Api3IAirnodeRequester {\\r\\n    function airnodeProtocol() external view returns (address);\\r\\n}\\r\\n\\r\\ncontract Api3IDapiServer is Api3IAirnodeRequester {\\r\\n    event SetRrpBeaconUpdatePermissionStatus(\\r\\n        address indexed sponsor,\\r\\n        address indexed rrpBeaconUpdateRequester,\\r\\n        bool status\\r\\n    );\\r\\n\\r\\n    event RequestedRrpBeaconUpdate(\\r\\n        bytes32 indexed beaconId,\\r\\n        address indexed sponsor,\\r\\n        address indexed requester,\\r\\n        bytes32 requestId,\\r\\n        address airnode,\\r\\n        bytes32 templateId\\r\\n    );\\r\\n\\r\\n    event RequestedRrpBeaconUpdateRelayed(\\r\\n        bytes32 indexed beaconId,\\r\\n        address indexed sponsor,\\r\\n        address indexed requester,\\r\\n        bytes32 requestId,\\r\\n        address airnode,\\r\\n        address relayer,\\r\\n        bytes32 templateId\\r\\n    );\\r\\n\\r\\n    event UpdatedBeaconWithRrp(\\r\\n        bytes32 indexed beaconId,\\r\\n        bytes32 requestId,\\r\\n        int256 value,\\r\\n        uint256 timestamp\\r\\n    );\\r\\n\\r\\n    event RegisteredBeaconUpdateSubscription(\\r\\n        bytes32 indexed subscriptionId,\\r\\n        address airnode,\\r\\n        bytes32 templateId,\\r\\n        bytes parameters,\\r\\n        bytes conditions,\\r\\n        address relayer,\\r\\n        address sponsor,\\r\\n        address requester,\\r\\n        bytes4 fulfillFunctionId\\r\\n    );\\r\\n\\r\\n    event UpdatedBeaconWithPsp(\\r\\n        bytes32 indexed beaconId,\\r\\n        bytes32 subscriptionId,\\r\\n        int224 value,\\r\\n        uint32 timestamp\\r\\n    );\\r\\n\\r\\n    event UpdatedBeaconWithSignedData(\\r\\n        bytes32 indexed beaconId,\\r\\n        int256 value,\\r\\n        uint256 timestamp\\r\\n    );\\r\\n\\r\\n    event UpdatedBeaconSetWithBeacons(\\r\\n        bytes32 indexed beaconSetId,\\r\\n        int224 value,\\r\\n        uint32 timestamp\\r\\n    );\\r\\n\\r\\n    event UpdatedBeaconSetWithSignedData(\\r\\n        bytes32 indexed dapiId,\\r\\n        int224 value,\\r\\n        uint32 timestamp\\r\\n    );\\r\\n\\r\\n    event AddedUnlimitedReader(address indexed unlimitedReader);\\r\\n\\r\\n    event SetDapiName(\\r\\n        bytes32 indexed dapiName,\\r\\n        bytes32 dataFeedId,\\r\\n        address indexed sender\\r\\n    );\\r\\n\\r\\n    function setRrpBeaconUpdatePermissionStatus(\\r\\n        address rrpBeaconUpdateRequester,\\r\\n        bool status\\r\\n    ) external;\\r\\n\\r\\n    function requestRrpBeaconUpdate(\\r\\n        address airnode,\\r\\n        bytes32 templateId,\\r\\n        address sponsor\\r\\n    ) external returns (bytes32 requestId);\\r\\n\\r\\n    function requestRrpBeaconUpdateRelayed(\\r\\n        address airnode,\\r\\n        bytes32 templateId,\\r\\n        address relayer,\\r\\n        address sponsor\\r\\n    ) external returns (bytes32 requestId);\\r\\n\\r\\n    function fulfillRrpBeaconUpdate(\\r\\n        bytes32 requestId,\\r\\n        uint256 timestamp,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function registerBeaconUpdateSubscription(\\r\\n        address airnode,\\r\\n        bytes32 templateId,\\r\\n        bytes memory conditions,\\r\\n        address relayer,\\r\\n        address sponsor\\r\\n    ) public returns (bytes32 subscriptionId);\\r\\n\\r\\n    function conditionPspBeaconUpdate(\\r\\n        bytes32 subscriptionId,\\r\\n        bytes calldata data,\\r\\n        bytes calldata conditionParameters\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function fulfillPspBeaconUpdate(\\r\\n        bytes32 subscriptionId,\\r\\n        address airnode,\\r\\n        address relayer,\\r\\n        address sponsor,\\r\\n        uint256 timestamp,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external;\\r\\n\\r\\n    function updateBeaconWithSignedData(\\r\\n        address airnode,\\r\\n        bytes32 beaconId,\\r\\n        uint256 timestamp,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external;\\r\\n\\r\\n    function updateBeaconSetWithBeacons(bytes32[] memory beaconIds)\\r\\n        public\\r\\n        returns (bytes32 beaconSetId);\\r\\n\\r\\n    function updateBeaconSetWithBeaconsAndReturnCondition(\\r\\n        bytes32[] memory beaconIds,\\r\\n        uint256 updateThresholdInPercentage\\r\\n    ) public returns (bool);\\r\\n\\r\\n    function conditionPspBeaconSetUpdate(\\r\\n        bytes32 subscriptionId,\\r\\n        bytes calldata data,\\r\\n        bytes calldata conditionParameters\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function fulfillPspBeaconSetUpdate(\\r\\n        bytes32 subscriptionId,\\r\\n        address airnode,\\r\\n        address relayer,\\r\\n        address sponsor,\\r\\n        uint256 timestamp,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external;\\r\\n\\r\\n    function updateBeaconSetWithSignedData(\\r\\n        address[] memory airnodes,\\r\\n        bytes32[] memory templateIds,\\r\\n        uint256[] memory timestamps,\\r\\n        bytes[] memory data,\\r\\n        bytes[] memory signatures\\r\\n    ) public returns (bytes32 beaconSetId);\\r\\n\\r\\n    function addUnlimitedReader(address unlimitedReader) external;\\r\\n\\r\\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId) external;\\r\\n\\r\\n    function dapiNameToDataFeedId(bytes32 dapiName)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32);\\r\\n\\r\\n    function readDataFeedWithId(bytes32 dataFeedId)\\r\\n        external\\r\\n        view\\r\\n        returns (int224 value, uint32 timestamp);\\r\\n\\r\\n    function readDataFeedValueWithId(bytes32 dataFeedId)\\r\\n        external\\r\\n        view\\r\\n        returns (int224 value);\\r\\n\\r\\n    function readDataFeedWithDapiName(bytes32 dapiName)\\r\\n        external\\r\\n        view\\r\\n        returns (int224 value, uint32 timestamp);\\r\\n\\r\\n    function readDataFeedValueWithDapiName(bytes32 dapiName)\\r\\n        external\\r\\n        view\\r\\n        returns (int224 value);\\r\\n\\r\\n    function readerCanReadDataFeed(bytes32 dataFeedId, address reader)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function dataFeedIdToReaderToWhitelistStatus(\\r\\n        bytes32 dataFeedId,\\r\\n        address reader\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\\r\\n\\r\\n    function dataFeedIdToReaderToSetterToIndefiniteWhitelistStatus(\\r\\n        bytes32 dataFeedId,\\r\\n        address reader,\\r\\n        address setter\\r\\n    ) external view returns (bool indefiniteWhitelistStatus);\\r\\n\\r\\n    function deriveBeaconId(address airnode, bytes32 templateId)\\r\\n        external\\r\\n        pure\\r\\n        returns (bytes32 beaconId);\\r\\n\\r\\n    function deriveBeaconSetId(bytes32[] memory beaconIds)\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32 beaconSetId);\\r\\n\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DAPI_NAME_SETTER_ROLE_DESCRIPTION()\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function HUNDRED_PERCENT() external view returns (uint256);\\r\\n\\r\\n    function dapiNameSetterRole() external view returns (bytes32);\\r\\n\\r\\n    function sponsorToRrpBeaconUpdateRequesterToPermissionStatus(\\r\\n        address sponsor,\\r\\n        address updateRequester\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function subscriptionIdToBeaconId(bytes32 subscriptionId)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/CryptoPunksMarketInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\ncontract CryptoPunksMarketInterface {\\r\\n    string public imageHash; // You can use this hash to verify the image file containing all the punks\\r\\n    address public owner;\\r\\n    string public standard;\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public decimals;\\r\\n    uint256 public totalSupply;\\r\\n    uint public nextPunkIndexToAssign;\\r\\n    bool public allPunksAssigned;\\r\\n    uint public punksRemainingToAssign;\\r\\n    mapping(uint => address) public punkIndexToAddress;\\r\\n    mapping(address => uint256) public balanceOf; // This creates an array with all balances\\r\\n\\r\\n    struct Offer {\\r\\n        bool isForSale;\\r\\n        uint punkIndex;\\r\\n        address seller;\\r\\n        uint minValue; // in ether\\r\\n        address onlySellTo; // specify to sell only to a specific person\\r\\n    }\\r\\n\\r\\n    struct Bid {\\r\\n        bool hasBid;\\r\\n        uint punkIndex;\\r\\n        address bidder;\\r\\n        uint value;\\r\\n    }\\r\\n\\r\\n    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person\\r\\n    mapping(uint => Offer) public punksOfferedForSale;\\r\\n    mapping(uint => Bid) public punkBids; // A record of the highest punk bid\\r\\n    mapping(address => uint) public pendingWithdrawals;\\r\\n\\r\\n    event Assign(address indexed to, uint256 punkIndex);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);\\r\\n    event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);\\r\\n    event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);\\r\\n    event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);\\r\\n    event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);\\r\\n    event PunkNoLongerForSale(uint indexed punkIndex);\\r\\n\\r\\n    // Initializes contract with initial supply tokens to the creator of the contract\\r\\n    function CryptoPunksMarket() public payable;\\r\\n\\r\\n    function setInitialOwner(address to, uint punkIndex) public;\\r\\n\\r\\n    function setInitialOwners(address[] memory addresses, uint[] memory indices) public;\\r\\n\\r\\n    function allInitialOwnersAssigned() public;\\r\\n\\r\\n    function getPunk(uint punkIndex) public;\\r\\n\\r\\n    // Transfer ownership of a punk to another user without requiring payment\\r\\n    function transferPunk(address to, uint punkIndex) public;\\r\\n\\r\\n    function punkNoLongerForSale(uint punkIndex) public;\\r\\n\\r\\n    function offerPunkForSale(uint punkIndex, uint minSalePriceInWei) public;\\r\\n\\r\\n    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) public;\\r\\n\\r\\n    function buyPunk(uint punkIndex) public payable;\\r\\n\\r\\n    function withdraw() public;\\r\\n\\r\\n    function enterBidForPunk(uint punkIndex) public payable;\\r\\n\\r\\n    function acceptBidForPunk(uint punkIndex, uint minPrice) public;\\r\\n\\r\\n    function withdrawBidForPunk(uint punkIndex) public;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/EIP20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\n/**\\r\\n * @title ERC 20 Token Standard Interface\\r\\n *  https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface EIP20Interface {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the total number of tokens in circulation\\r\\n      * @return The supply of tokens\\r\\n      */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return The balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      * @return Whether or not the transfer succeeded\\r\\n      */\\r\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n      * @param src The address of the source account\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      * @return Whether or not the transfer succeeded\\r\\n      */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n      * @dev This will overwrite the approval amount for `spender`\\r\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\r\\n      * @return Whether or not the approval succeeded\\r\\n      */\\r\\n    function approve(address spender, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the current allowance from `owner` for `spender`\\r\\n      * @param owner The address of the account which owns the tokens to be spent\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\r\\n      */\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/EIP20NonStandardInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\n/**\\r\\n * @title EIP20NonStandardInterface\\r\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\r\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n */\\r\\ninterface EIP20NonStandardInterface {\\r\\n\\r\\n    /**\\r\\n     * @notice Get the total number of tokens in circulation\\r\\n     * @return The supply of tokens\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return The balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transfer(address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n      * @param src The address of the source account\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n      * @dev This will overwrite the approval amount for `spender`\\r\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @param amount The number of tokens that are approved\\r\\n      * @return Whether or not the approval succeeded\\r\\n      */\\r\\n    function approve(address spender, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the current allowance from `owner` for `spender`\\r\\n      * @param owner The address of the account which owns the tokens to be spent\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @return The number of tokens allowed to be spent\\r\\n      */\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/// @dev Required interface of an ERC721 compliant contract.\\r\\ninterface IERC721 {\\r\\n    /// @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /// @dev Returns the number of tokens in ``owner``'s account.\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n      *\\r\\n      * Requirements:\\r\\n      *\\r\\n      * - `from` cannot be the zero address.\\r\\n      * - `to` cannot be the zero address.\\r\\n      * - `tokenId` token must exist and be owned by `from`.\\r\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n      *\\r\\n      * Emits a {Transfer} event.\\r\\n      */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n    /**\\r\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n     * by `operator` from `from`, this function is called.\\r\\n     *\\r\\n     * It must return its Solidity selector to confirm the token transfer.\\r\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n     *\\r\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/NFTXInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\ninterface INFTXVault {\\r\\n    function assetAddress() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface INFTXVaultFactory {\\r\\n    function vault(uint256 vaultId) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface INFTXMarketplaceZap {\\r\\n    function nftxFactory() external view returns (INFTXVaultFactory);\\r\\n\\r\\n    function mintAndSell721(uint256 vaultId, uint256[] calldata ids, uint256 minEthOut, address[] calldata path, address to) external;\\r\\n    function mintAndSell721WETH(uint256 vaultId, uint256[] calldata ids, uint256 minWethOut, address[] calldata path, address to) external;\\r\\n\\r\\n    function mintAndSell1155(uint256 vaultId, uint256[] calldata ids, uint256[] calldata amounts, uint256 minWethOut, address[] calldata path, address to) external;\\r\\n    function mintAndSell1155WETH(uint256 vaultId, uint256[] calldata ids, uint256[] calldata amounts, uint256 minWethOut, address[] calldata path, address to) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/SudoswapInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface LSSVMPairERC20Interface {\\r\\n    function nft() external view returns (address);\\r\\n    function token() external view returns (address);\\r\\n\\r\\n    function swapNFTsForToken(uint256[] calldata nftIds, uint256 minExpectedTokenOutput, address payable tokenRecipient) external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface LSSVMRouterInterface {\\r\\n    struct PairSwapSpecific {\\r\\n        LSSVMPairERC20Interface pair;\\r\\n        uint256[] nftIds;\\r\\n    }\\r\\n\\r\\n    function swapNFTsForToken(\\r\\n        PairSwapSpecific[] calldata swapList,\\r\\n        uint256 minOutput,\\r\\n        address tokenRecipient,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/UniswapV3Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IUniswapV3SwapRouter {\\r\\n    function factory() external returns (address);\\r\\n\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\r\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\r\\n    /// @return amountOut The amount of the received token\\r\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\r\\n\\r\\n    struct ExactInputParams {\\r\\n        bytes path;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\r\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\r\\n    /// @return amountOut The amount of the received token\\r\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\r\\n\\r\\n    struct ExactOutputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountOut;\\r\\n        uint256 amountInMaximum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\r\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\r\\n    /// @return amountIn The amount of the input token\\r\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\r\\n\\r\\n    struct ExactOutputParams {\\r\\n        bytes path;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountOut;\\r\\n        uint256 amountInMaximum;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\r\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\r\\n    /// @return amountIn The amount of the input token\\r\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\r\\n}\\r\\n\\r\\ninterface IUniswapV3Pool {\\r\\n    function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked);\\r\\n    function liquidity() external view returns (uint128);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IUniswapV3Factory {\\r\\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Liquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./Utils/SafeMath.sol\\\";\\r\\nimport \\\"./Interfaces/EIP20Interface.sol\\\";\\r\\nimport \\\"./PToken/PErc20/PErc20.sol\\\";\\r\\nimport \\\"./Comptroller/ComptrollerInterfaces.sol\\\";\\r\\nimport \\\"./Interfaces/AaveInterfaces.sol\\\";\\r\\nimport \\\"./Interfaces/UniswapV3Interfaces.sol\\\";\\r\\nimport \\\"./PriceOracle/PriceOracleInterfaces.sol\\\";\\r\\n\\r\\ncontract Liquidator is AaveIFlashLoanSimpleReceiver {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMath for int;\\r\\n\\r\\n    AaveIPoolAddressesProvider public ADDRESSES_PROVIDER;\\r\\n    AaveIPool public POOL;\\r\\n    IUniswapV3SwapRouter public SWAP_ROUTER;\\r\\n\\r\\n    bool internal _notEntered;\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"Liquidator: reentered\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true; // get a gas-refund post-Istanbul\\r\\n    }\\r\\n\\r\\n    struct LiquidateParams {\\r\\n        PErc20 pToken; // TODO PErc20 does not support ETH\\r\\n        address borrower;\\r\\n        uint256 repayAmount;\\r\\n        PErc20 pTokenCollateral; // TODO ^^ PTokenInterface\\r\\n        address initiator;\\r\\n        bool collateralAsReward; // true to receive pTokenCollateral as reward; false to receive pToken as reward\\r\\n    }\\r\\n\\r\\n    constructor(address AaveAddressesProvider, address UniswapRouter) public {\\r\\n        ADDRESSES_PROVIDER = AaveIPoolAddressesProvider(AaveAddressesProvider);\\r\\n        SWAP_ROUTER = IUniswapV3SwapRouter(UniswapRouter);\\r\\n        POOL = AaveIPool(ADDRESSES_PROVIDER.getPool());\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /// @notice liquidate 'borrower' loan of 'pToken' using max worth collateral and max possible amount to liquidate; take 'pToken' as reward\\r\\n    /// 1. Borrow X TokenA from AAVE flashloan\\r\\n    /// 2. Liquidate TokenA loan and receive Y TokenB\\r\\n    /// 3. Trade all Y TokenB for Z TokenA on Uniswap (Z > X)\\r\\n    /// 4. Repay AAVE flashloan for X TokenA\\r\\n    /// 5. Keep Z - X TokenA as profit\\r\\n    function liquidate(PErc20 pToken, address borrower, address initiator) external {\\r\\n        PTokenInterface pTokenCollateral = _findMaxWorthCollateral(pToken, borrower);\\r\\n        uint256 repayAmount = _findMaxRepayAmount(pToken, borrower, pTokenCollateral);\\r\\n\\r\\n        return _liquidateImpl(pToken, borrower, repayAmount, pTokenCollateral, initiator, false);\\r\\n    }\\r\\n\\r\\n    /// @notice liquidate 'borrower' loan of 'pToken' using 'pTokenCollateral' and max possible amount to liquidate; take 'pTokenCollateral' as reward\\r\\n    /// 1. Borrow X TokenA from AAVE flashloan\\r\\n    /// 2. Liquidate TokenA loan and receive Y TokenB\\r\\n    /// 3. Trade Z TokenB for exact X TokenA on Uniswap (Z < Y)\\r\\n    /// 4. Repay AAVE flashloan for X TokenA\\r\\n    /// 5. Keep Y - Z TokenB as profit\\r\\n    function liquidateFor(PErc20 pToken, address borrower, PTokenInterface pTokenCollateral, address initiator) external {\\r\\n        uint256 repayAmount = _findMaxRepayAmount(pToken, borrower, pTokenCollateral);\\r\\n\\r\\n        return _liquidateImpl(pToken, borrower, repayAmount, pTokenCollateral, initiator, true);\\r\\n    }\\r\\n\\r\\n    /// @notice liquidate 'borrower' loan of 'pToken' using max worth collateral and max possible amount to liquidate; take collateral as reward\\r\\n    function liquidateForBest(PErc20 pToken, address borrower, address initiator) external {\\r\\n        PTokenInterface pTokenCollateral = _findMaxWorthCollateral(pToken, borrower);\\r\\n        uint256 repayAmount = _findMaxRepayAmount(pToken, borrower, pTokenCollateral);\\r\\n\\r\\n        return _liquidateImpl(pToken, borrower, repayAmount, pTokenCollateral, initiator, true);\\r\\n    }\\r\\n\\r\\n    function _liquidateImpl(PErc20 pToken, address borrower, uint256 repayAmount, PTokenInterface pTokenCollateral, address initiator, bool collateralAsReward) internal {\\r\\n        require(pToken.isPToken(), \\\"invalid argument\\\");\\r\\n        bytes memory params = _encodeParams(pToken, borrower, repayAmount, pTokenCollateral, initiator, collateralAsReward);\\r\\n        uint16 referralCode = 0; // TODO ??\\r\\n\\r\\n        POOL.flashLoanSimple(address(this), pToken.underlying(), repayAmount, params, referralCode);\\r\\n    }\\r\\n\\r\\n    function executeOperation(address asset, uint256 amount, uint256 premium, address flashloanInitiator, bytes calldata params) external nonReentrant returns (bool) {\\r\\n        // pre-requirements\\r\\n        uint256 totalDebt = amount.add(premium);\\r\\n        require(msg.sender == address(POOL), \\\"Liquidator: sender must be the pool\\\"); // this function should only be called by Aave pool after receiving flashloan\\r\\n        require(_getBalance(address(this), asset) >= amount, \\\"Liquidator: invalid balance\\\");\\r\\n        require(premium < amount, \\\"Liquidator: fee too high\\\");\\r\\n\\r\\n        _executeOperationImpl(asset, amount, totalDebt, flashloanInitiator, params);\\r\\n\\r\\n        // post-requirements\\r\\n        require(_getBalance(address(this), asset) >= amount, \\\"Liquidator: insufficient balance to payoff debt\\\");\\r\\n        require(_getBalance(address(this), asset) >= totalDebt, \\\"Liquidator: insufficient balance to payoff fee\\\");\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _executeOperationImpl(address asset, uint256 amount, uint256 totalDebt, address /*flashloanInitiator*/, bytes memory _params) internal {\\r\\n        // validate params\\r\\n        LiquidateParams memory params = _decodeParams(_params);\\r\\n        require(address(params.pToken) != address(params.pTokenCollateral), \\\"Liquidator: not supported\\\");\\r\\n        require(params.pTokenCollateral.underlying() != address(0), \\\"Liquidator: not supported\\\");\\r\\n        require(params.pToken.underlying() == asset, \\\"Liquidator: invalid arguments\\\");\\r\\n        require(amount == params.repayAmount, \\\"Liquidator: invalid arguments\\\");\\r\\n\\r\\n        // liquidation\\r\\n        uint256 seizedPTokens = _callLiquidate(params);\\r\\n\\r\\n        // redeem received PTokens for tokens\\r\\n        uint256 seizedTokens = _redeemPTokens(params.pTokenCollateral, seizedPTokens);\\r\\n        uint256 userEarnings = 0;\\r\\n        address rewardAddress;\\r\\n\\r\\n        // exchange tokens\\r\\n        if (params.collateralAsReward) { // params.pTokenCollateral.underlying() as reward\\r\\n            uint256 soldTokens = _exchangeTokensForExactAmount(params.pTokenCollateral.underlying(), asset, totalDebt, seizedTokens.sub(1));\\r\\n            userEarnings = seizedTokens.sub(soldTokens);\\r\\n            rewardAddress = params.pTokenCollateral.underlying();\\r\\n            require(userEarnings == _getBalance(address(this), rewardAddress), \\\"Liquidator: invalid balance after\\\");\\r\\n\\r\\n        } else { // asset as reward\\r\\n            uint256 receivedTokens = _exchangeAllTokens(params.pTokenCollateral.underlying(), asset, totalDebt.add(1));\\r\\n            userEarnings = receivedTokens.sub(totalDebt);\\r\\n            rewardAddress = asset;\\r\\n        }\\r\\n\\r\\n        // send user earnings\\r\\n        require(userEarnings > 0, \\\"Liquidator: no actual earnings\\\");\\r\\n        require(EIP20Interface(rewardAddress).transfer(params.initiator, userEarnings), \\\"Liquidator: send earnings transfer failed\\\");\\r\\n\\r\\n        // payoff debt\\r\\n        require(EIP20Interface(asset).approve(address(POOL), totalDebt), \\\"Liquidator: payoff debt approve failed\\\");\\r\\n    }\\r\\n\\r\\n    function _encodeParams(PErc20 pToken, address borrower, uint256 repayAmount, PTokenInterface pTokenCollateral, address initiator, bool collateralAsReward) internal pure returns (bytes memory) {\\r\\n        bytes memory params = abi.encode(address(pToken), borrower, repayAmount, address(pTokenCollateral), initiator, collateralAsReward);\\r\\n        return params;\\r\\n    }\\r\\n\\r\\n    function _decodeParams(bytes memory _params) internal pure returns (LiquidateParams memory) {\\r\\n        LiquidateParams memory params;\\r\\n        address pTokenAddress;\\r\\n        address pTokenCollateralAddress;\\r\\n        (pTokenAddress, params.borrower, params.repayAmount, pTokenCollateralAddress, params.initiator, params.collateralAsReward) = abi.decode(_params, (address, address, uint256, address, address, bool));\\r\\n        params.pToken = PErc20(pTokenAddress);\\r\\n        params.pTokenCollateral = PErc20(pTokenCollateralAddress);\\r\\n        return params;\\r\\n    }\\r\\n\\r\\n    function _findMaxWorthCollateral(PErc20 pToken, address borrower) internal returns (PTokenInterface) {\\r\\n        ComptrollerNoNFTInterface comptroller = ComptrollerNoNFTInterface(address(pToken.comptroller()));\\r\\n        PToken[] memory collaterals = comptroller.getAssetsIn(borrower);\\r\\n        uint256 maxCollateralWorth = 0;\\r\\n        PTokenInterface result;\\r\\n\\r\\n        for (uint256 i = 0; i < collaterals.length; i++) {\\r\\n            uint256 collateralPrice = PriceOracleNoNFTInterface(comptroller.oracle()).getUnderlyingPrice(collaterals[i]);\\r\\n            uint256 collateralWorth = collateralPrice.mul(collaterals[i].balanceOfUnderlying(borrower));\\r\\n\\r\\n            // because priceOracle returns number of decimals that depends on underlying asset,\\r\\n            //   we've got even number of decimals in this comparison:\\r\\n            if (collateralWorth >= maxCollateralWorth) {\\r\\n                maxCollateralWorth = collateralWorth;\\r\\n                result = PTokenInterface(collaterals[i]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function _findMaxRepayAmount(PErc20 pToken, address borrower, PTokenInterface pTokenCollateral) internal returns (uint256) {\\r\\n        ComptrollerNoNFTInterface comptroller = ComptrollerNoNFTInterface(address(pToken.comptroller()));\\r\\n        uint256 collateralPrice = PriceOracleNoNFTInterface(comptroller.oracle()).getUnderlyingPrice(PToken(address(pTokenCollateral)));\\r\\n        uint256 collateralWorth = collateralPrice.mul(pTokenCollateral.balanceOfUnderlying(borrower));\\r\\n        uint256 borrowedPrice = PriceOracleNoNFTInterface(comptroller.oracle()).getUnderlyingPrice(pToken);\\r\\n        uint256 liquidationIncentive = comptroller.liquidationIncentiveMantissa();\\r\\n        uint256 result = collateralWorth.div(liquidationIncentive.mul(borrowedPrice).div(1e18)); // liquidationIncentive has 18 decimals\\r\\n        uint256 borrowedAmount = pToken.borrowBalanceStored(borrower);\\r\\n        uint256 maxResult = borrowedAmount.mul(comptroller.closeFactorMantissa()).div(1e18); // closeFactorMantissa has 18 decimals\\r\\n\\r\\n        return result > maxResult ? maxResult : result;\\r\\n    }\\r\\n\\r\\n    function _getBalance(address account, address asset) internal view returns (uint256) {\\r\\n        return EIP20Interface(asset).balanceOf(account);\\r\\n    }\\r\\n\\r\\n    /// @return seized token amount\\r\\n    function _callLiquidate(LiquidateParams memory params) internal returns (uint256) {\\r\\n        // pre-requirements\\r\\n        (uint256 error, uint256 seizeTokens) = params.pToken.comptroller().liquidateCalculateSeizeTokens(address(params.pToken), address(params.pTokenCollateral), params.repayAmount);\\r\\n        require(error == 0, \\\"Liquidator: liquidateCalculateSeizeTokens error\\\");\\r\\n\\r\\n        uint256 protocolSeizeShare = seizeTokens.mul(params.pTokenCollateral.protocolSeizeShareMantissa()).div(1e18); // protocolSeizeShareMantissa has 18 decimals\\r\\n        seizeTokens = seizeTokens.sub(protocolSeizeShare);\\r\\n\\r\\n        // liquidation\\r\\n        require(EIP20Interface(params.pToken.underlying()).approve(address(params.pToken), params.repayAmount), \\\"Liquidator: liquidate approve failed\\\");\\r\\n        require(params.pToken.liquidateBorrow(params.borrower, params.repayAmount, params.pTokenCollateral) == 0, \\\"Liquidator: liquidateBorrow error\\\");\\r\\n\\r\\n        // post-requirements\\r\\n        require(params.pTokenCollateral.balanceOf(address(this)) >= seizeTokens, \\\"Liquidator: invalid balance after liquidation\\\");\\r\\n\\r\\n        return seizeTokens;\\r\\n    }\\r\\n\\r\\n    /// @return tokens redeemed\\r\\n    function _redeemPTokens(PErc20 pTokenCollateral, uint256 amount) internal returns (uint256) {\\r\\n        // pre-requirements\\r\\n        require(pTokenCollateral.balanceOf(address(this)) >= amount, \\\"Liquidator: invalid amount to redeem\\\");\\r\\n\\r\\n        // redeem everything\\r\\n        require(pTokenCollateral.redeem(amount) == 0, \\\"Liquidator: redeem error\\\");\\r\\n\\r\\n        // post-requirements\\r\\n        uint256 result = _getBalance(address(this), pTokenCollateral.underlying());\\r\\n        assert(result > 0);\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @return fee of the best found existing pool for ('assetToSell', 'assetToReceive') pair\\r\\n    function _findBestPoolFee(address assetToSell, address assetToReceive) internal returns (uint24) {\\r\\n        IUniswapV3Factory factory = IUniswapV3Factory(SWAP_ROUTER.factory());\\r\\n        uint24[] memory possibleFees = new uint24[](3);\\r\\n        possibleFees[0] = 500; possibleFees[1] = 3000; possibleFees[2] = 10000; // lower first\\r\\n\\r\\n        for (uint256 i = 0; i < possibleFees.length; i++) {\\r\\n            address poolAddress = factory.getPool(assetToSell, assetToReceive, possibleFees[i]);\\r\\n            if (poolAddress == address(0)) continue;\\r\\n            IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\r\\n\\r\\n            (uint160 sqrtPriceX96, , , , , ,) = pool.slot0();\\r\\n            if (pool.liquidity() > 0 && sqrtPriceX96 > 0) return possibleFees[i];\\r\\n        }\\r\\n\\r\\n        revert(\\\"Liquidator: no uniswap v3 pool available\\\");\\r\\n    }\\r\\n\\r\\n    /// @return amount received\\r\\n    function _exchangeAllTokens(address assetToSell, address assetToReceive, uint256 minAmountToReceive) internal returns (uint256) {\\r\\n        // pre-requirements\\r\\n        uint256 amountToSell = _getBalance(address(this), assetToSell);\\r\\n        assert(minAmountToReceive > 0);\\r\\n\\r\\n        IUniswapV3SwapRouter.ExactInputSingleParams memory swapParams;\\r\\n        swapParams.tokenIn = assetToSell;\\r\\n        swapParams.tokenOut = assetToReceive;\\r\\n        swapParams.fee = _findBestPoolFee(assetToSell, assetToReceive);\\r\\n        swapParams.recipient = address(this);\\r\\n        swapParams.deadline = block.timestamp;\\r\\n        swapParams.amountIn = amountToSell;\\r\\n        swapParams.amountOutMinimum = minAmountToReceive;\\r\\n        swapParams.sqrtPriceLimitX96 = 0; // 0 to ensure we swap our exact input amount\\r\\n\\r\\n        require(EIP20Interface(assetToSell).approve(address(SWAP_ROUTER), amountToSell), \\\"Liquidator: exchange tokens approve failed\\\");\\r\\n        uint256 amountOut = SWAP_ROUTER.exactInputSingle(swapParams);\\r\\n\\r\\n        // post-requirements\\r\\n        assert(amountOut >= minAmountToReceive);\\r\\n        assert(_getBalance(address(this), assetToReceive) >= minAmountToReceive);\\r\\n\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    /// @return amount sold\\r\\n    function _exchangeTokensForExactAmount(address assetToSell, address assetToReceive, uint256 amountToReceive, uint256 amountInMaximum) internal returns (uint256) {\\r\\n        // pre-requirements\\r\\n        assert(amountToReceive > 0);\\r\\n\\r\\n        IUniswapV3SwapRouter.ExactOutputSingleParams memory swapParams;\\r\\n        swapParams.tokenIn = assetToSell;\\r\\n        swapParams.tokenOut = assetToReceive;\\r\\n        swapParams.fee = _findBestPoolFee(assetToSell, assetToReceive);\\r\\n        swapParams.recipient = address(this);\\r\\n        swapParams.deadline = block.timestamp;\\r\\n        swapParams.amountOut = amountToReceive;\\r\\n        swapParams.amountInMaximum = amountInMaximum;\\r\\n        swapParams.sqrtPriceLimitX96 = 0; // 0 to ensure we swap our exact input amount\\r\\n\\r\\n        require(EIP20Interface(assetToSell).approve(address(SWAP_ROUTER), amountInMaximum), \\\"Liquidator: exchange tokens approve failed\\\");\\r\\n        uint256 amountIn = SWAP_ROUTER.exactOutputSingle(swapParams);\\r\\n\\r\\n        // post-requirements\\r\\n        assert(amountIn <= amountInMaximum);\\r\\n        assert(_getBalance(address(this), assetToReceive) >= amountToReceive);\\r\\n\\r\\n        return amountIn;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Maximillion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PToken/PEther/PEther.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus Maximillion Contract\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract Maximillion {\\r\\n    /// @notice The default pEther market to repay in\\r\\n    PEther public pEther;\\r\\n\\r\\n    /// @notice Construct a Maximillion to repay max in a PEther market\\r\\n    constructor(PEther pEther_) public {\\r\\n        pEther = pEther_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice msg.sender sends Ether to repay an account's borrow in the pEther market\\r\\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\\r\\n     * @param borrower The address of the borrower account to repay on behalf of\\r\\n     */\\r\\n    function repayBehalf(address borrower) external payable {\\r\\n        repayBehalfExplicit(borrower, pEther);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice msg.sender sends Ether to repay an account's borrow in a pEther market\\r\\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\\r\\n     * @param borrower The address of the borrower account to repay on behalf of\\r\\n     * @param pEther_ The address of the pEther contract to repay in\\r\\n     */\\r\\n    function repayBehalfExplicit(address borrower, PEther pEther_) public payable {\\r\\n        uint received = msg.value;\\r\\n        uint borrows = pEther_.borrowBalanceCurrent(borrower);\\r\\n\\r\\n        if (received > borrows) {\\r\\n            pEther_.repayBorrowBehalf.value(borrows)(borrower);\\r\\n            (bool success, ) = msg.sender.call.value(received - borrows)(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed\\\");\\r\\n        } else {\\r\\n            pEther_.repayBorrowBehalf.value(received)(borrower);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/AaveMocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Interfaces/AaveInterfaces.sol\\\";\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\n\\r\\ncontract AavePoolMock is AaveIPool {\\r\\n    function flashLoanSimple(address receiverAddress, address asset, uint256 amount, bytes calldata params, uint16 /*referralCode*/) external {\\r\\n        uint256 fee = uint256(10) ** EIP20Interface(asset).decimals(); // 1 token\\r\\n        require(EIP20Interface(asset).transfer(receiverAddress, amount), \\\"transfer failed\\\");\\r\\n        AaveIFlashLoanSimpleReceiver(receiverAddress).executeOperation(asset, amount, fee, tx.origin, params);\\r\\n        require(EIP20Interface(asset).transferFrom(receiverAddress, address(this), amount + fee), \\\"transferFrom failed\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract AavePoolAddressesProviderMock is AaveIPoolAddressesProvider {\\r\\n    AaveIPool public poolMock;\\r\\n\\r\\n    constructor() public {\\r\\n        poolMock = new AavePoolMock();\\r\\n    }\\r\\n\\r\\n    function getPool() external view returns (address) {\\r\\n        return address(poolMock);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/Api3Mocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Interfaces/Api3Interfaces.sol\\\";\\r\\n\\r\\ncontract Api3DapiServerMock /* is Api3IDapiServer */ {\\r\\n    int224 valueMock;\\r\\n    uint32 timestampMock;\\r\\n\\r\\n    constructor(int224 _valueMock, uint32 _timestampMock) public {\\r\\n        valueMock = _valueMock;\\r\\n        timestampMock = _timestampMock;\\r\\n    }\\r\\n\\r\\n    function readDataFeedWithDapiName(bytes32 /* dapiName */) external view returns (int224 value, uint32 timestamp) {\\r\\n        return (valueMock, timestampMock);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/ComptrollerMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Comptroller/ComptrollerNFTPart1.sol\\\";\\r\\nimport \\\"../Comptroller/ComptrollerNFTPart2.sol\\\";\\r\\n\\r\\ncontract ComptrollerMockBase is ComptrollerNFTPart1, ComptrollerNFTPart2 {\\r\\n    constructor() public { }\\r\\n\\r\\n    function isComptroller() external pure returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract AllowingComptrollerMock is ComptrollerMockBase { // Comptroller with no business restrictions\\r\\n    function mintAllowed(address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function mintNFTAllowed(address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function mintVerify(address, address, uint, uint) external { }\\r\\n    function mintNFTVerify(address, address, uint) external { }\\r\\n    function redeemVerify(address, address, uint, uint) external { }\\r\\n    function redeemNFTVerify(address, address, uint) external { }\\r\\n    function borrowVerify(address, address, uint) external { }\\r\\n    function transferVerify(address, address, address, uint) external { }\\r\\n    function transferNFTVerify(address, address, address, uint) external { }\\r\\n    function redeemAllowed(address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function redeemNFTAllowed(address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function borrowAllowed(address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function transferAllowed(address, address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function transferNFTAllowed(address, address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function repayBorrowAllowed(address, address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function repayBorrowVerify(address, address, address, uint, uint) external { }\\r\\n    function liquidateBorrowVerify(address, address, address, address, uint, uint) external { }\\r\\n    function seizeAllowed(address, address, address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function liquidateNFTCollateralAllowed(address, address, address, uint, address) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function seizeVerify(address, address, address, address, uint) external { }\\r\\n    function liquidateBorrowAllowed(address, address, address, address, uint) external returns (uint) { return uint(Error.NO_ERROR); }\\r\\n    function liquidateNFTCollateralVerify(address, address, address, uint) external { }\\r\\n}\\r\\n\\r\\ncontract DenyingComptrollerMock is ComptrollerMockBase {\\r\\n    function mintAllowed(address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n    function mintVerify(address, address, uint, uint) external { }\\r\\n    function redeemVerify(address, address, uint, uint) external { }\\r\\n    function borrowVerify(address, address, uint) external { }\\r\\n    function transferVerify(address, address, address, uint) external { }\\r\\n    function redeemAllowed(address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n    function borrowAllowed(address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n    function transferAllowed(address, address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n    function repayBorrowAllowed(address, address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n    function repayBorrowVerify(address, address, address, uint, uint) external { }\\r\\n    function liquidateBorrowVerify(address, address, address, address, uint, uint) external { }\\r\\n    function seizeAllowed(address, address, address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n    function seizeVerify(address, address, address, address, uint) external { }\\r\\n    function liquidateBorrowAllowed(address, address, address, address, uint) external returns (uint) { return uint(Error.REJECTION); }\\r\\n}\\r\\n\\r\\ncontract ComptrollerStorageV2Mock is ComptrollerNFTStorage {\\r\\n    int foo;\\r\\n    int bar;\\r\\n}\\r\\n\\r\\ncontract ComptrollerPart1V2Mock is ComptrollerStorageV2Mock, ComptrollerNFTPart1 {\\r\\n    function getFoo() external view returns (int) {\\r\\n        return foo;\\r\\n    }\\r\\n\\r\\n    function setFoo(int _foo) external {\\r\\n        foo = _foo;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ComptrollerPart2V2Mock is ComptrollerStorageV2Mock, ComptrollerNFTPart2 {\\r\\n    function getBar() external view returns (int) {\\r\\n        return bar;\\r\\n    }\\r\\n\\r\\n    function setBar(int _bar) external {\\r\\n        bar = _bar;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ComptrollerV2Interface is ComptrollerPart1V2Mock, ComptrollerPart2V2Mock { }\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/ERC721ReceiverMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Interfaces/IERC721Receiver.sol\\\";\\r\\n\\r\\ncontract ERC721ReceiverMock is IERC721Receiver {\\r\\n    enum Error {\\r\\n        None,\\r\\n        RevertWithMessage,\\r\\n        RevertWithoutMessage,\\r\\n        Panic\\r\\n    }\\r\\n\\r\\n    bytes4 private _retval;\\r\\n    Error private _error;\\r\\n\\r\\n    event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\\r\\n\\r\\n    constructor(bytes4 retval, Error error) public {\\r\\n        _retval = retval;\\r\\n        _error = error;\\r\\n    }\\r\\n\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4) {\\r\\n        if (_error == Error.RevertWithMessage) {\\r\\n            revert(\\\"ERC721ReceiverMock: reverting\\\");\\r\\n        } else if (_error == Error.RevertWithoutMessage) {\\r\\n            revert();\\r\\n        } else if (_error == Error.Panic) {\\r\\n            uint256 a = uint256(0) / uint256(0);\\r\\n            a;\\r\\n        }\\r\\n        emit Received(operator, from, tokenId, data, gasleft());\\r\\n        return _retval;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NonReceiverMock { }\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/LiquidatorMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../Liquidator.sol\\\";\\r\\n\\r\\ncontract LiquidatorMock is Liquidator {\\r\\n    constructor(address provider, address swapRouter) public Liquidator(provider, swapRouter) { }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/NFTXMocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Interfaces/NFTXInterfaces.sol\\\";\\r\\nimport \\\"../Interfaces/EIP20NonStandardInterface.sol\\\";\\r\\n\\r\\ncontract NFTXVaultMock is INFTXVault {\\r\\n    address public assetAddressMock;\\r\\n\\r\\n    constructor(address _assetAddress) public {\\r\\n        assetAddressMock = _assetAddress;\\r\\n    }\\r\\n\\r\\n    function assetAddress() external view returns (address) {\\r\\n        return assetAddressMock;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NFTXVaultFactoryMock is INFTXVaultFactory {\\r\\n    mapping(uint => INFTXVault) public vaultIdToNFTAsset;\\r\\n\\r\\n    function vault(uint256 vaultId) external view returns (address) {\\r\\n        return address(vaultIdToNFTAsset[vaultId]);\\r\\n    }\\r\\n\\r\\n    function setNFTAsset(uint vaultId, address nftAssetAddress) public {\\r\\n        vaultIdToNFTAsset[vaultId] = new NFTXVaultMock(nftAssetAddress);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NFTXMarketplaceZapMock is INFTXMarketplaceZap {\\r\\n    address public cryptoPunksAddress;\\r\\n    NFTXVaultFactoryMock public nftxFactoryMock;\\r\\n\\r\\n    constructor(address _cryptoPunksAddress, address _nftxFactory) public {\\r\\n        cryptoPunksAddress = _cryptoPunksAddress;\\r\\n        nftxFactoryMock = NFTXVaultFactoryMock(_nftxFactory);\\r\\n    }\\r\\n\\r\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\\r\\n        return this.onERC721Received.selector;\\r\\n    }\\r\\n\\r\\n    function nftxFactory() external view returns (INFTXVaultFactory) {\\r\\n        return nftxFactoryMock;\\r\\n    }\\r\\n\\r\\n    function mintAndSell721(uint256, uint256[] calldata, uint256, address[] calldata, address) external { revert(\\\"not implemented\\\"); }\\r\\n    function mintAndSell1155(uint256, uint256[] calldata, uint256[] calldata, uint256, address[] calldata, address) external { revert(\\\"not implemented\\\"); }\\r\\n    function mintAndSell1155WETH(uint256, uint256[] calldata, uint256[] calldata, uint256, address[] calldata, address) external { revert(\\\"not implemented\\\"); }\\r\\n\\r\\n    function mintAndSell721WETH(uint256 vaultId, uint256[] calldata ids, uint256 minWethOut, address[] calldata path, address to) external {\\r\\n        address assetOut = path[path.length - 1];\\r\\n\\r\\n        address nftAssetAddress = INFTXVault(nftxFactoryMock.vault(vaultId)).assetAddress();\\r\\n        uint256 length = ids.length;\\r\\n\\r\\n        for (uint256 i; i < length; ++i) {\\r\\n            _transferFromERC721(nftAssetAddress, ids[i]);\\r\\n        }\\r\\n\\r\\n        uint256 extra = ((minWethOut / 21) * 20) / 4; // magic here, do not touch\\r\\n        EIP20NonStandardInterface(assetOut).transfer(to, minWethOut + extra);\\r\\n    }\\r\\n\\r\\n    function _transferFromERC721(address assetAddr, uint256 tokenId) internal {\\r\\n        bytes memory data;\\r\\n\\r\\n        if (assetAddr == cryptoPunksAddress) {\\r\\n            data = abi.encodeWithSignature(\\\"buyPunk(uint256)\\\", tokenId);\\r\\n        } else {\\r\\n            data = abi.encodeWithSignature(\\\"safeTransferFrom(address,address,uint256)\\\", msg.sender, address(this), tokenId);\\r\\n        }\\r\\n\\r\\n        (bool success, bytes memory resultData) = address(assetAddr).call(data);\\r\\n        require(success, string(resultData));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/PBXRewardClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Comptroller/ComptrollerInterfaces.sol\\\";\\r\\n\\r\\n// the whole point of this contract is to be able to call PBXAccrued() and claimPBXReward() in the same block for testing purposes\\r\\ncontract PBXRewardClaimer {\\r\\n    ComptrollerNoNFTInterface comptroller;\\r\\n    EIP20Interface PBXToken;\\r\\n\\r\\n    event passed();\\r\\n    event failure(uint a, uint b, string str);\\r\\n\\r\\n    constructor(address _comptroller) public {\\r\\n        comptroller = ComptrollerNoNFTInterface(_comptroller);\\r\\n        PBXToken = EIP20Interface(comptroller.PBXToken());\\r\\n    }\\r\\n\\r\\n    function testClaimPBX(address holder, uint expectedReward) public {\\r\\n        uint startingBalance = PBXToken.balanceOf(holder);\\r\\n        uint PBXAccrued = comptroller.PBXAccrued(holder);\\r\\n        comptroller.claimPBXReward(holder);\\r\\n        uint PBXTransferred = PBXToken.balanceOf(holder) - startingBalance;\\r\\n\\r\\n        if (PBXTransferred != expectedReward) {\\r\\n            emit failure(PBXTransferred, expectedReward, \\\"PBXTransferred != expectedReward\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (PBXTransferred != PBXAccrued) {\\r\\n            emit failure(PBXTransferred, PBXAccrued, \\\"PBXTransferred != PBXAccrued\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (comptroller.PBXAccrued(holder) != 0) {\\r\\n            emit failure(comptroller.PBXAccrued(holder), 0, \\\"comptroller.PBXAccrued(holder) != 0\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        comptroller.claimPBXReward(holder);\\r\\n\\r\\n        if (PBXToken.balanceOf(holder) != PBXAccrued + startingBalance) {\\r\\n            emit failure(PBXToken.balanceOf(holder), PBXAccrued + startingBalance, \\\"PBXToken.balanceOf(holder) != PBXAccrued + startingBalance\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        emit passed();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/PriceOracleMocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PriceOracle/Impl/ChainlinkPriceOracle.sol\\\";\\r\\nimport \\\"../PriceOracle/Impl/NFTPriceOracle.sol\\\";\\r\\nimport \\\"../PriceOracle/Impl/Api3PriceOracle.sol\\\";\\r\\n\\r\\ncontract ChainlinkPriceOracleMock is ChainlinkPriceOracle, NFTPriceOracle {\\r\\n    constructor(address pwbtcDataFeed, address pethDataFeed, address wbtcAddress, address wethAddress, address stablecoinAddress, uint256 stablecoinPrice, address pethAddress) public {\\r\\n        chainlinkDataFeeds[wbtcAddress] = pwbtcDataFeed;\\r\\n        chainlinkDataFeeds[wethAddress] = pethDataFeed;\\r\\n        chainlinkDataFeeds[address(0)] = pethDataFeed;\\r\\n        stablecoinsPrices[stablecoinAddress] = stablecoinPrice;\\r\\n        pEtherAddress = pethAddress;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Api3PriceOracleMock is Api3PriceOracle, NFTPriceOracle {\\r\\n    constructor(address _api3DapiServer, address wbtcAddress) public {\\r\\n        api3DapiServer = _api3DapiServer;\\r\\n        api3DataFeedNames[wbtcAddress] = \\\"WBTC/USD\\\";\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/PTokenMocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PNFTToken/PErc721/PErc721Delegate.sol\\\";\\r\\nimport \\\"../PToken/PErc20/PErc20Delegate.sol\\\";\\r\\nimport \\\"../PToken/PEther/PEtherDelegate.sol\\\";\\r\\n\\r\\ncontract PNFTTokenStorageV2Mock is PNFTTokenStorage {\\r\\n    int foo;\\r\\n    int bar;\\r\\n}\\r\\n\\r\\ncontract PErc721DelegateV2Mock is PErc721Delegate, PNFTTokenStorageV2Mock { // that EXACT inheritance order is CRUCIAL here\\r\\n    function getBar() external view returns (int) {\\r\\n        return bar;\\r\\n    }\\r\\n\\r\\n    function setBar(int _bar) external {\\r\\n        bar = _bar;\\r\\n    }\\r\\n\\r\\n    function getFoo() external view returns (int) {\\r\\n        return foo;\\r\\n    }\\r\\n\\r\\n    function setFoo(int _foo) external {\\r\\n        foo = _foo;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PTokenStorageV2Mock is PTokenStorage {\\r\\n    int foo;\\r\\n    int bar;\\r\\n}\\r\\n\\r\\ncontract PErc20DelegateV2Mock is PErc20Delegate, PTokenStorageV2Mock { // that EXACT inheritance order is CRUCIAL here\\r\\n    function getBar() external view returns (int) {\\r\\n        return bar;\\r\\n    }\\r\\n\\r\\n    function setBar(int _bar) external {\\r\\n        bar = _bar;\\r\\n    }\\r\\n\\r\\n    function getFoo() external view returns (int) {\\r\\n        return foo;\\r\\n    }\\r\\n\\r\\n    function setFoo(int _foo) external {\\r\\n        foo = _foo;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PEtherStorageV2Mock is PTokenStorage {\\r\\n    int foo;\\r\\n    int bar;\\r\\n}\\r\\n\\r\\ncontract PEtherDelegateV2Mock is PEtherDelegate, PEtherStorageV2Mock { // that EXACT inheritance order is CRUCIAL here\\r\\n    function getBar() external view returns (int) {\\r\\n        return bar;\\r\\n    }\\r\\n\\r\\n    function setBar(int _bar) external {\\r\\n        bar = _bar;\\r\\n    }\\r\\n\\r\\n    function getFoo() external view returns (int) {\\r\\n        return foo;\\r\\n    }\\r\\n\\r\\n    function setFoo(int _foo) external {\\r\\n        foo = _foo;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/UniswapV2Mocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity >=0.5.16;\\r\\n\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\n\\r\\ncontract UniswapV2FactoryMock /*is IUniswapV2Factory*/ {\\r\\n\\r\\n}\\r\\n\\r\\ncontract UniswapV2Router02Mock /*is IUniswapV2Router02*/ {\\r\\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint /*deadline*/) external returns (uint[] memory) {\\r\\n        require(path.length == 2, \\\"not supported\\\");\\r\\n        address assetIn = path[0];\\r\\n        address assetOut = path[path.length - 1];\\r\\n        require(EIP20Interface(assetIn).transferFrom(msg.sender, address(this), amountIn), \\\"transferFrom failed\\\");\\r\\n        uint256 extra = 10 * uint256(10) ** EIP20Interface(assetOut).decimals();\\r\\n        require(EIP20Interface(assetOut).transfer(to, amountOutMin + extra), \\\"transfer failed\\\"); // amountOutMin + 10 tokens\\r\\n        uint[] memory result = new uint[](1);\\r\\n        result[0] = amountOutMin + extra;\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mocks/UniswapV3Mocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity >=0.5.16;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\nimport \\\"../Interfaces/UniswapV3Interfaces.sol\\\";\\r\\n\\r\\ncontract UniswapV3PoolMock is IUniswapV3Pool {\\r\\n    uint160 priceMock;\\r\\n    uint128 liquidityMock;\\r\\n    constructor(uint160 _priceMock, uint128 _liquidityMock) public {\\r\\n        priceMock = _priceMock;\\r\\n        liquidityMock = _liquidityMock;\\r\\n    }\\r\\n    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool) {\\r\\n        return (priceMock, 0, 0, 0, 0, 0, false);\\r\\n    }\\r\\n\\r\\n    function liquidity() external view returns (uint128) {\\r\\n        return liquidityMock;\\r\\n    }\\r\\n\\r\\n    function token0() external view returns (address) { revert(\\\"not implemented\\\"); }\\r\\n    function token1() external view returns (address) { revert(\\\"not implemented\\\"); }\\r\\n}\\r\\n\\r\\ncontract UniswapV3FactoryMock is IUniswapV3Factory {\\r\\n    UniswapV3PoolMock public poolMock;\\r\\n    UniswapV3PoolMock public emptyPoolMock;\\r\\n\\r\\n    constructor() public {\\r\\n        poolMock = new UniswapV3PoolMock(42, 42);\\r\\n        emptyPoolMock = new UniswapV3PoolMock(0, 0);\\r\\n    }\\r\\n\\r\\n    function getPool(address /*tokenA*/, address /*tokenB*/, uint24 fee) external view returns (address) {\\r\\n        if (fee == 3000) return address(0);\\r\\n        if (fee == 500) return address(emptyPoolMock);\\r\\n        else return address(poolMock);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract UniswapV3SwapRouterMock is IUniswapV3SwapRouter {\\r\\n    IUniswapV3Factory public factoryMock;\\r\\n\\r\\n    constructor() public {\\r\\n        factoryMock = new UniswapV3FactoryMock();\\r\\n    }\\r\\n\\r\\n    function factory() external returns (address) {\\r\\n        return address(factoryMock);\\r\\n    }\\r\\n\\r\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256) {\\r\\n        uint256 extra = 10 * uint256(10) ** EIP20Interface(params.tokenOut).decimals(); // 10 tokens\\r\\n        require(EIP20Interface(params.tokenIn).transferFrom(msg.sender, address(this), params.amountIn), \\\"transferFrom failed\\\");\\r\\n        require(EIP20Interface(params.tokenOut).transfer(params.recipient, params.amountOutMinimum + extra), \\\"transfer failed\\\");\\r\\n        return params.amountOutMinimum + extra;\\r\\n    }\\r\\n\\r\\n    function exactInput(ExactInputParams calldata) external payable returns (uint256) { revert(\\\"not implemented\\\"); }\\r\\n\\r\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256) {\\r\\n        require(EIP20Interface(params.tokenIn).transferFrom(msg.sender, address(this), params.amountInMaximum - 100), \\\"transferFrom failed\\\");\\r\\n        require(EIP20Interface(params.tokenOut).transfer(params.recipient, params.amountOut), \\\"transfer failed\\\");\\r\\n        return params.amountInMaximum - 100;\\r\\n    }\\r\\n\\r\\n    function exactOutput(ExactOutputParams calldata) external payable returns (uint256) { revert(\\\"not implemented\\\"); }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PCryptoPunks/PCryptoPunks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PNFTToken.sol\\\";\\r\\nimport \\\"../../Interfaces/CryptoPunksMarketInterface.sol\\\";\\r\\nimport \\\"../../Interfaces/NFTXInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PCryptoPunks Contract\\r\\n * @notice PNFTTokens which wrap the CryptoPunks collection underlying\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PCryptoPunks is PNFTToken {\\r\\n    /**\\r\\n     * @notice Initialize the new money market\\r\\n     * @param underlying_ The CryptoPunks collection address\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param name_ ERC-721 name of this token\\r\\n     * @param symbol_ ERC-721 symbol of this token\\r\\n     */\\r\\n    function initialize(address underlying_,\\r\\n        address comptroller_,\\r\\n        string memory name_,\\r\\n        string memory symbol_) public {\\r\\n        // PToken initialize does the bulk of the work\\r\\n        super.initialize(underlying_, comptroller_, name_, symbol_);\\r\\n\\r\\n        // Sanity check underlying\\r\\n        CryptoPunksMarketInterface(underlying).imageHash();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying tokens owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view returns (uint) {\\r\\n        return CryptoPunksMarketInterface(underlying).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function approveUnderlying(uint256 tokenId, address addr) internal {\\r\\n        CryptoPunksMarketInterface(underlying).offerPunkForSaleToAddress(tokenId, 0, addr);\\r\\n    }\\r\\n\\r\\n    function checkIfOwnsUnderlying(uint tokenId) internal view returns (bool) {\\r\\n        return CryptoPunksMarketInterface(underlying).punkIndexToAddress(tokenId) == address(this);\\r\\n    }\\r\\n\\r\\n    function doTransferIn(address /* from */, uint tokenId) internal { // underlying transfer in\\r\\n        CryptoPunksMarketInterface(underlying).buyPunk.value(0)(tokenId);\\r\\n        assert(checkIfOwnsUnderlying(tokenId));\\r\\n    }\\r\\n\\r\\n    function doTransferOut(address to, uint tokenId) internal { // underlying transfer out\\r\\n        CryptoPunksMarketInterface token = CryptoPunksMarketInterface(underlying);\\r\\n        token.transferPunk(to, tokenId);\\r\\n        assert(token.punkIndexToAddress(tokenId) == to);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PCryptoPunks/PCryptopunksDelegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PCryptoPunks.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PCryptopunksDelegate Contract\\r\\n * @notice PCryptoPunksDelegate which wrap the CryptoPunks underlying and are delegated to\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PCryptoPunksDelegate is PCryptoPunks, PNFTTokenDelegateInterface {\\r\\n    /// @notice Construct an empty delegate\\r\\n    constructor() public { }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty. Should not be marked as pure\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes calldata data) external {\\r\\n        data; // Shh -- currently unused\\r\\n        require(msg.sender == admin, \\\"only the admin may call _becomeImplementation\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Called by the delegator on a delegate to forfeit its responsibility. Should not be marked as pure\\r\\n    function _resignImplementation() external {\\r\\n        require(msg.sender == admin, \\\"only the admin may call _resignImplementation\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PCryptoPunks/PCryptoPunksImmutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PCryptoPunks.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PCryptoPunksImmutable Contract\\r\\n * @notice PNFTTokens which wrap the CryptoPunks collection underlying and are immutable\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PCryptoPunksImmutable is PCryptoPunks {\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param underlying_ The CryptoPunks collection address\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param name_ ERC-721 name of this token\\r\\n     * @param symbol_ ERC-721 symbol of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     */\\r\\n    constructor(address underlying_,\\r\\n                address comptroller_,\\r\\n                string memory name_,\\r\\n                string memory symbol_,\\r\\n                address payable admin_) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // Initialize the market\\r\\n        initialize(underlying_, comptroller_, name_, symbol_);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PErc721/PErc721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PNFTToken.sol\\\";\\r\\nimport \\\"../../Interfaces/IERC721.sol\\\";\\r\\nimport \\\"../../Interfaces/NFTXInterfaces.sol\\\";\\r\\nimport \\\"../../Interfaces/SudoswapInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc721 Contract\\r\\n * @notice PNFTTokens which wrap an EIP-721 underlying\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PErc721 is PNFTToken, PErc721Interface {\\r\\n    /**\\r\\n     * @notice Initialize the new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param name_ ERC-721 name of this token\\r\\n     * @param symbol_ ERC-721 symbol of this token\\r\\n     */\\r\\n    function initialize(address underlying_,\\r\\n        address comptroller_,\\r\\n        string memory name_,\\r\\n        string memory symbol_) public {\\r\\n        // Sanity check underlying\\r\\n        require(underlying_ != address(0) && IERC721(underlying_).balanceOf(address(this)) >= 0);\\r\\n\\r\\n        // PToken initialize does the bulk of the work\\r\\n        super.initialize(underlying_, comptroller_, name_, symbol_);\\r\\n    }\\r\\n\\r\\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4) {\\r\\n        assert(msg.sender == underlying);\\r\\n        return this.onERC721Received.selector;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying tokens owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view returns (uint) {\\r\\n        return IERC721(underlying).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function approveUnderlying(uint256 tokenId, address addr) internal {\\r\\n        IERC721(underlying).approve(address(addr), tokenId);\\r\\n    }\\r\\n\\r\\n    function checkIfOwnsUnderlying(uint tokenId) internal view returns (bool) {\\r\\n        return IERC721(underlying).ownerOf(tokenId) == address(this);\\r\\n    }\\r\\n\\r\\n    function doTransferIn(address from, uint tokenId) internal { // underlying transfer in\\r\\n        IERC721(underlying).safeTransferFrom(from, address(this), tokenId);\\r\\n        assert(checkIfOwnsUnderlying(tokenId));\\r\\n    }\\r\\n\\r\\n    function doTransferOut(address to, uint tokenId) internal { // underlying transfer out\\r\\n        IERC721 token = IERC721(underlying);\\r\\n        token.safeTransferFrom(address(this), to, tokenId);\\r\\n        assert(token.ownerOf(tokenId) == to);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PErc721/PErc721Delegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PErc721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc721Delegate Contract\\r\\n * @notice PErc721Tokens which wrap an EIP-721 underlying and are delegated to\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PErc721Delegate is PErc721, PNFTTokenDelegateInterface {\\r\\n    /// @notice Construct an empty delegate\\r\\n    constructor() public { }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty. Should not be marked as pure\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes calldata data) external {\\r\\n        data; // Shh -- currently unused\\r\\n        require(msg.sender == admin, \\\"only the admin may call _becomeImplementation\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Called by the delegator on a delegate to forfeit its responsibility. Should not be marked as pure\\r\\n    function _resignImplementation() external {\\r\\n        require(msg.sender == admin, \\\"only the admin may call _resignImplementation\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PErc721/PErc721Immutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PErc721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc721Immutable Contract\\r\\n * @notice PErc721Tokens which wrap an EIP-721 underlying and are immutable\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PErc721Immutable is PErc721 {\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param name_ ERC-721 name of this token\\r\\n     * @param symbol_ ERC-721 symbol of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     */\\r\\n    constructor(address underlying_,\\r\\n                address comptroller_,\\r\\n                string memory name_,\\r\\n                string memory symbol_,\\r\\n                address payable admin_) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // Initialize the market\\r\\n        initialize(underlying_, comptroller_, name_, symbol_);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PNFTToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Comptroller/ComptrollerInterfaces.sol\\\";\\r\\nimport \\\"./PNFTTokenInterfaces.sol\\\";\\r\\nimport \\\"../PToken/PTokenInterfaces.sol\\\";\\r\\nimport \\\"../ErrorReporter.sol\\\";\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\nimport \\\"../Interfaces/IERC721Receiver.sol\\\";\\r\\nimport \\\"../Utils/ExponentialNoError.sol\\\";\\r\\nimport \\\"../Interfaces/NFTXInterfaces.sol\\\";\\r\\nimport \\\"../Interfaces/SudoswapInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PNFTToken Contract\\r\\n * @notice Abstract base for PNFTTokens\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PNFTToken is PNFTTokenInterface, ExponentialNoError, TokenErrorReporter {\\r\\n    /**\\r\\n     * @notice Initialize the money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param name_ EIP-721 name of this token\\r\\n     * @param symbol_ EIP-721 symbol of this token\\r\\n     */\\r\\n    function initialize(address underlying_,\\r\\n        address comptroller_,\\r\\n        string memory name_,\\r\\n        string memory symbol_) public {\\r\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\r\\n\\r\\n        // Set the comptroller\\r\\n        _setComptroller(comptroller_);\\r\\n\\r\\n        name = name_;\\r\\n        symbol = symbol_;\\r\\n        underlying = underlying_;\\r\\n\\r\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /*** ERC165 Functions ***/\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\r\\n        return interfaceId == 0x80ac58cd || // _INTERFACE_ID_ERC721\\r\\n               interfaceId == 0x01ffc9a7 || // _INTERFACE_ID_ERC165\\r\\n               interfaceId == 0x780e9d63;   // _INTERFACE_ID_ERC721_ENUMERABLE\\r\\n    }\\r\\n\\r\\n    /*** EIP721 Functions ***/\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted (`_mint`),\\r\\n     * and stop existing when they are burned (`_burn`).\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\r\\n        return tokensOwners[tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n        uint size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {size := extcodesize(account)}\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\r\\n     * The call is not executed if the target address is not a contract.\\r\\n     *\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param to target address that will receive the tokens\\r\\n     * @param tokenId The token ID\\r\\n     * @param _data bytes optional data to send along with the call\\r\\n     * @return bool whether the call correctly returned the expected magic value\\r\\n     */\\r\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\\r\\n        if (!isContract(to))\\r\\n            return true;\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\\r\\n                IERC721Receiver(to).onERC721Received.selector,\\r\\n                msg.sender,\\r\\n                from,\\r\\n                tokenId,\\r\\n                _data\\r\\n            ));\\r\\n\\r\\n        if (!success) {\\r\\n            if (returndata.length > 0) {\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(\\\"transfer to non ERC721Receiver implementer\\\");\\r\\n            }\\r\\n        } else {\\r\\n            bytes4 retval = abi.decode(returndata, (bytes4));\\r\\n            bytes4 _ERC721_RECEIVED = 0x150b7a02; // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n            return (retval == _ERC721_RECEIVED);\\r\\n        }\\r\\n\\r\\n        return false; // shut up\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the list of token IDs of the requested owner.\\r\\n     * @param owner address owning the tokens\\r\\n     * @return uint256[] List of token IDs owned by the requested address\\r\\n     */\\r\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\r\\n        return ownedTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\r\\n     * @param to address representing the new owner of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n     */\\r\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\r\\n        ownedTokensIndex[tokenId] = ownedTokens[to].length;\\r\\n        ownedTokens[to].push(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\r\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\r\\n     */\\r\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\r\\n        allTokensIndex[tokenId] = allTokens.length;\\r\\n        allTokens.push(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\r\\n     * while the token is not assigned a new owner, the ownedTokensIndex mapping is _not_ updated: this allows for\\r\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\r\\n     * This has O(1) time complexity, but alters the order of the ownedTokens array.\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n     */\\r\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\r\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\r\\n        // then delete the last slot (swap and pop).\\r\\n\\r\\n        uint256 lastTokenIndex = sub_(ownedTokens[from].length, 1);\\r\\n        uint256 tokenIndex = ownedTokensIndex[tokenId];\\r\\n\\r\\n        // When the token to delete is the last token, the swap operation is unnecessary\\r\\n        if (tokenIndex != lastTokenIndex) {\\r\\n            uint256 lastTokenId = ownedTokens[from][lastTokenIndex];\\r\\n\\r\\n            ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\r\\n            ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\r\\n        }\\r\\n\\r\\n        // This also deletes the contents at the last position of the array\\r\\n        ownedTokens[from].length--;\\r\\n\\r\\n        // Note that ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\\r\\n        // lastTokenId, or just over the end of the array if the token was the last one).\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\r\\n     * This has O(1) time complexity, but alters the order of the allTokens array.\\r\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\r\\n     */\\r\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\r\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\r\\n        // then delete the last slot (swap and pop).\\r\\n\\r\\n        uint256 lastTokenIndex = sub_(allTokens.length, 1);\\r\\n        uint256 tokenIndex = allTokensIndex[tokenId];\\r\\n\\r\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\r\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\r\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\r\\n        uint256 lastTokenId = allTokens[lastTokenIndex];\\r\\n\\r\\n        allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\r\\n        allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\r\\n\\r\\n        // This also deletes the contents at the last position of the array\\r\\n        allTokens.length--;\\r\\n        allTokensIndex[tokenId] = 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `tokens` tokens from `src` to `dst`\\r\\n     * @dev Called by both `transfer` and `safeTransferInternal` internally\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param tokenId The token ID\\r\\n     */\\r\\n    function transferInternal(address src, address dst, uint tokenId) internal {\\r\\n        require(ownerOf(tokenId) == src, \\\"transfer from incorrect owner\\\");\\r\\n        require(dst != address(0), \\\"transfer to the zero address\\\");\\r\\n\\r\\n        // Fail if transfer not allowed\\r\\n        uint allowed = comptroller.transferNFTAllowed(address(this), src, dst, tokenId);\\r\\n        require(allowed == 0, \\\"COMPTROLLER_REJECTION: TRANSFER_COMPTROLLER_REJECTION\\\");\\r\\n\\r\\n        // Do the calculations, checking for {under,over}flow\\r\\n        uint srcTokensNew = sub_(accountTokens[src], 1);\\r\\n        uint dstTokensNew = add_(accountTokens[dst], 1);\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        approveInternal(address(0), tokenId);\\r\\n\\r\\n        /* Check for self-transfers\\r\\n         * When src == dst, the values srcTokensNew, dstTokensNew are INCORRECT\\r\\n         */\\r\\n        if (src != dst) {\\r\\n            accountTokens[src] = srcTokensNew;\\r\\n            accountTokens[dst] = dstTokensNew;\\r\\n\\r\\n            // Erc721Enumerable\\r\\n            _removeTokenFromOwnerEnumeration(src, tokenId);\\r\\n            _addTokenToOwnerEnumeration(dst, tokenId);\\r\\n        }\\r\\n\\r\\n        tokensOwners[tokenId] = dst;\\r\\n\\r\\n        // We emit a Transfer event\\r\\n        emit Transfer(src, dst, tokenId);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.transferNFTVerify(address(this), src, dst, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param tokenId The token ID\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferFrom(address src, address dst, uint tokenId) external nonReentrant {\\r\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"transfer caller is not owner nor approved\\\");\\r\\n        transferInternal(src, dst, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `src` to `dst`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `src` cannot be the zero address.\\r\\n     * - `dst` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `src`.\\r\\n     * - If the caller is not `src`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `dst` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(address src, address dst, uint256 tokenId) public {\\r\\n        safeTransferFrom(src, dst, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `src` to `dst`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `src` cannot be the zero address.\\r\\n     * - `dst` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `src`.\\r\\n     * - If the caller is not `src`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `dst` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(address src, address dst, uint256 tokenId, bytes memory data) public nonReentrant {\\r\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"transfer caller is not owner nor approved\\\");\\r\\n        safeTransferInternal(src, dst, tokenId, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `src` to `dst`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * `data` is additional data, it has no specified format and it is sent in call to `dst`.\\r\\n     *\\r\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\r\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `src` cannot be the zero address.\\r\\n     * - `dst` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `src`.\\r\\n     * - If `dst` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferInternal(address src, address dst, uint256 tokenId, bytes memory data) internal {\\r\\n        transferInternal(src, dst, tokenId);\\r\\n        require(_checkOnERC721Received(src, dst, tokenId, data), \\\"transfer to non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Returns whether `spender` is allowed to manage `tokenId`.\\r\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\r\\n        require(_exists(tokenId), \\\"operator query for nonexistent token\\\");\\r\\n        address owner = ownerOf(tokenId);\\r\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint tokenId) external {\\r\\n        address owner = ownerOf(tokenId);\\r\\n        require(to != owner, \\\"approval to current owner\\\");\\r\\n\\r\\n        require(\\r\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\r\\n            \\\"approve caller is not owner nor approved for all\\\"\\r\\n        );\\r\\n\\r\\n        approveInternal(to, tokenId);\\r\\n    }\\r\\n\\r\\n    function approveInternal(address to, uint256 tokenId) internal {\\r\\n        transferAllowances[tokenId] = to;\\r\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view returns (address) {\\r\\n        require(_exists(tokenId), \\\"approved query for nonexistent token\\\");\\r\\n        return transferAllowances[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public {\\r\\n        setApprovalForAllInternal(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAllInternal(address owner, address operator, bool approved) internal {\\r\\n        require(owner != operator, \\\"approve to caller\\\");\\r\\n        operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\r\\n        return operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256) {\\r\\n        require(owner != address(0), \\\"address zero is not a valid owner\\\");\\r\\n        return accountTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\r\\n        address owner = tokensOwners[tokenId];\\r\\n        require(owner != address(0), \\\"owner query for nonexistent token\\\");\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\\r\\n     * @param owner address owning the tokens list to be accessed\\r\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\r\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\r\\n     */\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\\r\\n        require(index < this.balanceOf(owner), \\\"owner index out of bounds\\\");\\r\\n        return ownedTokens[owner][index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the total amount of tokens stored by the contract.\\r\\n     * @return uint256 representing the total amount of tokens\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return allTokens.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\r\\n     * Reverts if the index is greater or equal to the total number of tokens.\\r\\n     * @param index uint256 representing the index to be accessed of the tokens list\\r\\n     * @return uint256 token ID at the given index of the tokens list\\r\\n     */\\r\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\r\\n        require(index < totalSupply(), \\\"global index out of bounds\\\");\\r\\n        return allTokens[index];\\r\\n    }\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Get the underlying balance of the `owner`\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The amount of underlying owned by `owner`\\r\\n     */\\r\\n    function balanceOfUnderlying(address owner) external view returns (uint) {\\r\\n        return accountTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to simply retrieve block number\\r\\n     *  This exists mainly for inheriting test contracts to stub this result.\\r\\n     */\\r\\n    function getBlockNumber() internal view returns (uint) {\\r\\n        return block.number;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get cash balance of this pToken in the underlying asset\\r\\n     * @return The quantity of underlying asset owned by this contract\\r\\n     */\\r\\n    function getCash() external view returns (uint) {\\r\\n        return getCashPrior();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives pTokens in exchange\\r\\n     * @param tokenId The token ID\\r\\n     */\\r\\n    function mint(uint tokenId) external {\\r\\n        mintInternal(tokenId);\\r\\n    }\\r\\n\\r\\n    function safeMint(uint256 tokenId) external {\\r\\n        safeMintInternal(tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function safeMint(uint256 tokenId, bytes calldata data) external {\\r\\n        safeMintInternal(tokenId, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives pTokens in exchange\\r\\n     * @param tokenId The token ID\\r\\n     */\\r\\n    function mintInternal(uint tokenId) internal nonReentrant {\\r\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\r\\n        mintFresh(msg.sender, tokenId);\\r\\n    }\\r\\n\\r\\n    function safeMintInternal(uint256 tokenId, bytes memory data) internal {\\r\\n        mintInternal(tokenId);\\r\\n        require(_checkOnERC721Received(address(0), msg.sender, tokenId, data), \\\"transfer to non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User supplies assets into the market and receives pTokens in exchange\\r\\n     * @param minter The address of the account which is supplying the assets\\r\\n     * @param tokenId The token ID\\r\\n     */\\r\\n    function mintFresh(address minter, uint tokenId) internal {\\r\\n        require(minter != address(0), \\\"mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"token already minted\\\");\\r\\n\\r\\n        // Fail if mint not allowed\\r\\n        uint allowed = comptroller.mintNFTAllowed(address(this), minter, tokenId);\\r\\n        require(allowed == 0, \\\"COMPTROLLER_REJECTION: MINT_COMPTROLLER_REJECTION\\\");\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        doTransferIn(minter, tokenId);\\r\\n\\r\\n        /*\\r\\n         * We calculate the new total supply of pTokens and minter token balance, checking for overflow:\\r\\n         *  accountTokensNew = accountTokens[minter] + 1\\r\\n         */\\r\\n\\r\\n        uint accountTokensNew = add_(accountTokens[minter], 1);\\r\\n\\r\\n        // Erc721Enumerable\\r\\n        _addTokenToOwnerEnumeration(minter, tokenId);\\r\\n        _addTokenToAllTokensEnumeration(tokenId);\\r\\n\\r\\n        // We write previously calculated values into storage\\r\\n        accountTokens[minter] = accountTokensNew;\\r\\n        tokensOwners[tokenId] = minter;\\r\\n\\r\\n        // We emit a Mint event, and a Transfer event\\r\\n        emit Mint(minter, tokenId);\\r\\n        emit Transfer(address(0), minter, tokenId);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.mintNFTVerify(address(this), minter, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for the underlying asset\\r\\n     * @param tokenId The token ID\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeem(uint tokenId) external {\\r\\n        return redeemInternal(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for the underlying asset\\r\\n     * @param tokenId The token ID\\r\\n     */\\r\\n    function redeemInternal(uint tokenId) internal nonReentrant {\\r\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\r\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"caller is not owner nor approved\\\");\\r\\n        redeemFresh(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User redeems pTokens in exchange for the underlying asset\\r\\n     * @param tokenId The token ID\\r\\n     */\\r\\n    function redeemFresh(uint tokenId) internal {\\r\\n        address owner = ownerOf(tokenId);\\r\\n\\r\\n        // Fail if redeem not allowed\\r\\n        uint allowed = comptroller.redeemNFTAllowed(address(this), owner, tokenId);\\r\\n        require(allowed == 0, \\\"COMPTROLLER_REJECTION: MINT_COMPTROLLER_REJECTION\\\");\\r\\n\\r\\n        /*\\r\\n         * We calculate the new owner balance, checking for underflow:\\r\\n         *  accountTokensNew = accountTokens[owner] - 1\\r\\n         */\\r\\n\\r\\n        uint accountTokensNew = sub_(accountTokens[owner], 1);\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        // We invoke doTransferOut for the owner\\r\\n        doTransferOut(owner, tokenId);\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        approveInternal(address(0), tokenId);\\r\\n\\r\\n        // Erc721Enumerable\\r\\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\\r\\n        ownedTokensIndex[tokenId] = 0;\\r\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\r\\n\\r\\n        // We write previously calculated values into storage\\r\\n        accountTokens[owner] = accountTokensNew;\\r\\n        tokensOwners[tokenId] = address(0);\\r\\n\\r\\n        // We emit a Transfer event, and a Redeem event\\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n        emit Redeem(owner, tokenId);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.redeemNFTVerify(address(this), owner, tokenId);\\r\\n    }\\r\\n\\r\\n    function liquidateCollateral(address borrower, uint tokenId, address NFTLiquidationExchangePTokenAddress) external returns (uint) {\\r\\n        return liquidateCollateralInternal(msg.sender, borrower, tokenId, NFTLiquidationExchangePTokenAddress, false);\\r\\n    }\\r\\n\\r\\n    function liquidateSeizeCollateral(address borrower, uint tokenId, address NFTLiquidationExchangePTokenAddress) external returns (uint) {\\r\\n        return liquidateCollateralInternal(msg.sender, borrower, tokenId, NFTLiquidationExchangePTokenAddress, true);\\r\\n    }\\r\\n\\r\\n    function liquidateCollateralInternal(address liquidator, address borrower, uint tokenId, address NFTLiquidationExchangePTokenAddress, bool liquidatorSeize) internal nonReentrant returns (uint) { // NFT TODO liquidatorSeize ???\\r\\n        require(ownerOf(tokenId) == borrower, \\\"incorrect borrower\\\");\\r\\n\\r\\n        // Fail if borrower = caller\\r\\n        if (borrower == liquidator) {\\r\\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\\r\\n        }\\r\\n\\r\\n        // Fail if liquidateCollateral not allowed\\r\\n        uint allowed = comptroller.liquidateNFTCollateralAllowed(address(this), liquidator, borrower, tokenId, NFTLiquidationExchangePTokenAddress);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        PErc20Interface NFTLiquidationExchangePToken = PErc20Interface(NFTLiquidationExchangePTokenAddress);\\r\\n\\r\\n        // double-check\\r\\n        (, , uint beforeLiquidityShortfall) = comptroller.getAccountLiquidity(borrower);\\r\\n        assert(beforeLiquidityShortfall > 0);\\r\\n\\r\\n        // liquidate collateral\\r\\n        uint result = liquidateCollateralInternalImpl(liquidator, borrower, tokenId, NFTLiquidationExchangePToken, liquidatorSeize);\\r\\n\\r\\n        // double-check\\r\\n        (, , uint liquidityShortfall) = comptroller.getAccountLiquidity(borrower);\\r\\n        require(beforeLiquidityShortfall >= liquidityShortfall, \\\"invalid liquidity after the exchange\\\");\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function liquidateCollateralInternalImpl(address liquidator, address borrower, uint tokenId, PErc20Interface NFTLiquidationExchangePToken, bool liquidatorSeize) internal returns (uint) { // NFT TODO liquidatorSeize ???\\r\\n        uint256 exchangePTokenBalanceBefore = NFTLiquidationExchangePToken.balanceOf(address(this));\\r\\n        uint liquidationIncentive;\\r\\n        uint pbxBonusIncentive;\\r\\n\\r\\n        if (liquidatorSeize) { // sell underlying NFT to liquidator\\r\\n            uint seizeValueToReceive;\\r\\n            (, liquidationIncentive, pbxBonusIncentive, seizeValueToReceive) = comptroller.nftLiquidateCalculateValues(address(this), tokenId, address(NFTLiquidationExchangePToken));\\r\\n            require(seizeValueToReceive > 0, \\\"liquidateSeizeCollateral not possible\\\");\\r\\n            _exchangeUnderlying(borrower, tokenId, seizeValueToReceive, liquidationIncentive, liquidator, true, NFTLiquidationExchangePToken);\\r\\n        } else { // exchange underlying NFT for NFTLiquidationExchangePToken\\r\\n            uint minAmountToReceiveOnExchange;\\r\\n            (minAmountToReceiveOnExchange, liquidationIncentive, pbxBonusIncentive, ) = comptroller.nftLiquidateCalculateValues(address(this), tokenId, address(NFTLiquidationExchangePToken));\\r\\n            require(minAmountToReceiveOnExchange > 0, \\\"liquidateCollateral not possible\\\");\\r\\n            _exchangeUnderlying(borrower, tokenId, minAmountToReceiveOnExchange, liquidationIncentive, liquidator, false, NFTLiquidationExchangePToken);\\r\\n        }\\r\\n\\r\\n        // send liquidation incentive\\r\\n        // approve already called in _exchangeUnderlying\\r\\n        require(NFTLiquidationExchangePToken.mint(liquidationIncentive) == uint(Error.NO_ERROR), \\\"NFTLiquidationExchangePToken mint incentive failed\\\");\\r\\n        require(NFTLiquidationExchangePToken.transfer(liquidator, NFTLiquidationExchangePToken.balanceOf(address(this)) - exchangePTokenBalanceBefore), \\\"NFTLiquidationExchangePToken transfer incentive failed\\\");\\r\\n\\r\\n        // send PBX bonus liquidation incentive\\r\\n        comptroller.nftLiquidateSendPBXBonusIncentive(pbxBonusIncentive, liquidator);\\r\\n\\r\\n        assert(NFTLiquidationExchangePToken.balanceOf(address(this)) == exchangePTokenBalanceBefore); // double-check\\r\\n\\r\\n        // We emit a LiquidateCollateral event\\r\\n        emit LiquidateCollateral(liquidator, borrower, tokenId, address(NFTLiquidationExchangePToken));  // NFT TODO different events?\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.liquidateNFTCollateralVerify(address(this), liquidator, borrower, tokenId);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function _sellUnderlyingOnSudoswap(uint tokenId, uint minAmountToReceive, PErc20Interface NFTLiquidationExchangePToken) internal {\\r\\n        assert(SudoswapLSSVMPairAddress != address(0));\\r\\n        assert(comptroller.SudoswapPairRouterAddress() != address(0));\\r\\n\\r\\n        LSSVMPairERC20Interface SudoswapLSSVMPair = LSSVMPairERC20Interface(SudoswapLSSVMPairAddress);\\r\\n        EIP20Interface NFTLiquidationExchangeToken = EIP20Interface(NFTLiquidationExchangePToken.underlying());\\r\\n\\r\\n        require(SudoswapLSSVMPair.nft() == underlying, \\\"wrong SudoswapLSSVMPair.nft()\\\");\\r\\n        require(SudoswapLSSVMPair.token() == address(NFTLiquidationExchangeToken), \\\"wrong SudoswapLSSVMPair.token()\\\");\\r\\n\\r\\n        // sell underlying on Sudoswap\\r\\n        bytes memory encodedSig = abi.encodePacked(\\r\\n            bytes4(keccak256(\\\"swapNFTsForToken((address,uint256[])[],uint256,address,uint256)\\\")), // function signature\\r\\n            // function arguments\\r\\n            abi.encodePacked(uint256(128),\\r\\n                             uint256(minAmountToReceive),\\r\\n                             uint256(address(this)),\\r\\n                             uint256(block.timestamp),\\r\\n                             uint256(1),\\r\\n                             uint256(32),\\r\\n                             uint256(SudoswapLSSVMPairAddress),\\r\\n                             uint256(64),\\r\\n                             uint256(1),\\r\\n                             uint256(tokenId))\\r\\n        );\\r\\n\\r\\n        approveUnderlying(tokenId, SudoswapLSSVMPairAddress);\\r\\n\\r\\n        (bool success, bytes memory returnData) = comptroller.SudoswapPairRouterAddress().call(encodedSig);\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                revert(add(returnData, 0x20), returndatasize())\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(abi.decode(returnData, (uint256)) >= minAmountToReceive);\\r\\n    }\\r\\n\\r\\n    function _sellUnderlyingToLiquidator(uint tokenId, uint amountToReceive, address liquidator, PErc20Interface NFTLiquidationExchangePToken) internal {\\r\\n        doErc20TransferIn(NFTLiquidationExchangePToken.underlying(), liquidator, amountToReceive);\\r\\n        doTransferOut(liquidator, tokenId); // NFT TODO transfer PNFTToken instead of underlying?\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\r\\n     *      This will revert due to insufficient balance or insufficient allowance.\\r\\n     *      This function returns the actual amount received,\\r\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\r\\n     *\\r\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\r\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n     */\\r\\n    function doErc20TransferIn(address tokenAddress, address from, uint amount) internal { // NFT TODO ??\\r\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(tokenAddress);\\r\\n        uint balanceBefore = EIP20Interface(tokenAddress).balanceOf(address(this));\\r\\n        token.transferFrom(from, address(this), amount);\\r\\n\\r\\n        bool success;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {                       // This is a non-standard ERC-20\\r\\n                    success := not(0)          // set success to true\\r\\n                }\\r\\n                case 32 {                      // This is a compliant ERC-20\\r\\n                    returndatacopy(0, 0, 32)\\r\\n                    success := mload(0)        // Set `success = returndata` of external call\\r\\n                }\\r\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\r\\n\\r\\n        // Calculate the amount that was *actually* transferred\\r\\n        uint balanceAfter = EIP20Interface(tokenAddress).balanceOf(address(this));\\r\\n        require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\r\\n        require(balanceAfter - balanceBefore == amount); // underflow already checked above, just subtract\\r\\n    }\\r\\n\\r\\n    function _sellUnderlyingOnNFTXio(uint tokenId, uint minAmountToReceive, PErc20Interface NFTLiquidationExchangePToken) internal {\\r\\n        assert(NFTXioVaultId >= 0);\\r\\n        assert(comptroller.NFTXioMarketplaceZapAddress() != address(0));\\r\\n\\r\\n        INFTXMarketplaceZap NFTXioMarketplace = INFTXMarketplaceZap(comptroller.NFTXioMarketplaceZapAddress());\\r\\n        EIP20Interface NFTLiquidationExchangeToken = EIP20Interface(NFTLiquidationExchangePToken.underlying());\\r\\n\\r\\n        // sell underlying for NFTLiquidationExchangeToken\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = NFTXioMarketplace.nftxFactory().vault(uint(NFTXioVaultId));\\r\\n        path[1] = address(NFTLiquidationExchangeToken);\\r\\n        require(INFTXVault(path[0]).assetAddress() == underlying, \\\"wrong NFTXVaultId\\\");\\r\\n\\r\\n        approveUnderlying(tokenId, address(NFTXioMarketplace));\\r\\n\\r\\n        uint[] memory ids = new uint[](1);\\r\\n        ids[0] = tokenId;\\r\\n\\r\\n        NFTXioMarketplace.mintAndSell721WETH(uint(NFTXioVaultId), ids, minAmountToReceive, path, address(this));\\r\\n    }\\r\\n\\r\\n    function _exchangeUnderlying(address owner, uint tokenId, uint minAmountToReceive, uint liquidationIncentive, address liquidator, bool liquidatorSeize, PErc20Interface NFTLiquidationExchangePToken) internal {\\r\\n        // NFT TODO depositBehalf ??\\r\\n        assert(ownerOf(tokenId) == owner);\\r\\n        require(minAmountToReceive > liquidationIncentive && liquidationIncentive > 0, \\\"liquidateCollateral not possible\\\");\\r\\n\\r\\n        EIP20Interface NFTLiquidationExchangeToken = EIP20Interface(NFTLiquidationExchangePToken.underlying());\\r\\n\\r\\n        uint256 exchangeTokenBalanceBefore = NFTLiquidationExchangeToken.balanceOf(address(this));\\r\\n        uint256 exchangePTokenBalanceBefore = NFTLiquidationExchangePToken.balanceOf(address(this));\\r\\n\\r\\n        if (liquidatorSeize) { // sell underlying NFT to liquidator\\r\\n            _sellUnderlyingToLiquidator(tokenId, minAmountToReceive, liquidator, NFTLiquidationExchangePToken);\\r\\n        } else { // exchange underlying NFT for NFTLiquidationExchangePToken\\r\\n            _sellUnderlyingOnNFTXio(tokenId, minAmountToReceive, NFTLiquidationExchangePToken);\\r\\n//            _sellUnderlyingOnSudoswap(tokenId, minAmountToReceive, NFTLiquidationExchangePToken); // NFT TODO\\r\\n        }\\r\\n\\r\\n        uint amountReceived = NFTLiquidationExchangeToken.balanceOf(address(this)) - exchangeTokenBalanceBefore;\\r\\n        require(amountReceived >= minAmountToReceive, \\\"incorrect amount received\\\");\\r\\n        // address(this) has NFTLiquidationExchangeToken now\\r\\n\\r\\n        // exchange NFTLiquidationExchangeToken for its PToken\\r\\n        require(NFTLiquidationExchangeToken.approve(address(NFTLiquidationExchangePToken), amountReceived), \\\"NFTLiquidationExchangeToken approve failed\\\");\\r\\n        require(NFTLiquidationExchangePToken.mint(amountReceived - liquidationIncentive) == uint(Error.NO_ERROR), \\\"NFTLiquidationExchangePToken mint failed\\\");\\r\\n\\r\\n        // transfer NFTLiquidationExchangePToken to owner\\r\\n        require(NFTLiquidationExchangePToken.transfer(owner, NFTLiquidationExchangePToken.balanceOf(address(this)) - exchangePTokenBalanceBefore), \\\"NFTLiquidationExchangePToken transfer to owner failed\\\");\\r\\n\\r\\n        // burn pNFTToken\\r\\n        approveInternal(address(0), tokenId);\\r\\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\\r\\n        ownedTokensIndex[tokenId] = 0;\\r\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\r\\n        uint accountTokensNew = sub_(accountTokens[owner], 1);\\r\\n        accountTokens[owner] = accountTokensNew;\\r\\n        tokensOwners[tokenId] = address(0);\\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    /**\\r\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @param newPendingAdmin New pending admin.\\r\\n      */\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) external {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n\\r\\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin);\\r\\n        pendingAdmin = newPendingAdmin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\r\\n      * @dev Admin function for pending admin to accept role and update admin\\r\\n      */\\r\\n    function _acceptAdmin() external {\\r\\n        require(msg.sender == pendingAdmin, \\\"only pending admin\\\");\\r\\n\\r\\n        emit NewAdmin(admin, pendingAdmin);\\r\\n        emit NewPendingAdmin(pendingAdmin, address(0));\\r\\n        admin = pendingAdmin;\\r\\n        pendingAdmin = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets a new comptroller for the market\\r\\n      * @dev Admin function to set a new comptroller\\r\\n      */\\r\\n    function _setComptroller(address newComptroller) public {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n        require(ComptrollerNFTInterface(newComptroller).isComptroller());\\r\\n\\r\\n        emit NewComptroller(address(comptroller), newComptroller);\\r\\n        comptroller = ComptrollerNFTInterface(newComptroller);\\r\\n    }\\r\\n\\r\\n    function _setNFTXioVaultId(int newNFTXioVaultId) external {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n        require(INFTXVault(INFTXMarketplaceZap(comptroller.NFTXioMarketplaceZapAddress()).nftxFactory().vault(uint(newNFTXioVaultId))).assetAddress() == underlying, \\\"wrong NFTXVaultId\\\");\\r\\n\\r\\n        NFTXioVaultId = newNFTXioVaultId;\\r\\n    }\\r\\n\\r\\n    function _setSudoswapLSSVMPairAddress(address newSudoswapLSSVMPairAddress) external {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n\\r\\n        // NFT TODO\\r\\n        // require(LSSVMPairERC20Interface(newSudoswapLSSVMPairAddress).nft() == underlying, \\\"wrong newSudoswapLSSVMPairAddress.nft()\\\");\\r\\n        // require(LSSVMPairERC20Interface(newSudoswapLSSVMPairAddress).token() == PErc20Interface(comptroller.NFTLiquidationExchangePToken()).underlying(), \\\"wrong newSudoswapLSSVMPairAddress.token()\\\");\\r\\n        //\\r\\n        // SudoswapLSSVMPairAddress = newSudoswapLSSVMPairAddress;\\r\\n    }\\r\\n\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view returns (uint);\\r\\n\\r\\n    function checkIfOwnsUnderlying(uint tokenId) internal view returns (bool);\\r\\n\\r\\n    function approveUnderlying(uint256 tokenId, address addr) internal;\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\r\\n     *  This may revert due to insufficient balance or insufficient allowance.\\r\\n     */\\r\\n    function doTransferIn(address from, uint tokenId) internal;\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\r\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\r\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\r\\n     */\\r\\n    function doTransferOut(address to, uint tokenId) internal;\\r\\n\\r\\n    /*** Reentrancy Guard ***/\\r\\n\\r\\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"reentered\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n        // get a gas-refund post-Istanbul\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PNFTTokenDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PNFTTokenInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PNFTDelegator Contract\\r\\n * @notice PNFTTokens which wrap an NFT underlying and delegate to an implementation\\r\\n * @author Paribus\\r\\n */\\r\\ncontract PNFTTokenDelegator is PNFTTokenStorage, PNFTTokenDelegatorInterface {\\r\\n    constructor(address underlying_,\\r\\n        address comptroller_,\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        address payable admin_,\\r\\n        address implementation_,\\r\\n        bytes memory becomeImplementationData) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\r\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,string,string)\\\",\\r\\n            underlying_,\\r\\n            comptroller_,\\r\\n            name_,\\r\\n            symbol_));\\r\\n\\r\\n        // New implementations always get set via the setter (post-initialize)\\r\\n        _setImplementation(implementation_, false, becomeImplementationData);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal method to delegate execution to another contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param callee The contract to delegatecall\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                revert(add(returnData, 0x20), returndatasize)\\r\\n            }\\r\\n        }\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to the implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\r\\n        return delegateTo(implementation, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the admin to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\\r\\n        require(msg.sender == admin, \\\"PNFTTokenDelegator::_setImplementation: Caller must be admin\\\");\\r\\n        require(PNFTTokenInterface(implementation_).isPNFTToken());\\r\\n\\r\\n        if (allowResign) {\\r\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\r\\n        }\\r\\n\\r\\n        address oldImplementation = implementation;\\r\\n        implementation = implementation_;\\r\\n\\r\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\r\\n\\r\\n        emit NewImplementation(oldImplementation, implementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to an implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     */\\r\\n    function() external payable {\\r\\n        require(msg.value == 0, \\\"PNFTTokenDelegator:fallback: cannot send value to fallback\\\");\\r\\n\\r\\n        // delegate all other functions to current implementation\\r\\n        (bool success,) = implementation.delegatecall(msg.data);\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 {revert(free_mem_ptr, returndatasize)}\\r\\n            default {return (free_mem_ptr, returndatasize)}\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PNFTToken/PNFTTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Comptroller/ComptrollerInterfaces.sol\\\";\\r\\nimport \\\"../InterestRateModels/InterestRateModelInterface.sol\\\";\\r\\nimport \\\"../Interfaces/EIP20NonStandardInterface.sol\\\";\\r\\n\\r\\ncontract PNFTTokenStorage {\\r\\n    /// @dev Guard variable for reentrancy checks\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /// @notice EIP-721 token name for this token\\r\\n    string public name;\\r\\n\\r\\n    /// @notice EIP-721 token symbol for this token\\r\\n    string public symbol;\\r\\n\\r\\n    /// @notice Administrator for this contract\\r\\n    address payable public admin;\\r\\n\\r\\n    /// @notice Pending administrator for this contract\\r\\n    address payable public pendingAdmin;\\r\\n\\r\\n    /// @notice Contract which oversees inter-PNFTToken operations\\r\\n    ComptrollerNFTInterface public comptroller;\\r\\n\\r\\n    /// @notice Mapping from token ID to owner address\\r\\n    mapping(uint256 => address) internal tokensOwners;\\r\\n\\r\\n    /// @notice Mapping owner address to token count\\r\\n    mapping (address => uint) internal accountTokens;\\r\\n\\r\\n    /// @notice Mapping from token ID to approved address\\r\\n    mapping(uint256 => address) internal transferAllowances;\\r\\n\\r\\n    /// @notice Mapping from owner to operator approvals\\r\\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\\r\\n\\r\\n    /// @notice Mapping from owner to list of owned token IDs\\r\\n    mapping(address => uint256[]) internal ownedTokens;\\r\\n\\r\\n    /// @notice Mapping from token ID to index of the owner tokens list\\r\\n    mapping(uint256 => uint256) internal ownedTokensIndex;\\r\\n\\r\\n    /// @notice Array with all token ids, used for enumeration\\r\\n    uint256[] internal allTokens;\\r\\n\\r\\n    /// @notice Mapping from token id to position in the allTokens array\\r\\n    mapping(uint256 => uint256) internal allTokensIndex;\\r\\n\\r\\n    /// @notice Underlying asset for this PNFTToken\\r\\n    address public underlying;\\r\\n\\r\\n    int public NFTXioVaultId = -1;\\r\\n\\r\\n    address public SudoswapLSSVMPairAddress;\\r\\n}\\r\\n\\r\\ncontract PNFTTokenInterface is PNFTTokenStorage {\\r\\n    /// @notice Indicator that this is a PNFTToken contract (for inspection)\\r\\n    bool public constant isPNFTToken = true;\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /// @notice Event emitted when tokens are minted\\r\\n    event Mint(address indexed minter, uint256 indexed tokenId);\\r\\n\\r\\n    /// @notice Event emitted when tokens are redeemed\\r\\n    event Redeem(address indexed redeemer, uint256 indexed tokenId);\\r\\n\\r\\n    /// @notice Event emitted when borrower's collateral is liquidated\\r\\n    event LiquidateCollateral(address indexed liquidator, address indexed borrower, uint indexed tokenId, address NFTLiquidationExchangePToken);\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /// @notice Event emitted when pendingAdmin is changed\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /// @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /// @notice Event emitted when comptroller is changed\\r\\n    event NewComptroller(address oldComptroller, address newComptroller);\\r\\n\\r\\n    /// @notice Event emitted when the reserve factor is changed\\r\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\r\\n\\r\\n    /// @notice EIP721 Transfer event\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /// @notice EIP721 Approval event\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /// @notice EIP721 ApprovalForAll event\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /// @notice Failure event\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /*** ERC165 Functions ***/\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    /*** EIP721 Functions ***/\\r\\n\\r\\n    function transferFrom(address src, address dst, uint tokenId) external;\\r\\n    function safeTransferFrom(address src, address dst, uint256 tokenId, bytes memory data) public;\\r\\n    function safeTransferFrom(address src, address dst, uint256 tokenId) external;\\r\\n    function approve(address to, uint tokenId) external;\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function ownerOf(uint tokenId) external view returns (address);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\r\\n    function totalSupply() public view returns (uint256);\\r\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function balanceOfUnderlying(address owner) external view returns (uint);\\r\\n    function getCash() external view returns (uint);\\r\\n    function liquidateCollateral(address borrower, uint tokenId, address NFTLiquidationExchangePTokenAddress) external returns (uint);\\r\\n    function liquidateSeizeCollateral(address borrower, uint tokenId, address NFTLiquidationExchangePTokenAddress) external returns (uint);\\r\\n    function mint(uint tokenId) external;\\r\\n    function safeMint(uint256 tokenId) external;\\r\\n    function safeMint(uint256 tokenId, bytes calldata data) external;\\r\\n    function redeem(uint tokenId) external;\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) external;\\r\\n    function _acceptAdmin() external;\\r\\n    function _setComptroller(address newComptroller) public;\\r\\n    function _setNFTXioVaultId(int newNFTXioVaultId) external;\\r\\n    function _setSudoswapLSSVMPairAddress(address newSudoswapLSSVMPairAddress) external;\\r\\n}\\r\\n\\r\\ncontract PErc721Interface is PNFTTokenInterface {\\r\\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\\r\\n}\\r\\n\\r\\ncontract PNFTTokenDelegationStorage {\\r\\n    /// @notice Implementation address for this contract\\r\\n    address public implementation;\\r\\n}\\r\\n\\r\\ncontract PNFTTokenDelegatorInterface is PNFTTokenDelegationStorage {\\r\\n    /// @notice Emitted when implementation is changed\\r\\n    event NewImplementation(address oldImplementation, address newImplementation);\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the admin to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\\r\\n}\\r\\n\\r\\ncontract PNFTTokenDelegateInterface is PNFTTokenInterface, PNFTTokenDelegationStorage {\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\r\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes calldata data) external;\\r\\n\\r\\n    /// @notice Called by the delegator on a delegate to forfeit its responsibility\\r\\n    function _resignImplementation() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/ArbitrumPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./Impl/ChainlinkPriceOracle.sol\\\";\\r\\n\\r\\ncontract ArbitrumGoerliPriceOracle is L2ChainlinkPriceOracle {\\r\\n    constructor() public {\\r\\n        chainlinkDataFeeds[0xFf8CbB3E593cf9003A43Ff4A77E7832c8B620571] = 0x6550bc2301936011c1334555e62A87705A81C12C; // wbtc\\r\\n        chainlinkDataFeeds[0xeBD32BFc3e0D80E9ed34A97e3083e7a5C63C2d89] = 0x0a023a3423D9b27A0BE48c768CCF2dD7877fEf5E; // usdt\\r\\n\\r\\n        chainlinkDataFeeds[address(0)] = 0x62CAe0FA2da220f43a51F86Db2EDb36DcA9A5A08; // eth\\r\\n        pEtherAddress = 0x3c2cf7aAD5804cA3c786E2640Db150043437b6dA;\\r\\n\\r\\n        sequencerUptimeFeed = 0x4da69F028a5790fCCAfe81a75C0D24f46ceCDd69;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ArbitrumPriceOracle is L2ChainlinkPriceOracle {\\r\\n    constructor() public {\\r\\n        chainlinkDataFeeds[0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f] = 0x6ce185860a4963106506C203335A2910413708e9; // wbtc\\r\\n        chainlinkDataFeeds[0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9] = 0x3f3f5dF88dC9F13eac63DF89EC16ef6e7E25DdE7; // usdt\\r\\n\\r\\n        chainlinkDataFeeds[address(0)] = 0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612; // eth\\r\\n        pEtherAddress = 0x375Ae76F0450293e50876D0e5bDC3022CAb23198;\\r\\n\\r\\n        sequencerUptimeFeed = 0xFdB631F5EE196F0ed6FAa767959853A9F217697D;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/GoerliPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./Impl/ChainlinkPriceOracle.sol\\\";\\r\\nimport \\\"./Impl/NFTPriceOracle.sol\\\";\\r\\n\\r\\ncontract GoerliPriceOracle is ChainlinkPriceOracle, NFTPriceOracle {\\r\\n    constructor() public {\\r\\n        chainlinkDataFeeds[0x2511cBfcb3a4581C128dD6e0196a618f25E1a10B] = 0xA39434A63A52E749F02807ae27335515BA4b07F7; // wbtc\\r\\n        chainlinkDataFeeds[0x6E3c9208bA7D4e6950DC540a483976774Cf00D77] = 0x48731cF7e84dc94C5f84577882c14Be11a5B7456; // link\\r\\n        chainlinkDataFeeds[address(0)] = 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e; // eth\\r\\n        stablecoinsPrices[0x06698e5d51bd05Eb3551a7Cf9DcA881aB069A9Ba] = 1000000000000000000; // usdc == 1 USD\\r\\n        pEtherAddress = 0x9517c419f5b9A9C7e876B066543d36d798c23fDD;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/Impl/Api3PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../../Interfaces/Api3Interfaces.sol\\\";\\r\\nimport \\\"./StablecoinsPriceOracle.sol\\\";\\r\\n\\r\\ncontract Api3PriceOracle is StablecoinsPriceOracle {\\r\\n    /// @notice underlying address => data feed name\\r\\n    mapping(address => bytes32) public api3DataFeedNames;\\r\\n\\r\\n    address public api3DapiServer;\\r\\n\\r\\n    function isTokenSupported(address token) public view returns (bool) {\\r\\n        return StablecoinsPriceOracle.isTokenSupported(token) || api3DataFeedNames[token] != 0;\\r\\n    }\\r\\n\\r\\n    function getPriceOfUnderlying(address token, uint decimals) public view returns (uint) {\\r\\n        require(isTokenSupported(token), \\\"TOKEN_NOT_SUPPORTED\\\");\\r\\n        if (StablecoinsPriceOracle.isTokenSupported(token)) return StablecoinsPriceOracle.getPriceOfUnderlying(token, decimals);\\r\\n\\r\\n        (int price, /* uint timestamp */) = Api3IDapiServer(api3DapiServer).readDataFeedWithDapiName(api3DataFeedNames[token]);\\r\\n        assert(price >= 0);\\r\\n        return adjustDecimals(18, decimals, uint(price));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/Impl/ChainlinkPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.5/interfaces/AggregatorV3Interface.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.5/interfaces/FlagsInterface.sol\\\";\\r\\nimport \\\"./StablecoinsPriceOracle.sol\\\";\\r\\n\\r\\ncontract ChainlinkPriceOracle is StablecoinsPriceOracle {\\r\\n    /// @notice underlying address => underlying asset price data feed\\r\\n    mapping(address => address) public chainlinkDataFeeds;\\r\\n\\r\\n    function isTokenSupported(address token) public view returns (bool) {\\r\\n        return StablecoinsPriceOracle.isTokenSupported(token) || chainlinkDataFeeds[token] != address(0);\\r\\n    }\\r\\n\\r\\n    function getPriceOfUnderlying(address token, uint decimals) public view returns (uint) {\\r\\n        require(isTokenSupported(token), \\\"TOKEN_NOT_SUPPORTED\\\");\\r\\n        if (StablecoinsPriceOracle.isTokenSupported(token)) return StablecoinsPriceOracle.getPriceOfUnderlying(token, decimals);\\r\\n\\r\\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(chainlinkDataFeeds[token]);\\r\\n        (uint80 roundID, int256 price, uint256 updatedAt, uint256 timeStamp, uint80 answeredInRound) = priceFeed.latestRoundData();\\r\\n        require(price > 0, \\\"invalid chainlink answer: price\\\");\\r\\n        require(timeStamp > 0, \\\"invalid chainlink answer: timestamp\\\");\\r\\n        require(answeredInRound >= roundID, \\\"invalid chainlink answer: answeredInRound\\\");\\r\\n        require(subabs(block.timestamp, updatedAt) < 86400 * 1.1, \\\"invalid chainlink answer: updatedAt\\\"); // chainlink heartbeat is 86400s or lower on all chains (we multiply by some slippage factor)\\r\\n\\r\\n        return adjustDecimals(priceFeed.decimals(), decimals, uint(price));\\r\\n    }\\r\\n\\r\\n    /// @return abs(a - b)\\r\\n    function subabs(uint a, uint b) internal pure returns (uint) {\\r\\n        return a > b ? a - b : b - a;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract L2ChainlinkPriceOracle is ChainlinkPriceOracle {\\r\\n    /// @dev see https://docs.chain.link/data-feeds/l2-sequencer-feeds\\r\\n    address public sequencerUptimeFeed;\\r\\n\\r\\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\\r\\n\\r\\n    function getPriceOfUnderlying(address token, uint decimals) public view returns (uint) {\\r\\n        (, int256 answer, uint256 startedAt, , ) = AggregatorV3Interface(sequencerUptimeFeed).latestRoundData();\\r\\n\\r\\n        // Answer == 0: Sequencer is up\\r\\n        // Answer == 1: Sequencer is down\\r\\n        if (answer != 0) {\\r\\n            revert('chainlink L2 sequencer is down');\\r\\n        }\\r\\n\\r\\n        // Make sure the grace period has passed after the sequencer is back up\\r\\n        uint256 timeSinceUp = block.timestamp - startedAt;\\r\\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\\r\\n            revert('chainlink L2 sequencer grace period not over');\\r\\n        }\\r\\n\\r\\n        return ChainlinkPriceOracle.getPriceOfUnderlying(token, decimals);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/Impl/NFTPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PriceOracleCommonImpl.sol\\\";\\r\\n\\r\\n// NFT TODO NFTPriceOracle\\r\\ncontract NFTPriceOracle is PriceOracleCommonImpl {\\r\\n    // 18 decimals\\r\\n    function getUnderlyingNFTPrice(PNFTToken, uint256) public view returns (uint) {\\r\\n        assert(false);\\r\\n    }\\r\\n\\r\\n    function isNFTCollectionSupported(address) public view returns (bool) {\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/Impl/PriceOracleCommonImpl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../../Utils/SafeMath.sol\\\";\\r\\nimport \\\"../PriceOracleInterfaces.sol\\\";\\r\\nimport \\\"../../PToken/PErc20/PErc20.sol\\\";\\r\\n\\r\\ncontract PriceOracleCommonImpl is PriceOracleNoNFTInterface {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMath for uint8;\\r\\n    using SafeMath for int;\\r\\n\\r\\n    /// @notice The address of pEther. We need this because pEther has no .underlying() property for obvious reason\\r\\n    address public pEtherAddress;\\r\\n\\r\\n    /**\\r\\n      * @notice Get the decimals and address of a given pToken's underlying asset\\r\\n      * @param pToken The token\\r\\n      * @return (decimals of underlying, address of underlying (address(0) for pEther))\\r\\n      */\\r\\n    function getUnderlyingDecimalsAndAddress(PToken pToken) public view returns (uint256, address) {\\r\\n        if (address(pToken) == pEtherAddress) return (18, address(0));\\r\\n\\r\\n        else {\\r\\n            PErc20 pErc20 = PErc20(address(pToken));\\r\\n            return (EIP20Interface(pErc20.underlying()).decimals(), pErc20.underlying());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function adjustDecimals(uint valueDecimals, uint wantedDecimals, uint value) internal pure returns (uint) {\\r\\n        if (wantedDecimals >= valueDecimals) return value.mul(10 ** wantedDecimals.sub(valueDecimals));\\r\\n        else return value.div(10 ** valueDecimals.sub(wantedDecimals));\\r\\n    }\\r\\n\\r\\n    function isPTokenSupported(PToken pToken) public view returns (bool) {\\r\\n        (, address underlyingAddress) = getUnderlyingDecimalsAndAddress(pToken);\\r\\n        return isTokenSupported(underlyingAddress);\\r\\n    }\\r\\n\\r\\n    function getUnderlyingPrice(PToken pToken) public view returns (uint256) {\\r\\n        (uint256 underlyingDecimals, address underlyingAddress) = getUnderlyingDecimalsAndAddress(pToken);\\r\\n        return getPriceOfUnderlying(underlyingAddress, SafeMath.sub(36, underlyingDecimals));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/Impl/StablecoinsPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PriceOracleCommonImpl.sol\\\";\\r\\n\\r\\ncontract StablecoinsPriceOracle is PriceOracleCommonImpl {\\r\\n    /// @notice underlying stablecoin address => fixed stablecoin price, 18 decimals\\r\\n    mapping(address => uint256) public stablecoinsPrices;\\r\\n\\r\\n    function getPriceOfUnderlying(address token, uint decimals) public view returns (uint) {\\r\\n        require(isTokenSupported(token), \\\"TOKEN_NOT_SUPPORTED\\\");\\r\\n        return adjustDecimals(18, decimals, stablecoinsPrices[token]);\\r\\n    }\\r\\n\\r\\n    function isTokenSupported(address token) public view returns (bool) {\\r\\n        return stablecoinsPrices[token] > 0;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/PolygonPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./Impl/ChainlinkPriceOracle.sol\\\";\\r\\nimport \\\"./Impl/Api3PriceOracle.sol\\\";\\r\\n\\r\\ncontract MumbaiPriceOracle is ChainlinkPriceOracle, Api3PriceOracle {\\r\\n    constructor() public {\\r\\n        chainlinkDataFeeds[address(0)] = address(0); // wbtc\\r\\n        chainlinkDataFeeds[address(0)] = address(0); // eth\\r\\n        chainlinkDataFeeds[address(0)] = address(0); // weth\\r\\n        chainlinkDataFeeds[address(0)] = address(0); // dai\\r\\n\\r\\n        stablecoinsPrices[address(0)] = 1000000000000000000; // usdc == 1 USD\\r\\n        stablecoinsPrices[address(0)] = 100000000000000000; // pbx == 0.01 USD\\r\\n\\r\\n        pEtherAddress = address(0);\\r\\n\\r\\n        api3DataFeedNames[address(0)] = \\\"\\\";\\r\\n        api3DapiServer = 0x71Da7A936fCaEd1Ee364Df106B12deF6D1Bf1f14;\\r\\n    }\\r\\n\\r\\n    function isTokenSupported(address token) public view returns (bool) {\\r\\n        return ChainlinkPriceOracle.isTokenSupported(token) || Api3PriceOracle.isTokenSupported(token);\\r\\n    }\\r\\n\\r\\n    function getPriceOfUnderlying(address token, uint decimals) public view returns (uint) {\\r\\n        if (ChainlinkPriceOracle.isTokenSupported(token)) return ChainlinkPriceOracle.getPriceOfUnderlying(token, decimals);\\r\\n        if (Api3PriceOracle.isTokenSupported(token)) return Api3PriceOracle.getPriceOfUnderlying(token, decimals);\\r\\n        revert(\\\"TOKEN_NOT_SUPPORTED\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/PriceOracleInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PNFTToken/PNFTToken.sol\\\";\\r\\nimport \\\"../PToken/PToken.sol\\\";\\r\\n\\r\\ncontract PriceOracleNoNFTInterface {\\r\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\r\\n    bool public constant isPriceOracle = true;\\r\\n\\r\\n    /**\\r\\n      * @notice Get the price of underlying pToken asset.\\r\\n      * @param pToken The pToken\\r\\n      * @return The price of pToken.underlying(). Decimals: 36 - underlyingDecimals\\r\\n      */\\r\\n    function getUnderlyingPrice(PToken pToken) public view returns (uint);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the price of a given token\\r\\n      * @param token The token. Use address(0) for native token (like ETH).\\r\\n      * @param decimals Wanted decimals\\r\\n      * @return The price of the token with a given decimals\\r\\n      */\\r\\n    function getPriceOfUnderlying(address token, uint decimals) public view returns (uint);\\r\\n\\r\\n    /** @notice Check whether token is supported by this oracle and we've got a price for it\\r\\n      * @param token The token to check\\r\\n      */\\r\\n    function isTokenSupported(address token) public view returns (bool);\\r\\n\\r\\n    /** @notice Check whether pToken is supported by this oracle and we've got a price for its underlying asset\\r\\n      * @param pToken The token to check\\r\\n      */\\r\\n    function isPTokenSupported(PToken pToken) public view returns (bool);\\r\\n}\\r\\n\\r\\ncontract PriceOracleInterface is PriceOracleNoNFTInterface {\\r\\n    function getUnderlyingNFTPrice(PNFTToken pNFTToken, uint256 tokenId) public view returns (uint);\\r\\n\\r\\n    function isNFTCollectionSupported(address nft) public view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/RinkebyPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./Impl/ChainlinkPriceOracle.sol\\\";\\r\\n\\r\\ncontract RinkebyPriceOracle is ChainlinkPriceOracle {\\r\\n    constructor() public {\\r\\n        chainlinkDataFeeds[0x37022F97333df61A61595B7cf43b63205290f8Ee] = 0xECe365B379E1dD183B20fc5f022230C044d51404; // wbtc\\r\\n        chainlinkDataFeeds[address(0)] = 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e; // eth\\r\\n        chainlinkDataFeeds[0x98a5F1520f7F7fb1e83Fe3398f9aBd151f8C65ed] = 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e; // weth\\r\\n        chainlinkDataFeeds[0x2Ec4c6fCdBF5F9beECeB1b51848fc2DB1f3a26af] = 0x2bA49Aaa16E6afD2a993473cfB70Fa8559B523cF; // dai\\r\\n        stablecoinsPrices[0x5B8B635c2665791cf62fe429cB149EaB42A3cEd8] = 1000000000000000000; // usdc == 1 USD\\r\\n        stablecoinsPrices[0x04A382E64E36D63Dc2bAA837aB5217620732c60A] = 100000000000000000; // pbx == 0.01 USD\\r\\n        pEtherAddress = 0x2a97aDE05f844802a6DB2a40f547096b464CcF18;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PriceOracle/SimplePriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./Impl/StablecoinsPriceOracle.sol\\\";\\r\\nimport \\\"../Utils/Ownable.sol\\\";\\r\\n\\r\\n// SimplePriceOracle contract is used in unit tests only and allows to set the prices manually\\r\\n// use StablecoinsPriceOracle here to simplify implementation, just add the setUnderlyingPrice function with proper decimals calculation\\r\\ncontract SimplePriceOracle is StablecoinsPriceOracle, PriceOracleInterface, Ownable {\\r\\n    function getUnderlyingDecimalsAndAddress(PToken pToken) public view returns (uint256, address) {\\r\\n        if (compareStrings(pToken.symbol(), \\\"pETH\\\")) return (18, address(0));\\r\\n\\r\\n        else {\\r\\n            PErc20 pErc20 = PErc20(address(pToken));\\r\\n            return (EIP20Interface(pErc20.underlying()).decimals(), pErc20.underlying());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\r\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Admin function to set the new price for a given pToken\\r\\n      * @param pToken The token\\r\\n      * @param underlyingPriceMantissa The new price. Expected decimals: 36 - underlying decimals\\r\\n      */\\r\\n    function setUnderlyingPrice(PToken pToken, uint underlyingPriceMantissa) public onlyOwner {\\r\\n        require(pToken.isPToken());\\r\\n        (uint underlyingDecimals, address underlyingAddress) = getUnderlyingDecimalsAndAddress(pToken);\\r\\n        stablecoinsPrices[underlyingAddress] = adjustDecimals(SafeMath.sub(36, underlyingDecimals), 18, underlyingPriceMantissa);\\r\\n    }\\r\\n\\r\\n    // NFTs\\r\\n\\r\\n    mapping(address => mapping(uint => uint)) public nftPrices;\\r\\n    mapping(address => bool) public supportedNFTs;\\r\\n\\r\\n    // 18 decimals\\r\\n    function getUnderlyingNFTPrice(PNFTToken pNFTToken, uint256 tokenId) public view returns (uint256) {\\r\\n        return nftPrices[pNFTToken.underlying()][tokenId];\\r\\n    }\\r\\n\\r\\n    function setUnderlyingNFTPrice(PNFTToken pNFTToken, uint256 tokenId, uint underlyingPriceMantissa) public onlyOwner {\\r\\n        require(pNFTToken.isPNFTToken());\\r\\n        supportedNFTs[pNFTToken.underlying()] = true;\\r\\n        nftPrices[pNFTToken.underlying()][tokenId] = underlyingPriceMantissa;\\r\\n    }\\r\\n\\r\\n    function isNFTCollectionSupported(address nft) public view returns (bool) {\\r\\n        return supportedNFTs[nft];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PErc20/PErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc20 Contract\\r\\n * @notice PTokens which wrap an EIP-20 underlying\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PErc20 is PToken, PErc20Interface {\\r\\n    /**\\r\\n     * @notice Initialize the new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     */\\r\\n    function initialize(address underlying_,\\r\\n                        address comptroller_,\\r\\n                        InterestRateModelInterface interestRateModel_,\\r\\n                        uint initialExchangeRateMantissa_,\\r\\n                        string memory name_,\\r\\n                        string memory symbol_,\\r\\n                        uint8 decimals_) public {\\r\\n        require(underlying_ != address(0) && EIP20Interface(underlying_).totalSupply() >= 0, \\\"invalid argument\\\");\\r\\n\\r\\n        // PToken initialize does the bulk of the work\\r\\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\r\\n\\r\\n        // Set underlying and sanity check it\\r\\n        underlying = underlying_;\\r\\n    }\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives pTokens in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function mint(uint mintAmount) external returns (uint) {\\r\\n        (uint err,) = mintInternal(mintAmount);\\r\\n        return err;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for the underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemTokens The number of pTokens to redeem into underlying\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeem(uint redeemTokens) external returns (uint) {\\r\\n        return redeemInternal(redeemTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for a specified amount of underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemAmount The amount of underlying to redeem\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\\r\\n        return redeemUnderlyingInternal(redeemAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sender borrows assets from the protocol to their own address\\r\\n      * @param borrowAmount The amount of the underlying asset to borrow\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function borrow(uint borrowAmount) external returns (uint) {\\r\\n        return borrowInternal(borrowAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays their own borrow\\r\\n     * @param repayAmount The amount to repay\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function repayBorrow(uint repayAmount) external returns (uint) {\\r\\n        (uint err,) = repayBorrowInternal(repayAmount);\\r\\n        return err;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays a borrow belonging to borrower\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount The amount to repay\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\\r\\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\\r\\n        return err;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param borrower The borrower of this pToken to be liquidated\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @param pTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function liquidateBorrow(address borrower, uint repayAmount, PTokenInterface pTokenCollateral) external returns (uint) {\\r\\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, pTokenCollateral);\\r\\n        return err;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\r\\n     * @param token The address of the ERC-20 token to sweep\\r\\n     */\\r\\n    function sweepToken(EIP20NonStandardInterface token) external {\\r\\n    \\trequire(address(token) != underlying, \\\"PErc20::sweepToken: can not sweep underlying token\\\");\\r\\n    \\tuint256 balance = token.balanceOf(address(this));\\r\\n    \\ttoken.transfer(admin, balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender adds to reserves.\\r\\n     * @param addAmount The amount fo underlying token to add as reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _addReserves(uint addAmount) external returns (uint) {\\r\\n        return _addReservesInternal(addAmount);\\r\\n    }\\r\\n\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying tokens owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view returns (uint) {\\r\\n        EIP20Interface token = EIP20Interface(underlying);\\r\\n        return token.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\r\\n     *      This will revert due to insufficient balance or insufficient allowance.\\r\\n     *      This function returns the actual amount received,\\r\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\r\\n     *\\r\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\r\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n     */\\r\\n    function doTransferIn(address from, uint amount) internal returns (uint) {\\r\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\\r\\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\\r\\n        token.transferFrom(from, address(this), amount);\\r\\n\\r\\n        bool success;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {                       // This is a non-standard ERC-20\\r\\n                    success := not(0)          // set success to true\\r\\n                }\\r\\n                case 32 {                      // This is a compliant ERC-20\\r\\n                    returndatacopy(0, 0, 32)\\r\\n                    success := mload(0)        // Set `success = returndata` of external call\\r\\n                }\\r\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\r\\n\\r\\n        // Calculate the amount that was *actually* transferred\\r\\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\\r\\n        require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\r\\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\r\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\r\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\r\\n     *      it is >= amount, this should not revert in normal conditions.\\r\\n     *\\r\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\r\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n     */\\r\\n    function doTransferOut(address payable to, uint amount) internal {\\r\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\\r\\n        token.transfer(to, amount);\\r\\n\\r\\n        bool success;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {                      // This is a non-standard ERC-20\\r\\n                    success := not(0)          // set success to true\\r\\n                }\\r\\n                case 32 {                     // This is a complaint ERC-20\\r\\n                    returndatacopy(0, 0, 32)\\r\\n                    success := mload(0)        // Set `success = returndata` of external call\\r\\n                }\\r\\n                default {                     // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PErc20/PErc20Delegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PErc20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc20Delegate Contract\\r\\n * @notice PTokens which wrap an EIP-20 underlying and are delegated to\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PErc20Delegate is PErc20, PTokenDelegateInterface {\\r\\n    /// @notice Construct an empty delegate\\r\\n    constructor() public { }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty. Should not be marked as pure\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes calldata data) external {\\r\\n        data; // Shh -- currently unused\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Called by the delegator on a delegate to forfeit its responsibility. Should not be marked as pure\\r\\n    function _resignImplementation() external {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PErc20/PErc20Delegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PTokenInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc20Delegator Contract\\r\\n * @notice PTokens which wrap an EIP-20 underlying and delegate to an implementation\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PErc20Delegator is PTokenStorage, PTokenDelegatorInterface {\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     * @param implementation_ The address of the implementation the contract delegates to\\r\\n     * @param becomeImplementationData The encoded args for becomeImplementation\\r\\n     */\\r\\n    constructor(address underlying_,\\r\\n        address comptroller_,\\r\\n        InterestRateModelInterface interestRateModel_,\\r\\n        uint initialExchangeRateMantissa_,\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        address payable admin_,\\r\\n        address implementation_,\\r\\n        bytes memory becomeImplementationData) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\r\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,address,uint256,string,string,uint8)\\\",\\r\\n            underlying_,\\r\\n            comptroller_,\\r\\n            interestRateModel_,\\r\\n            initialExchangeRateMantissa_,\\r\\n            name_,\\r\\n            symbol_,\\r\\n            decimals_));\\r\\n\\r\\n        // New implementations always get set via the setter (post-initialize)\\r\\n        _setImplementation(implementation_, false, becomeImplementationData);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal method to delegate execution to another contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param callee The contract to delegatecall\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                revert(add(returnData, 0x20), returndatasize)\\r\\n            }\\r\\n        }\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to the implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\r\\n        return delegateTo(implementation, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the admin to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n        require(PTokenInterface(implementation_).isPToken());\\r\\n\\r\\n        if (allowResign) {\\r\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\r\\n        }\\r\\n\\r\\n        address oldImplementation = implementation;\\r\\n        implementation = implementation_;\\r\\n\\r\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\r\\n\\r\\n        emit NewImplementation(oldImplementation, implementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to an implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     */\\r\\n    function () external payable {\\r\\n        require(msg.value == 0,\\\"PErc20Delegator:fallback: cannot send value to fallback\\\");\\r\\n\\r\\n        // delegate all other functions to current implementation\\r\\n        (bool success, ) = implementation.delegatecall(msg.data);\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 { revert(free_mem_ptr, returndatasize) }\\r\\n            default { return(free_mem_ptr, returndatasize) }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PErc20/PErc20Immutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PErc20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PErc20Immutable Contract\\r\\n * @notice PTokens which wrap an EIP-20 underlying and are immutable\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PErc20Immutable is PErc20 {\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     */\\r\\n    constructor(address underlying_,\\r\\n                address comptroller_,\\r\\n                InterestRateModelInterface interestRateModel_,\\r\\n                uint initialExchangeRateMantissa_,\\r\\n                string memory name_,\\r\\n                string memory symbol_,\\r\\n                uint8 decimals_,\\r\\n                address payable admin_) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // Initialize the market\\r\\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PEther/PEther.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PEther Contract\\r\\n * @notice PToken which wraps network native token\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PEther is PToken {\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives pTokens in exchange\\r\\n     * @dev Reverts upon any failure\\r\\n     */\\r\\n    function mint() external payable {\\r\\n        (uint err,) = mintInternal(msg.value);\\r\\n        requireNoError(err, \\\"mint failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for the underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemTokens The number of pTokens to redeem into underlying\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeem(uint redeemTokens) external returns (uint) {\\r\\n        return redeemInternal(redeemTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for a specified amount of underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemAmount The amount of underlying to redeem\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\\r\\n        return redeemUnderlyingInternal(redeemAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sender borrows assets from the protocol to their own address\\r\\n      * @param borrowAmount The amount of the underlying asset to borrow\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function borrow(uint borrowAmount) external returns (uint) {\\r\\n        return borrowInternal(borrowAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays their own borrow\\r\\n     * @dev Reverts upon any failure\\r\\n     */\\r\\n    function repayBorrow() external payable {\\r\\n        (uint err,) = repayBorrowInternal(msg.value);\\r\\n        requireNoError(err, \\\"repayBorrow failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays a borrow belonging to borrower\\r\\n     * @dev Reverts upon any failure\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     */\\r\\n    function repayBorrowBehalf(address borrower) external payable {\\r\\n        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\\r\\n        requireNoError(err, \\\"repayBorrowBehalf failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender liquidates the borrowers collateral. The collateral seized is transferred to the liquidator.\\r\\n     * @dev Reverts upon any failure\\r\\n     * @param borrower The borrower of this pToken to be liquidated\\r\\n     * @param pTokenCollateral The market in which to seize collateral from the borrower\\r\\n     */\\r\\n    function liquidateBorrow(address borrower, PTokenInterface pTokenCollateral) external payable {\\r\\n        (uint err,) = liquidateBorrowInternal(borrower, msg.value, pTokenCollateral);\\r\\n        requireNoError(err, \\\"liquidateBorrow failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender adds to reserves.\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _addReserves() external payable returns (uint) {\\r\\n        return _addReservesInternal(msg.value);\\r\\n    }\\r\\n\\r\\n    /// @notice Send Ether to PEther to mint\\r\\n    function () external payable {\\r\\n        (uint err,) = mintInternal(msg.value);\\r\\n        requireNoError(err, \\\"mint failed\\\");\\r\\n    }\\r\\n\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of Ether, before this message\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of Ether owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view returns (uint) {\\r\\n        return sub_(address(this).balance, msg.value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Perform the actual transfer in, which is a no-op\\r\\n     * @param from Address sending the Ether\\r\\n     * @param amount Amount of Ether being sent\\r\\n     * @return The actual amount of Ether transferred\\r\\n     */\\r\\n    function doTransferIn(address from, uint amount) internal returns (uint) {\\r\\n        // Sanity checks\\r\\n        require(msg.sender == from, \\\"sender mismatch\\\");\\r\\n        require(msg.value == amount, \\\"value mismatch\\\");\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function doTransferOut(address payable to, uint amount) internal {\\r\\n        // Send the Ether, with minimal gas and revert on failure\\r\\n        (bool success, ) = to.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function requireNoError(uint errCode, string memory message) internal pure {\\r\\n        if (errCode == uint(Error.NO_ERROR)) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\\r\\n        uint i;\\r\\n\\r\\n        for (i = 0; i < bytes(message).length; i++) {\\r\\n            fullMessage[i] = bytes(message)[i];\\r\\n        }\\r\\n\\r\\n        fullMessage[i+0] = byte(uint8(32));\\r\\n        fullMessage[i+1] = byte(uint8(40));\\r\\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\\r\\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\\r\\n        fullMessage[i+4] = byte(uint8(41));\\r\\n\\r\\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PEther/PEtherDelegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PEther.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PEtherDelegate Contract\\r\\n * @notice PTokens which wraps network native token and are delegated to\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PEtherDelegate is PEther, PTokenDelegateInterface {\\r\\n    /// @notice Construct an empty delegate\\r\\n    constructor() public { }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty. Should not be marked as pure\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes calldata data) external {\\r\\n        data; // Shh -- currently unused\\r\\n        require(msg.sender == admin, \\\"only the admin may call _becomeImplementation\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Called by the delegator on a delegate to forfeit its responsibility. Should not be marked as pure\\r\\n    function _resignImplementation() external {\\r\\n        require(msg.sender == admin, \\\"only the admin may call _resignImplementation\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PEther/PEtherDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../PTokenInterfaces.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PEtherDelegator Contract\\r\\n * @notice PTokens which wraps network native token and delegate to an implementation\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PEtherDelegator is PTokenStorage, PTokenDelegatorInterface {\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     * @param implementation_ The address of the implementation the contract delegates to\\r\\n     * @param becomeImplementationData The encoded args for becomeImplementation\\r\\n     */\\r\\n    constructor(address comptroller_,\\r\\n        InterestRateModelInterface interestRateModel_,\\r\\n        uint initialExchangeRateMantissa_,\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        address payable admin_,\\r\\n        address implementation_,\\r\\n        bytes memory becomeImplementationData) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\r\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,uint256,string,string,uint8)\\\",\\r\\n            comptroller_,\\r\\n            interestRateModel_,\\r\\n            initialExchangeRateMantissa_,\\r\\n            name_,\\r\\n            symbol_,\\r\\n            decimals_));\\r\\n\\r\\n        // New implementations always get set via the setter (post-initialize)\\r\\n        _setImplementation(implementation_, false, becomeImplementationData);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal method to delegate execution to another contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param callee The contract to delegatecall\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                revert(add(returnData, 0x20), returndatasize)\\r\\n            }\\r\\n        }\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to the implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\r\\n        return delegateTo(implementation, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the admin to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n        require(PTokenInterface(implementation_).isPToken());\\r\\n\\r\\n        if (allowResign) {\\r\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\r\\n        }\\r\\n\\r\\n        address oldImplementation = implementation;\\r\\n        implementation = implementation_;\\r\\n\\r\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\r\\n\\r\\n        emit NewImplementation(oldImplementation, implementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to an implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     */\\r\\n    function () external payable {\\r\\n        // delegate all other functions to current implementation\\r\\n        (bool success, ) = implementation.delegatecall(msg.data);\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 { revert(free_mem_ptr, returndatasize) }\\r\\n            default { return(free_mem_ptr, returndatasize) }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PEther/PEtherImmutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./PEther.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PEtherImmutable Contract\\r\\n * @notice PTokens which which wraps network native token and are immutable\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PEtherImmutable is PEther {\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     */\\r\\n    constructor(address comptroller_,\\r\\n                InterestRateModelInterface interestRateModel_,\\r\\n                uint initialExchangeRateMantissa_,\\r\\n                string memory name_,\\r\\n                string memory symbol_,\\r\\n                uint8 decimals_,\\r\\n                address payable admin_) public {\\r\\n        // Creator of the contract is admin during initialization\\r\\n        admin = msg.sender;\\r\\n\\r\\n        // Initialize the market\\r\\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\r\\n\\r\\n        // Set the proper admin now that initialization is done\\r\\n        admin = admin_;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Comptroller/ComptrollerInterfaces.sol\\\";\\r\\nimport \\\"../PToken/PTokenInterfaces.sol\\\";\\r\\nimport \\\"../ErrorReporter.sol\\\";\\r\\nimport \\\"../Utils/ExponentialNoError.sol\\\";\\r\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\r\\nimport \\\"../InterestRateModels/InterestRateModelInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Paribus PToken Contract\\r\\n * @notice Abstract base for PTokens\\r\\n * @author Compound, Paribus\\r\\n */\\r\\ncontract PToken is PTokenInterface, ExponentialNoError, TokenErrorReporter {\\r\\n    /**\\r\\n     * @notice Initialize the money market\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ EIP-20 name of this token\\r\\n     * @param symbol_ EIP-20 symbol of this token\\r\\n     * @param decimals_ EIP-20 decimal precision of this token\\r\\n     */\\r\\n    function initialize(address comptroller_,\\r\\n                        InterestRateModelInterface interestRateModel_,\\r\\n                        uint initialExchangeRateMantissa_,\\r\\n                        string memory name_,\\r\\n                        string memory symbol_,\\r\\n                        uint8 decimals_) public {\\r\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\r\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\r\\n\\r\\n        // Set initial exchange rate\\r\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\r\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero\\\");\\r\\n\\r\\n        // Set the comptroller\\r\\n        _setComptroller(comptroller_);\\r\\n\\r\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\r\\n        accrualBlockNumber = getBlockNumber();\\r\\n        borrowIndex = mantissaOne;\\r\\n\\r\\n        // Set the interest rate model (depends on block number / borrow index)\\r\\n        require(_setInterestRateModelFresh(interestRateModel_) == uint(Error.NO_ERROR), \\\"setting interest rate model failed\\\");\\r\\n\\r\\n        name = name_;\\r\\n        symbol = symbol_;\\r\\n        decimals = decimals_;\\r\\n\\r\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\r\\n     * @dev Called by both `transfer` and `transferFrom` internally\\r\\n     * @param spender The address of the account performing the transfer\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param tokens The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\r\\n        // Fail if transfer not allowed\\r\\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        // Do not allow self-transfers\\r\\n        if (src == dst) {\\r\\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\\r\\n        }\\r\\n\\r\\n        // Get the allowance, infinite for the account owner\\r\\n        uint startingAllowance = 0;\\r\\n        if (spender == src) {\\r\\n            startingAllowance = uint(-1);\\r\\n        } else {\\r\\n            startingAllowance = transferAllowances[src][spender];\\r\\n        }\\r\\n\\r\\n        // Do the calculations, checking for {under,over}flow\\r\\n        uint allowanceNew = sub_(startingAllowance, tokens, 'ALLOWANCE_NOT_ENOUGH');\\r\\n        uint srcTokensNew = sub_(accountTokens[src], tokens, 'BALANCE_NOT_ENOUGH');\\r\\n        uint dstTokensNew = add_(accountTokens[dst], tokens);\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        accountTokens[src] = srcTokensNew;\\r\\n        accountTokens[dst] = dstTokensNew;\\r\\n\\r\\n        // Eat some of the allowance (if necessary)\\r\\n        if (startingAllowance != uint(-1)) {\\r\\n            transferAllowances[src][spender] = allowanceNew;\\r\\n        }\\r\\n\\r\\n        // We emit a Transfer event\\r\\n        emit Transfer(src, dst, tokens);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.transferVerify(address(this), src, dst, tokens);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\\r\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\\r\\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\r\\n     * @return Whether or not the approval succeeded\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool) {\\r\\n        address src = msg.sender;\\r\\n        transferAllowances[src][spender] = amount;\\r\\n        emit Approval(src, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256) {\\r\\n        return transferAllowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the token balance of the `owner`\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The number of tokens owned by `owner`\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256) {\\r\\n        return accountTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the underlying balance of the `owner`\\r\\n     * @dev This also accrues interest in a transaction\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The amount of underlying owned by `owner`\\r\\n     */\\r\\n    function balanceOfUnderlying(address owner) external returns (uint) {\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\r\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the underlying balance of the `owner` based on stored data\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The amount of underlying owned by `owner`, with no interest accrued\\r\\n     */\\r\\n    function balanceOfUnderlyingStored(address owner) external view returns (uint) {\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStored()});\\r\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\r\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\r\\n     * @param account Address of the account to snapshot\\r\\n     * @return (token balance, borrow balance, exchange rate mantissa)\\r\\n     */\\r\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint) {\\r\\n        uint pTokenBalance = accountTokens[account];\\r\\n        uint borrowBalance = borrowBalanceStoredInternal(account);\\r\\n        uint exchangeRateMantissa = exchangeRateStoredInternal();\\r\\n\\r\\n        return (pTokenBalance, borrowBalance, exchangeRateMantissa);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to simply retrieve block number\\r\\n     *  This exists mainly for inheriting test contracts to stub this result.\\r\\n     */\\r\\n    function getBlockNumber() internal view returns (uint) {\\r\\n        return block.number;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current per-block borrow interest rate for this pToken\\r\\n     * @return The borrow interest rate per block, scaled by 1e18\\r\\n     */\\r\\n    function borrowRatePerBlock() external view returns (uint) {\\r\\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current per-block supply interest rate for this pToken\\r\\n     * @return The supply interest rate per block, scaled by 1e18\\r\\n     */\\r\\n    function supplyRatePerBlock() external view returns (uint) {\\r\\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current total borrows plus accrued interest\\r\\n     * @return The total borrows with interest\\r\\n     */\\r\\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n        return totalBorrows;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\r\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\r\\n     * @return The calculated balance\\r\\n     */\\r\\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n        return borrowBalanceStored(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the borrow balance of account based on stored data\\r\\n     * @param account The address whose balance should be calculated\\r\\n     * @return The calculated balance\\r\\n     */\\r\\n    function borrowBalanceStored(address account) public view returns (uint) {\\r\\n        return borrowBalanceStoredInternal(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the borrow balance of account based on stored data\\r\\n     * @param account The address whose balance should be calculated\\r\\n     * @return the calculated balance\\r\\n     */\\r\\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\\r\\n        // Get borrowBalance and borrowIndex\\r\\n        // Note: we do not assert that the market is up to date\\r\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\r\\n\\r\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\r\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\r\\n         */\\r\\n        if (borrowSnapshot.principal == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        /* Calculate new borrow balance using the interest index:\\r\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\r\\n         */\\r\\n        uint principalTimesIndex = mul_(borrowSnapshot.principal, borrowIndex);\\r\\n        return div_(principalTimesIndex, borrowSnapshot.interestIndex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue interest then return the up-to-date exchange rate\\r\\n     * @return Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n        return exchangeRateStored();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the exchange rate from the underlying to the PToken\\r\\n     * @dev This function does not accrue interest before calculating the exchange rate\\r\\n     * @return Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateStored() public view returns (uint) {\\r\\n        return exchangeRateStoredInternal();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the exchange rate from the underlying to the PToken\\r\\n     * @dev This function does not accrue interest before calculating the exchange rate\\r\\n     * @return calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateStoredInternal() internal view returns (uint) {\\r\\n        uint _totalSupply = totalSupply;\\r\\n        if (_totalSupply == 0) {\\r\\n            /*\\r\\n             * If there are no tokens minted:\\r\\n             *  exchangeRate = initialExchangeRate\\r\\n             */\\r\\n            return initialExchangeRateMantissa;\\r\\n        } else {\\r\\n            /*\\r\\n             * Otherwise:\\r\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\r\\n             */\\r\\n            uint totalCash = getCashPrior();\\r\\n            uint cashPlusBorrowsMinusReserves = sub_(add_(totalCash, totalBorrows), totalReserves);\\r\\n            return getExp_(cashPlusBorrowsMinusReserves, _totalSupply);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Get live borrow index, including interest rates\\r\\n    function getRealBorrowIndex() external view returns (uint) {\\r\\n        uint currentBlockNumber = getBlockNumber();\\r\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\r\\n\\r\\n        // Short-circuit accumulating 0 interest\\r\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\r\\n            return borrowIndex;\\r\\n        }\\r\\n\\r\\n        uint cashPrior = getCashPrior();\\r\\n        uint borrowsPrior = totalBorrows;\\r\\n        uint reservesPrior = totalReserves;\\r\\n        uint borrowIndexPrior = borrowIndex;\\r\\n\\r\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\r\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\r\\n\\r\\n        uint blockDelta = sub_(currentBlockNumber, accrualBlockNumberPrior);\\r\\n\\r\\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\\r\\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\r\\n\\r\\n        return borrowIndexNew;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get cash balance of this pToken in the underlying asset\\r\\n     * @return The quantity of underlying asset owned by this contract\\r\\n     */\\r\\n    function getCash() external view returns (uint) {\\r\\n        return getCashPrior();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Applies accrued interest to total borrows and reserves\\r\\n     * @dev This calculates interest accrued from the last checkpointed block up to the current block and writes new checkpoint to storage.\\r\\n     */\\r\\n    function accrueInterest() public {\\r\\n        uint currentBlockNumber = getBlockNumber();\\r\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\r\\n\\r\\n        // Short-circuit accumulating 0 interest\\r\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Read the previous values out of storage\\r\\n        uint cashPrior = getCashPrior();\\r\\n        uint borrowsPrior = totalBorrows;\\r\\n        uint reservesPrior = totalReserves;\\r\\n        uint borrowIndexPrior = borrowIndex;\\r\\n\\r\\n        // Calculate the current borrow interest rate\\r\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\r\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\r\\n\\r\\n        // Calculate the number of blocks elapsed since the last accrual\\r\\n        uint blockDelta = sub_(currentBlockNumber, accrualBlockNumberPrior);\\r\\n\\r\\n        /*\\r\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\r\\n         *  simpleInterestFactor = borrowRate * blockDelta\\r\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\r\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\r\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\r\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\r\\n         */\\r\\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\\r\\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\r\\n        uint totalBorrowsNew = add_(interestAccumulated, borrowsPrior);\\r\\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\\r\\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        // We write the previously calculated values into storage\\r\\n        accrualBlockNumber = currentBlockNumber;\\r\\n        borrowIndex = borrowIndexNew;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        // We emit an AccrueInterest event\\r\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives pTokens in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\r\\n     */\\r\\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\r\\n        return mintFresh(msg.sender, mintAmount);\\r\\n    }\\r\\n\\r\\n    struct MintLocalVars {\\r\\n        Error err;\\r\\n        uint exchangeRateMantissa;\\r\\n        uint mintTokens;\\r\\n        uint totalSupplyNew;\\r\\n        uint accountTokensNew;\\r\\n        uint actualMintAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User supplies assets into the market and receives pTokens in exchange\\r\\n     * @dev Assumes interest has already been accrued up to the current block\\r\\n     * @param minter The address of the account which is supplying the assets\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\r\\n     */\\r\\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\\r\\n        // Fail if mint not allowed\\r\\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\\r\\n        if (allowed != 0) {\\r\\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\\r\\n        }\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\\r\\n        }\\r\\n\\r\\n        MintLocalVars memory vars;\\r\\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\r\\n         *  Note: The pToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\r\\n         *  side-effects occurred. The function returns the amount actually transferred,\\r\\n         *  in case of a fee. On success, the pToken holds an additional `actualMintAmount`\\r\\n         *  of cash.\\r\\n         */\\r\\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\\r\\n\\r\\n        /*\\r\\n         * We get the current exchange rate and calculate the number of pTokens to be minted:\\r\\n         *  mintTokens = actualMintAmount / exchangeRate\\r\\n         */\\r\\n        vars.mintTokens = div_(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\\r\\n\\r\\n        /*\\r\\n         * We calculate the new total supply of pTokens and minter token balance, checking for overflow:\\r\\n         *  totalSupplyNew = totalSupply + mintTokens\\r\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\r\\n         */\\r\\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\\r\\n\\r\\n        if (totalSupply == 0 && MINIMUM_LIQUIDITY > 0) {\\r\\n            // first minter gets MINIMUM_LIQUIDITY pTokens less\\r\\n            vars.mintTokens = sub_(vars.mintTokens, MINIMUM_LIQUIDITY, 'FIRST_MINT_NOT_ENOUGH');\\r\\n\\r\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\r\\n            accountTokens[address(0)] = MINIMUM_LIQUIDITY;\\r\\n\\r\\n            // we dont emit any Transfer, Mint events for that\\r\\n        }\\r\\n\\r\\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\\r\\n\\r\\n        // We write previously calculated values into storage\\r\\n        totalSupply = vars.totalSupplyNew;\\r\\n        accountTokens[minter] = vars.accountTokensNew;\\r\\n\\r\\n        // We emit a Mint event and a Transfer event\\r\\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\\r\\n        emit Transfer(address(0), minter, vars.mintTokens);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\\r\\n\\r\\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for the underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemTokens The number of pTokens to redeem into underlying\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\r\\n        return redeemFresh(msg.sender, redeemTokens, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems pTokens in exchange for a specified amount of underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemAmount The amount of underlying to receive from redeeming pTokens\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\r\\n        return redeemFresh(msg.sender, 0, redeemAmount);\\r\\n    }\\r\\n\\r\\n    struct RedeemLocalVars {\\r\\n        Error err;\\r\\n        uint exchangeRateMantissa;\\r\\n        uint redeemTokens;\\r\\n        uint redeemAmount;\\r\\n        uint totalSupplyNew;\\r\\n        uint accountTokensNew;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User redeems pTokens in exchange for the underlying asset\\r\\n     * @dev Assumes interest has already been accrued up to the current block\\r\\n     * @param redeemer The address of the account which is redeeming the tokens\\r\\n     * @param redeemTokensIn The number of pTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\r\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming pTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\\r\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\\r\\n        }\\r\\n\\r\\n        RedeemLocalVars memory vars;\\r\\n\\r\\n        // exchangeRate = invoke Exchange Rate Stored()\\r\\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\\r\\n\\r\\n        // If redeemTokensIn > 0:\\r\\n        if (redeemTokensIn > 0) {\\r\\n            /*\\r\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\r\\n             *  redeemTokens = redeemTokensIn\\r\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\r\\n             */\\r\\n            vars.redeemTokens = redeemTokensIn;\\r\\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\\r\\n        } else {\\r\\n            /*\\r\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\r\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\r\\n             *  redeemAmount = redeemAmountIn\\r\\n             */\\r\\n\\r\\n            vars.redeemTokens = div_(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\\r\\n            vars.redeemAmount = redeemAmountIn;\\r\\n        }\\r\\n\\r\\n        // Fail if redeem not allowed\\r\\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        // Fail gracefully if protocol has insufficient cash\\r\\n        if (getCashPrior() < vars.redeemAmount) {\\r\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * We calculate the new total supply and redeemer balance, checking for underflow:\\r\\n         *  totalSupplyNew = totalSupply - redeemTokens\\r\\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\\r\\n         */\\r\\n        vars.totalSupplyNew = sub_(totalSupply, vars.redeemTokens, 'REDEEM_TOO_MUCH');\\r\\n        vars.accountTokensNew = sub_(accountTokens[redeemer], vars.redeemTokens, 'REDEEM_TOO_MUCH');\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\r\\n         *  Note: The pToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the pToken has redeemAmount less of cash.\\r\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         */\\r\\n        doTransferOut(redeemer, vars.redeemAmount);\\r\\n\\r\\n        // We write previously calculated values into storage\\r\\n        totalSupply = vars.totalSupplyNew;\\r\\n        accountTokens[redeemer] = vars.accountTokensNew;\\r\\n\\r\\n        // We emit a Transfer event, and a Redeem event\\r\\n        emit Transfer(redeemer, address(0), vars.redeemTokens);\\r\\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sender borrows assets from the protocol to their own address\\r\\n      * @param borrowAmount The amount of the underlying asset to borrow\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\r\\n        return borrowFresh(msg.sender, borrowAmount);\\r\\n    }\\r\\n\\r\\n    struct BorrowLocalVars {\\r\\n        uint accountBorrows;\\r\\n        uint accountBorrowsNew;\\r\\n        uint totalBorrowsNew;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Users borrow assets from the protocol to their own address\\r\\n      * @param borrowAmount The amount of the underlying asset to borrow\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\\r\\n        // Fail if borrow not allowed\\r\\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\\r\\n        }\\r\\n\\r\\n        // Fail gracefully if protocol has insufficient underlying cash\\r\\n        if (getCashPrior() < borrowAmount) {\\r\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\\r\\n        }\\r\\n\\r\\n        BorrowLocalVars memory vars;\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\r\\n         *  accountBorrowsNew = accountBorrows + borrowAmount\\r\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\r\\n         */\\r\\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\\r\\n        vars.accountBorrowsNew = add_(vars.accountBorrows, borrowAmount);\\r\\n        vars.totalBorrowsNew = add_(totalBorrows, borrowAmount);\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We write the previously calculated values into storage.\\r\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\r\\n        `*/\\r\\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = vars.totalBorrowsNew;\\r\\n\\r\\n        /*\\r\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\r\\n         *  Note: The pToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the pToken borrowAmount less of cash.\\r\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         */\\r\\n        doTransferOut(borrower, borrowAmount);\\r\\n\\r\\n        // We emit a Borrow event\\r\\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays their own borrow\\r\\n     * @param repayAmount The amount to repay\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\r\\n     */\\r\\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\r\\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays a borrow belonging to borrower\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount The amount to repay\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\r\\n     */\\r\\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\r\\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\\r\\n    }\\r\\n\\r\\n    struct RepayBorrowLocalVars {\\r\\n        Error err;\\r\\n        uint repayAmount;\\r\\n        uint borrowerIndex;\\r\\n        uint accountBorrows;\\r\\n        uint accountBorrowsNew;\\r\\n        uint totalBorrowsNew;\\r\\n        uint actualRepayAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\r\\n     * @param payer the account paying off the borrow\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount the amount of undelrying tokens being returned\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\r\\n     */\\r\\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\\r\\n        // Fail if repayBorrow not allowed\\r\\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\r\\n        if (allowed != 0) {\\r\\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\\r\\n        }\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\\r\\n        }\\r\\n\\r\\n        RepayBorrowLocalVars memory vars;\\r\\n\\r\\n        // We remember the original borrowerIndex for verification purposes\\r\\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\\r\\n\\r\\n        // We fetch the amount the borrower owes, with accumulated interest\\r\\n        vars.accountBorrows = borrowBalanceStoredInternal(borrower);\\r\\n\\r\\n        // If repayAmount == -1, repayAmount = accountBorrows\\r\\n        if (repayAmount == uint(-1)) {\\r\\n            vars.repayAmount = vars.accountBorrows;\\r\\n        } else {\\r\\n            vars.repayAmount = repayAmount;\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We call doTransferIn for the payer and the repayAmount\\r\\n         *  Note: The pToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the pToken holds an additional repayAmount of cash.\\r\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         *   it returns the amount actually transferred, in case of a fee.\\r\\n         */\\r\\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\r\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\r\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\r\\n         */\\r\\n        vars.accountBorrowsNew = sub_(vars.accountBorrows, vars.actualRepayAmount, \\\"REPAY_TOO_MUCH\\\");\\r\\n        vars.totalBorrowsNew = sub_(totalBorrows, vars.actualRepayAmount, \\\"REPAY_TOO_MUCH\\\");\\r\\n\\r\\n        // We write the previously calculated values into storage\\r\\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = vars.totalBorrowsNew;\\r\\n\\r\\n        // We emit a RepayBorrow event\\r\\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\\r\\n\\r\\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param borrower The borrower of this pToken to be liquidated\\r\\n     * @param pTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\r\\n     */\\r\\n    function liquidateBorrowInternal(address borrower, uint repayAmount, PTokenInterface pTokenCollateral) internal nonReentrant returns (uint, uint) {\\r\\n        require(pTokenCollateral.isPToken());\\r\\n\\r\\n        accrueInterest();\\r\\n        if (address(pTokenCollateral) != address(this)) {\\r\\n            pTokenCollateral.accrueInterest();\\r\\n        }\\r\\n\\r\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\r\\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, pTokenCollateral);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The liquidator liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param borrower The borrower of this pToken to be liquidated\\r\\n     * @param liquidator The address repaying the borrow and seizing collateral\\r\\n     * @param pTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\r\\n     */\\r\\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, PTokenInterface pTokenCollateral) internal returns (uint, uint) {\\r\\n        // Fail if liquidate not allowed\\r\\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(pTokenCollateral), liquidator, borrower, repayAmount);\\r\\n        if (allowed != 0) {\\r\\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\\r\\n        }\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\\r\\n        }\\r\\n\\r\\n        // Verify pTokenCollateral market's block number equals current block number\\r\\n        if (pTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\r\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\\r\\n        }\\r\\n\\r\\n        // Fail if borrower = liquidator\\r\\n        if (borrower == liquidator) {\\r\\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\\r\\n        }\\r\\n\\r\\n        // Fail if repayAmount = 0\\r\\n        if (repayAmount == 0) {\\r\\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\\r\\n        }\\r\\n\\r\\n        // Fail if repayAmount = -1\\r\\n        if (repayAmount == uint(-1)) {\\r\\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\\r\\n        }\\r\\n\\r\\n        // Fail if repayBorrow fails\\r\\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\\r\\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\\r\\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        // We calculate the number of collateral tokens that will be seized\\r\\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(pTokenCollateral), actualRepayAmount);\\r\\n        require(amountSeizeError == uint(Error.NO_ERROR), \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\r\\n\\r\\n        // Revert if borrower collateral token balance < seizeTokens\\r\\n        require(pTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\r\\n\\r\\n        // If this is also the collateral, run seizeInternal to avoid reentrancy, otherwise make an external call\\r\\n        uint seizeError;\\r\\n        if (address(pTokenCollateral) == address(this)) {\\r\\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\\r\\n        } else {\\r\\n            seizeError = pTokenCollateral.seize(liquidator, borrower, seizeTokens);\\r\\n        }\\r\\n\\r\\n        // Revert if seize tokens fails (since we cannot be sure of side effects)\\r\\n        require(seizeError == uint(Error.NO_ERROR), \\\"token seizure failed\\\");\\r\\n\\r\\n        // We emit a LiquidateBorrow event\\r\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(pTokenCollateral), seizeTokens);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.liquidateBorrowVerify(address(this), address(pTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\\r\\n\\r\\n        return (uint(Error.NO_ERROR), actualRepayAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\r\\n     * @dev Will fail unless called by another pToken during the process of liquidation.\\r\\n     *  Its absolutely critical to use msg.sender as the borrowed pToken and not a parameter.\\r\\n     * @param liquidator The account receiving seized collateral\\r\\n     * @param borrower The account having collateral seized\\r\\n     * @param seizeTokens The number of pTokens to seize\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\\r\\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\r\\n    }\\r\\n\\r\\n    struct SeizeInternalLocalVars {\\r\\n        uint borrowerTokensNew;\\r\\n        uint liquidatorTokensNew;\\r\\n        uint liquidatorSeizeTokens;\\r\\n        uint protocolSeizeTokens;\\r\\n        uint protocolSeizeAmount;\\r\\n        uint exchangeRateMantissa;\\r\\n        uint totalReservesNew;\\r\\n        uint totalSupplyNew;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\r\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another PToken.\\r\\n     *  Its absolutely critical to use msg.sender as the seizer pToken and not a parameter.\\r\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed pToken)\\r\\n     * @param liquidator The account receiving seized collateral\\r\\n     * @param borrower The account having collateral seized\\r\\n     * @param seizeTokens The number of pTokens to seize\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\\r\\n        // Fail if seize not allowed\\r\\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\r\\n        if (allowed != 0) {\\r\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\\r\\n        }\\r\\n\\r\\n        // Fail if borrower = liquidator\\r\\n        if (borrower == liquidator) {\\r\\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\\r\\n        }\\r\\n\\r\\n        SeizeInternalLocalVars memory vars;\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\r\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\r\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\r\\n         */\\r\\n        vars.borrowerTokensNew = sub_(accountTokens[borrower], seizeTokens, 'SEIZE_TOO_MUCH');\\r\\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\\r\\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens, 'SEIZE_TOO_MUCH');\\r\\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\\r\\n        vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);\\r\\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\\r\\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens, 'SEIZE_TOO_MUCH');\\r\\n        vars.liquidatorTokensNew = add_(accountTokens[liquidator], vars.liquidatorSeizeTokens);\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        // We write the previously calculated values into storage\\r\\n        totalReserves = vars.totalReservesNew;\\r\\n        totalSupply = vars.totalSupplyNew;\\r\\n        accountTokens[borrower] = vars.borrowerTokensNew;\\r\\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\\r\\n\\r\\n        // Emit a Transfer event\\r\\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\\r\\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\\r\\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\\r\\n\\r\\n        // We call the defense hook\\r\\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    /**\\r\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @param newPendingAdmin New pending admin.\\r\\n      */\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) external {\\r\\n        onlyAdmin();\\r\\n\\r\\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin);\\r\\n        pendingAdmin = newPendingAdmin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\r\\n      * @dev Admin function for pending admin to accept role and update admin\\r\\n      */\\r\\n    function _acceptAdmin() external {\\r\\n        require(msg.sender == pendingAdmin, 'only pending admin');\\r\\n\\r\\n        emit NewAdmin(admin, pendingAdmin);\\r\\n        emit NewPendingAdmin(pendingAdmin, address(0));\\r\\n        admin = pendingAdmin;\\r\\n        pendingAdmin = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets a new comptroller for the market\\r\\n      * @dev Admin function to set a new comptroller\\r\\n      */\\r\\n    function _setComptroller(address newComptroller) public {\\r\\n        onlyAdmin();\\r\\n        require(ComptrollerNoNFTInterface(newComptroller).isComptroller());\\r\\n\\r\\n        emit NewComptroller(address(comptroller), newComptroller);\\r\\n        comptroller = ComptrollerNoNFTInterface(newComptroller);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to set the protocolSeizeShareMantissa value\\r\\n     * @param newProtocolSeizeShareMantissa new protocolSeizeShareMantissa value\\r\\n     */\\r\\n    function _setProtocolSeizeShareMantissa(uint newProtocolSeizeShareMantissa) external {\\r\\n        onlyAdmin();\\r\\n\\r\\n        emit NewProtocolSeizeShareMantissa(protocolSeizeShareMantissa, newProtocolSeizeShareMantissa);\\r\\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\r\\n      * @dev Admin function to accrue interest and set a new reserve factor\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\r\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\r\\n      * @dev Admin function to set a new reserve factor\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\\r\\n        onlyAdmin();\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\\r\\n        }\\r\\n\\r\\n        // Check newReserveFactor \u00e2\u2030\u00a4 maxReserveFactor\\r\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\r\\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\\r\\n        }\\r\\n\\r\\n        emit NewReserveFactor(reserveFactorMantissa, newReserveFactorMantissa);\\r\\n        reserveFactorMantissa = newReserveFactorMantissa;\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\r\\n     * @param addAmount Amount of addition to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\r\\n        (uint error, ) = _addReservesFresh(addAmount);\\r\\n        return error;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add reserves by transferring from caller\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param addAmount Amount of addition to reserves\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\r\\n     */\\r\\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), 0);\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We call doTransferIn for the caller and the addAmount\\r\\n         *  Note: The pToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the pToken holds an additional addAmount of cash.\\r\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         *  it returns the amount actually transferred, in case of a fee.\\r\\n         */\\r\\n\\r\\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount);\\r\\n\\r\\n        uint totalReservesNew = totalReserves + actualAddAmount;\\r\\n\\r\\n        // Revert on overflow\\r\\n        require(totalReservesNew >= totalReserves, \\\"add reserves unexpected overflow\\\");\\r\\n\\r\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\r\\n\\r\\n        return (uint(Error.NO_ERROR), actualAddAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\r\\n        return _reduceReservesFresh(reduceAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reduces reserves by transferring to admin\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\r\\n        onlyAdmin();\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\\r\\n        }\\r\\n\\r\\n        // Fail gracefully if protocol has insufficient underlying cash\\r\\n        if (getCashPrior() < reduceAmount) {\\r\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\\r\\n        }\\r\\n\\r\\n        // Check reduceAmount \u00e2\u2030\u00a4 reserves[n] (totalReserves)\\r\\n        if (reduceAmount > totalReserves) {\\r\\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        // totalReserves - reduceAmount\\r\\n        uint totalReservesNew = totalReserves - reduceAmount;\\r\\n\\r\\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\\r\\n        require(totalReservesNew <= totalReserves, \\\"reduce reserves unexpected underflow\\\");\\r\\n\\r\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n        doTransferOut(admin, reduceAmount);\\r\\n\\r\\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\r\\n     * @dev Admin function to accrue interest and update the interest rate model\\r\\n     * @param newInterestRateModel the new interest rate model to use\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setInterestRateModel(InterestRateModelInterface newInterestRateModel) public returns (uint) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\r\\n        return _setInterestRateModelFresh(newInterestRateModel);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\r\\n     * @dev Admin function to update the interest rate model\\r\\n     * @param newInterestRateModel the new interest rate model to use\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setInterestRateModelFresh(InterestRateModelInterface newInterestRateModel) internal returns (uint) {\\r\\n        onlyAdmin();\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\\r\\n        }\\r\\n\\r\\n        require(newInterestRateModel.isInterestRateModel());\\r\\n\\r\\n        emit NewMarketInterestRateModel(interestRateModel, newInterestRateModel);\\r\\n        interestRateModel = newInterestRateModel;\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\r\\n     *  This may revert due to insufficient balance or insufficient allowance.\\r\\n     */\\r\\n    function doTransferIn(address from, uint amount) internal returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\\r\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\r\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\r\\n     */\\r\\n    function doTransferOut(address payable to, uint amount) internal;\\r\\n\\r\\n    /*** Reentrancy Guard ***/\\r\\n\\r\\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"reentered\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true; // get a gas-refund post-Istanbul\\r\\n    }\\r\\n\\r\\n    /// @notice Checks caller is admin\\r\\n    function onlyAdmin() internal view {\\r\\n        require(msg.sender == admin, \\\"only admin\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PToken/PTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"../Comptroller/ComptrollerInterfaces.sol\\\";\\r\\nimport \\\"../InterestRateModels/InterestRateModelInterface.sol\\\";\\r\\nimport \\\"../Interfaces/EIP20NonStandardInterface.sol\\\";\\r\\n\\r\\ncontract PTokenStorage {\\r\\n    /// @dev Guard variable for reentrancy checks\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /// @notice EIP-20 token name for this token\\r\\n    string public name;\\r\\n\\r\\n    /// @notice EIP-20 token symbol for this token\\r\\n    string public symbol;\\r\\n\\r\\n    /// @notice EIP-20 token decimals for this token\\r\\n    uint8 public decimals;\\r\\n\\r\\n    /// @notice Maximum borrow rate that can ever be applied (.0005% / block)\\r\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\r\\n\\r\\n    /// @notice Maximum fraction of interest that can be set aside for reserves\\r\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\r\\n\\r\\n    /// @notice Administrator for this contract\\r\\n    address payable public admin;\\r\\n\\r\\n    /// @notice Pending administrator for this contract\\r\\n    address payable public pendingAdmin;\\r\\n\\r\\n    /// @notice Contract which oversees inter-pToken operations\\r\\n    ComptrollerNoNFTInterface public comptroller;\\r\\n\\r\\n    /// @notice Model which tells what the current interest rate should be\\r\\n    InterestRateModelInterface public interestRateModel;\\r\\n\\r\\n    /// @notice Initial exchange rate used when minting the first PTokens (used when totalSupply = 0)\\r\\n    uint internal initialExchangeRateMantissa;\\r\\n\\r\\n    /// @notice Fraction of interest currently set aside for reserves\\r\\n    uint public reserveFactorMantissa;\\r\\n\\r\\n    /// @notice Block number that interest was last accrued at\\r\\n    uint public accrualBlockNumber;\\r\\n\\r\\n    /// @notice Accumulator of the total earned interest rate since the opening of the market\\r\\n    uint public borrowIndex;\\r\\n\\r\\n    /// @notice Total amount of outstanding borrows of the underlying in this market\\r\\n    uint public totalBorrows;\\r\\n\\r\\n    /// @notice Total amount of reserves of the underlying held in this market\\r\\n    uint public totalReserves;\\r\\n\\r\\n    /// @notice Total number of tokens in circulation\\r\\n    uint public totalSupply;\\r\\n\\r\\n    /// @notice Official record of token balances for each account\\r\\n    mapping (address => uint) internal accountTokens;\\r\\n\\r\\n    /// @notice Approved token transfer amounts on behalf of others\\r\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\r\\n\\r\\n    /**\\r\\n     * @notice Container for borrow balance information\\r\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\r\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\r\\n     */\\r\\n    struct BorrowSnapshot {\\r\\n        uint principal;\\r\\n        uint interestIndex;\\r\\n    }\\r\\n\\r\\n    /// @notice Mapping of account addresses to outstanding borrow balances\\r\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\r\\n\\r\\n    /// @notice Share of seized collateral that is added to reserves\\r\\n    uint public protocolSeizeShareMantissa = 5e16; // 5%;  0% == disabled\\r\\n\\r\\n    /// @notice First MINIMUM_LIQUIDITY minted pTokens gets locked on address(0) to prevent totalSupply being 0\\r\\n    uint public constant MINIMUM_LIQUIDITY = 10000;\\r\\n}\\r\\n\\r\\ncontract PTokenInterface is PTokenStorage {\\r\\n    /// @notice Indicator that this is a PToken contract (for inspection)\\r\\n    bool public constant isPToken = true;\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /// @notice Event emitted when interest is accrued\\r\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\r\\n\\r\\n    /// @notice Event emitted when tokens are minted\\r\\n    event Mint(address indexed minter, uint mintAmount, uint mintTokens);\\r\\n\\r\\n    /// @notice Event emitted when tokens are redeemed\\r\\n    event Redeem(address indexed redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\r\\n    /// @notice Event emitted when underlying is borrowed\\r\\n    event Borrow(address indexed borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\r\\n\\r\\n    /// @notice Event emitted when a borrow is repaid\\r\\n    event RepayBorrow(address indexed payer, address indexed borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\r\\n\\r\\n    /// @notice Event emitted when a borrow is liquidated\\r\\n    event LiquidateBorrow(address indexed liquidator, address indexed borrower, uint repayAmount, address indexed pTokenCollateral, uint seizeTokens);\\r\\n\\r\\n    /// @notice EIP20 Transfer event\\r\\n    event Transfer(address indexed from, address indexed to, uint amount);\\r\\n\\r\\n    /// @notice EIP20 Approval event\\r\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\r\\n\\r\\n    /// @notice Failure event\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /// @notice Event emitted when pendingAdmin is changed\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /// @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /// @notice Event emitted when comptroller is changed\\r\\n    event NewComptroller(address oldComptroller, address newComptroller);\\r\\n\\r\\n    /// @notice Event emitted when interestRateModel is changed\\r\\n    event NewMarketInterestRateModel(InterestRateModelInterface oldInterestRateModel, InterestRateModelInterface newInterestRateModel);\\r\\n\\r\\n    /// @notice Event emitted when the reserve factor is changed\\r\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\r\\n\\r\\n    /// @notice Event emitted when the reserves are added\\r\\n    event ReservesAdded(address indexed benefactor, uint addAmount, uint newTotalReserves);\\r\\n\\r\\n    /// @notice Event emitted when the reserves are reduced\\r\\n    event ReservesReduced(address indexed admin, uint reduceAmount, uint newTotalReserves);\\r\\n\\r\\n    /// @notice Event emitted when protocolSeizeShareMantissa is changed\\r\\n    event NewProtocolSeizeShareMantissa(uint oldProtocolSeizeShareMantissa, uint newProtocolSeizeShareMantissa);\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function transfer(address dst, uint amount) external returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function balanceOfUnderlying(address owner) external returns (uint);\\r\\n    function balanceOfUnderlyingStored(address owner) external view returns (uint);\\r\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint);\\r\\n    function borrowRatePerBlock() external view returns (uint);\\r\\n    function supplyRatePerBlock() external view returns (uint);\\r\\n    function totalBorrowsCurrent() external returns (uint);\\r\\n    function borrowBalanceCurrent(address account) external returns (uint);\\r\\n    function borrowBalanceStored(address account) public view returns (uint);\\r\\n    function exchangeRateCurrent() public returns (uint);\\r\\n    function exchangeRateStored() public view returns (uint);\\r\\n    function getCash() external view returns (uint);\\r\\n    function getRealBorrowIndex() external view returns (uint);\\r\\n    function accrueInterest() public;\\r\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) external;\\r\\n    function _acceptAdmin() external;\\r\\n    function _setComptroller(address newComptroller) public;\\r\\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\\r\\n    function _reduceReserves(uint reduceAmount) external returns (uint);\\r\\n    function _setInterestRateModel(InterestRateModelInterface newInterestRateModel) public returns (uint);\\r\\n    function _setProtocolSeizeShareMantissa(uint newProtocolSeizeShareMantissa) external;\\r\\n}\\r\\n\\r\\ncontract PErc20Storage {\\r\\n    /// @notice Underlying asset for this PToken\\r\\n    address public underlying;\\r\\n}\\r\\n\\r\\ncontract PErc20Interface is PErc20Storage, PTokenInterface {\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint mintAmount) external returns (uint);\\r\\n    function redeem(uint redeemTokens) external returns (uint);\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\r\\n    function borrow(uint borrowAmount) external returns (uint);\\r\\n    function repayBorrow(uint repayAmount) external returns (uint);\\r\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\r\\n    function liquidateBorrow(address borrower, uint repayAmount, PTokenInterface pTokenCollateral) external returns (uint);\\r\\n    function sweepToken(EIP20NonStandardInterface token) external;\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _addReserves(uint addAmount) external returns (uint);\\r\\n}\\r\\n\\r\\ncontract PTokenDelegationStorage {\\r\\n    /// @notice Implementation address for this contract\\r\\n    address public implementation;\\r\\n}\\r\\n\\r\\ncontract PTokenDelegatorInterface is PTokenDelegationStorage {\\r\\n    /// @notice Emitted when implementation is changed\\r\\n    event NewImplementation(address oldImplementation, address newImplementation);\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the admin to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\\r\\n}\\r\\n\\r\\ncontract PTokenDelegateInterface is PTokenInterface, PTokenDelegationStorage {\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\r\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes calldata data) external;\\r\\n\\r\\n    /// @notice Called by the delegator on a delegate to forfeit its responsibility\\r\\n    function _resignImplementation() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Utils/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @title Exponential module for storing fixed-precision decimals\\r\\n * @author Compound\\r\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\r\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\r\\n *         `Exp({mantissa: 5100000000000000000})`.\\r\\n */\\r\\ncontract ExponentialNoError {\\r\\n    uint constant expScale = 1e18;\\r\\n    uint constant doubleScale = 1e36;\\r\\n    uint constant halfExpScale = expScale/2;\\r\\n    uint constant mantissaOne = expScale;\\r\\n\\r\\n    struct Exp {\\r\\n        uint mantissa;\\r\\n    }\\r\\n\\r\\n    struct Double {\\r\\n        uint mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Truncates the given exp to a whole number value.\\r\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\r\\n     */\\r\\n    function truncate(Exp memory exp) internal pure returns (uint) {\\r\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\r\\n        return exp.mantissa / expScale;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\r\\n     */\\r\\n    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return truncate(product);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\r\\n     */\\r\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return add_(truncate(product), addend);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if first Exp is less than second Exp.\\r\\n     */\\r\\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\r\\n        return left.mantissa < right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if left Exp <= right Exp.\\r\\n     */\\r\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\r\\n        return left.mantissa <= right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if left Exp > right Exp.\\r\\n     */\\r\\n    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\r\\n        return left.mantissa > right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns true if Exp is exactly zero\\r\\n     */\\r\\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\\r\\n        return value.mantissa == 0;\\r\\n    }\\r\\n\\r\\n    function safe224(uint n, string memory errorMessage) internal pure returns (uint224) {\\r\\n        require(n < 2**224, errorMessage);\\r\\n        return uint224(n);\\r\\n    }\\r\\n\\r\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(n < 2**32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function add_(uint a, uint b) internal pure returns (uint) {\\r\\n        return add_(a, b, \\\"addition overflow\\\");\\r\\n    }\\r\\n\\r\\n    function add_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        uint c = a + b;\\r\\n        require(c >= a, errorMessage);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function sub_(Exp memory a, Exp memory b, string memory errorMessage) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa, errorMessage)});\\r\\n    }\\r\\n\\r\\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function sub_(uint a, uint b) internal pure returns (uint) {\\r\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        require(b <= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, Exp memory b) internal pure returns (uint) {\\r\\n        return mul_(a, b.mantissa) / expScale;\\r\\n    }\\r\\n\\r\\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\r\\n    }\\r\\n\\r\\n    function mul_(Double memory a, uint b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: mul_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, Double memory b) internal pure returns (uint) {\\r\\n        return mul_(a, b.mantissa) / doubleScale;\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, uint b) internal pure returns (uint) {\\r\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        if (a == 0 || b == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint c = a * b;\\r\\n        require(c / a == b, errorMessage);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: div_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function div_(uint a, Exp memory b) internal pure returns (uint) {\\r\\n        return div_(mul_(a, expScale), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function div_(Double memory a, uint b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: div_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function div_(uint a, Double memory b) internal pure returns (uint) {\\r\\n        return div_(mul_(a, doubleScale), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(uint a, uint b) internal pure returns (uint) {\\r\\n        return div_(a, b, \\\"divide by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div_(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        require(b > 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function fraction(uint a, uint b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates an exponential from numerator and denominator values.\\r\\n     *      Note: Reverts if (`num` * 10e18) > MAX_INT or if `denom` is zero.\\r\\n     */\\r\\n    function getExp_(uint num, uint denom) internal pure returns (uint) {\\r\\n        uint scaledNumerator = mul_(num, expScale);\\r\\n        return div_(scaledNumerator, denom);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/*\\r\\n * Ownable\\r\\n *\\r\\n * Base contract with an owner.\\r\\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address public owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), owner);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"only admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        if (newOwner != address(0)) {\\r\\n            emit OwnershipTransferred(owner, newOwner);\\r\\n            owner = newOwner;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\r\\n// Subject to the MIT license.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, errorMessage);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot underflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot underflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, errorMessage);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers.\\r\\n     * Reverts on division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers.\\r\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptroller_\",\"type\":\"address\"},{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"becomeImplementationData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowResign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"becomeImplementationData\",\"type\":\"bytes\"}],\"name\":\"_setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"internalType\":\"contract ComptrollerNoNFTInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolSeizeShareMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
    "ContractName": "PEtherDelegator",
    "CompilerVersion": "v0.5.17+commit.d19bba13",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "0000000000000000000000002130c88fd0891ea79430fb490598a5d06bf2a5450000000000000000000000004370ae1da158b4f5c42062db268354d7a24bff9a000000000000000000000000000000000000000000a56fa5b99019a5c80000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000080000000000000000000000008acd5764d8edef0558dbdf40ae64c7ffb65311600000000000000000000000005b0ec471565e36e5a33c35b861dd752e16f3a8e700000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000d5061726962757320457468657200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000470455448000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "BSD-3-Clause",
    "Proxy": "1",
    "Implementation": "0x5b0ec471565e36e5a33c35b861dd752e16f3a8e7",
    "SwarmSource": "bzzr://fe022dae5d71d19c658e5a5c0557e4e1e2feb7285491e541a032a2d3d06a7ed3"
}