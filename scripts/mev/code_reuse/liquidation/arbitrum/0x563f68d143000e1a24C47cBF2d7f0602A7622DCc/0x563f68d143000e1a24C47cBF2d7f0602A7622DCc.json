{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BaseJumpRateModelV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./InterestRateModel.sol\\\";\\n\\n/**\\n  * @title Logic for Compound's JumpRateModel Contract V2.\\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\\n  */\\nabstract contract BaseJumpRateModelV2 is InterestRateModel {\\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\\n\\n    uint256 private constant BASE = 1e18;\\n\\n    /**\\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\\n     */\\n    address public owner;\\n\\n    /**\\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\\n     */\\n    uint public constant blocksPerYear = 144752795;\\n\\n    /**\\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\\n     */\\n    uint public multiplierPerBlock;\\n\\n    /**\\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\\n     */\\n    uint public baseRatePerBlock;\\n\\n    /**\\n     * @notice The multiplierPerBlock after hitting a specified utilization point\\n     */\\n    uint public jumpMultiplierPerBlock;\\n\\n    /**\\n     * @notice The utilization point at which the jump multiplier is applied\\n     */\\n    uint public kink;\\n\\n    /**\\n     * @notice Construct an interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\\n     */\\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal {\\n        owner = owner_;\\n\\n        updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);\\n    }\\n\\n    /**\\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) virtual external {\\n        require(msg.sender == owner, \\\"only the owner may call this function.\\\");\\n\\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\\n    }\\n\\n    /**\\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market (currently unused)\\n     * @return The utilization rate as a mantissa between [0, BASE]\\n     */\\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\\n        // Utilization rate is 0 when there are no borrows\\n        if (borrows == 0) {\\n            return 0;\\n        }\\n\\n        return borrows * BASE / (cash + borrows - reserves);\\n    }\\n\\n    /**\\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\\n     */\\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\\n        uint util = utilizationRate(cash, borrows, reserves);\\n\\n        if (util <= kink) {\\n            return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\\n        } else {\\n            uint normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\\n            uint excessUtil = util - kink;\\n            return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the current supply rate per block\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @param reserveFactorMantissa The current reserve factor for the market\\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\\n     */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual override public view returns (uint) {\\n        uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\\n        uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\\n        return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\\n    }\\n\\n    /**\\n     * @notice Internal function to update the parameters of the interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {\\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\\n        multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\\n        kink = kink_;\\n\\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n  * @title Compound's InterestRateModel Interface\\n  * @author Compound\\n  */\\nabstract contract InterestRateModel {\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n    bool public constant isInterestRateModel = true;\\n\\n    /**\\n      * @notice Calculates the current borrow interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\\n\\n    /**\\n      * @notice Calculates the current supply interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param reserveFactorMantissa The current reserve factor the market has\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/JumpRateModelV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./BaseJumpRateModelV2.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\n\\n\\n/**\\n  * @title Compound's JumpRateModel Contract V2 for V2 cTokens\\n  * @author Arr00\\n  * @notice Supports only for V2 cTokens\\n  */\\ncontract JumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2  {\\n\\n\\t/**\\n     * @notice Calculates the current borrow rate per block\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\\n     */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) override external view returns (uint) {\\n        return getBorrowRateInternal(cash, borrows, reserves);\\n    }\\n\\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_)\\n\\n    BaseJumpRateModelV2(baseRatePerYear,multiplierPerYear,jumpMultiplierPerYear,kink_,owner_) public {}\\n}\\n\"\r\n    },\r\n    \"contracts/JumpRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./InterestRateModel.sol\\\";\\n\\n/**\\n  * @title Compound's JumpRateModel Contract\\n  * @author Compound\\n  */\\ncontract JumpRateModel is InterestRateModel {\\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\\n\\n    uint256 private constant BASE = 1e18;\\n\\n    /**\\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\\n     */\\n    uint public constant blocksPerYear = 144752795;\\n\\n    /**\\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\\n     */\\n    uint public multiplierPerBlock;\\n\\n    /**\\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\\n     */\\n    uint public baseRatePerBlock;\\n\\n    /**\\n     * @notice The multiplierPerBlock after hitting a specified utilization point\\n     */\\n    uint public jumpMultiplierPerBlock;\\n\\n    /**\\n     * @notice The utilization point at which the jump multiplier is applied\\n     */\\n    uint public kink;\\n\\n    /**\\n     * @notice Construct an interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) public {\\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\\n        multiplierPerBlock = multiplierPerYear / blocksPerYear;\\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\\n        kink = kink_;\\n\\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\\n    }\\n\\n    /**\\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market (currently unused)\\n     * @return The utilization rate as a mantissa between [0, BASE]\\n     */\\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\\n        // Utilization rate is 0 when there are no borrows\\n        if (borrows == 0) {\\n            return 0;\\n        }\\n\\n        return borrows * BASE / (cash + borrows - reserves);\\n    }\\n\\n    /**\\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\\n     */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) override public view returns (uint) {\\n        uint util = utilizationRate(cash, borrows, reserves);\\n\\n        if (util <= kink) {\\n            return (util * multiplierPerBlock / BASE) + baseRatePerBlock;\\n        } else {\\n            uint normalRate = (kink * multiplierPerBlock / BASE) + baseRatePerBlock;\\n            uint excessUtil = util - kink;\\n            return (excessUtil * jumpMultiplierPerBlock/ BASE) + normalRate;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the current supply rate per block\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @param reserveFactorMantissa The current reserve factor for the market\\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\\n     */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) override public view returns (uint) {\\n        uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\\n        uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\\n        return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ComptrollerInterface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./IGmxRewardRouter.sol\\\";\\nimport \\\"./IStakedGlp.sol\\\";\\nimport \\\"./IRewardTracker.sol\\\";\\n\\ncontract CTokenStorage {\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice Is the underlying token GLP\\n     */\\n    bool public isGLP;\\n\\n    /**\\n     * @notice Wether or not the eth rewards from glp market should be autocompounded\\n     */\\n    bool public autocompound;\\n\\n    /**\\n     * @notice GLP reward router for claiming rewards\\n     */\\n    IGmxRewardRouter public glpRewardRouter = IGmxRewardRouter(0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1);\\n\\n    /**\\n     * @notice Staked GLP Adress to call transfer on\\n     */\\n    IStakedGlp public stakedGLP = IStakedGlp(0x2F546AD4eDD93B956C8999Be404cdCAFde3E89AE);\\n\\n    /**\\n     * @notice address of the GMX token\\n     */\\n    address public gmxToken = 0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a;\\n\\n    /**\\n     * @notice Address that handles GMX staking\\n     */\\n    IRewardTracker public stakedGmxTracker = IRewardTracker(0x908C4D94D34924765f1eDc22A1DD098397c59dD4);\\n\\n    /**\\n     * @notice address of the Staked GMX token\\n     */\\n    address public sbfGMX = 0xd2D1162512F927a7e282Ef43a362659E4F2a728F;\\n\\n    /**\\n     * @notice Staked GLP Adress to call transfer on\\n     */\\n    address public immutable WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\\n\\n    /**\\n     * @notice GLP manager contract to approve transfers on for autocompounding\\n     */\\n    address public glpManager = 0x321F653eED006AD1C29D174e17d96351BDe22649;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n    // Maximum fraction of interest that can be set aside for reserves\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\n\\n    /**\\n     * @notice Administrator for this contract\\n     */\\n    address payable public admin;\\n\\n    /**\\n     * @notice Pending administrator for this contract\\n     */\\n    address payable public pendingAdmin;\\n\\n    /**\\n     * @notice Contract which oversees inter-cToken operations\\n     */\\n    ComptrollerInterface public comptroller;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\\n    uint internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint public totalSupply;\\n\\n    /**\\n     * @notice Withdraw fee for strategy vaults\\n     */\\n    uint256 public withdrawFee;\\n\\n    /**\\n     * @notice Management fee for strategy vaults\\n     */\\n    uint256 public managementFee;\\n\\n    // Official record of token balances for each account\\n    mapping (address => uint) internal accountTokens;\\n\\n    // Approved token transfer amounts on behalf of others\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\n\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint principal;\\n        uint interestIndex;\\n    }\\n\\n    // Mapping of account addresses to outstanding borrow balances\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Share of seized collateral that is added to reserves\\n     */\\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\\n}\\n\\nabstract contract CTokenInterface is CTokenStorage {\\n    /**\\n     * @notice Indicator that this is a CToken contract (for inspection)\\n     */\\n    bool public constant isCToken = true;\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\\n\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is changed\\n     */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\n     */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /**\\n     * @notice Event emitted when comptroller is changed\\n     */\\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n\\n    /*** User Interface ***/\\n\\n    function transfer(address dst, uint amount) virtual external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\\n    function approve(address spender, uint amount) virtual external returns (bool);\\n    function allowance(address owner, address spender) virtual external view returns (uint);\\n    function balanceOf(address owner) virtual external view returns (uint);\\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() virtual external view returns (uint);\\n    function supplyRatePerBlock() virtual external view returns (uint);\\n    function totalBorrowsCurrent() virtual external returns (uint);\\n    function borrowBalanceCurrent(address account) virtual external returns (uint);\\n    function borrowBalanceStored(address account) virtual external view returns (uint);\\n    function exchangeRateCurrent() virtual external returns (uint);\\n    function exchangeRateStored() virtual external view returns (uint);\\n    function getCash() virtual external view returns (uint);\\n    function accrueInterest() virtual external returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\\n\\n\\n    /*** Admin Functions ***/\\n\\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\\n    function _acceptAdmin() virtual external returns (uint);\\n    function _setComptroller(ComptrollerInterface newComptroller) virtual external returns (uint);\\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);\\n    function _setGlpAddresses(IStakedGlp stakedGLP_, IGmxRewardRouter glpRewardRouter_, address glpManager_) virtual public returns (uint);\\n    function _signalTransfer(address recipient) virtual public returns (uint);\\n    function _setAutocompoundRewards(bool autocompound_) virtual public returns (uint);\\n    function _setVaultFees(uint256 withdrawFee_, uint256 managementFee_) virtual public returns (uint);\\n}\\n\\ncontract CErc20Storage {\\n    /**\\n     * @notice Underlying asset for this CToken\\n     */\\n    address public underlying;\\n}\\n\\nabstract contract CErc20Interface is CErc20Storage {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) virtual external returns (uint);\\n    function redeem(uint redeemTokens) virtual external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\\n    function borrow(uint borrowAmount) virtual external returns (uint);\\n    function repayBorrow(uint repayAmount) virtual external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) virtual external returns (uint);\\n    function sweepToken(EIP20NonStandardInterface token) virtual external;\\n    function depositNFT(address _NFTAddress, uint256 _TokenID) virtual external;\\n    function withdrawNFT(address _NFTAddress, uint256 _TokenID) virtual external;\\n\\n    \\n\\n    /*** Admin Functions ***/\\n\\n    function _addReserves(uint addAmount) virtual external returns (uint);\\n}\\n\\ncontract CDelegationStorage {\\n    /**\\n     * @notice Implementation address for this contract\\n     */\\n    address public implementation;\\n}\\n\\nabstract contract CDelegatorInterface is CDelegationStorage {\\n    /**\\n     * @notice Emitted when implementation is changed\\n     */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) virtual external;\\n}\\n\\nabstract contract CDelegateInterface is CDelegationStorage {\\n    /**\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\n     * @param data The encoded bytes data for any initialization\\n     */\\n    function _becomeImplementation(bytes memory data) virtual external;\\n\\n    /**\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\n     */\\n    function _resignImplementation() virtual external;\\n}\\n\"\r\n    },\r\n    \"contracts/ComptrollerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nabstract contract ComptrollerInterface {\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\n    bool public constant isComptroller = true;\\n\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata cTokens) virtual external returns (uint[] memory);\\n    function exitMarket(address cToken) virtual external returns (uint);\\n\\n    function addToMarketExternal(address cToken, address borrower) virtual external;\\n    \\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) virtual external;\\n\\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\\n\\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) virtual external;\\n\\n    function getIsAccountVip(address _account) virtual public view returns (bool);\\n\\n    function repayBorrowAllowed(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount) virtual external returns (uint);\\n    function repayBorrowVerify(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount,\\n        uint borrowerIndex) virtual external;\\n\\n    function liquidateBorrowAllowed(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount) virtual external returns (uint);\\n    function liquidateBorrowVerify(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount,\\n        uint seizeTokens) virtual external;\\n\\n    function seizeAllowed(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) virtual external returns (uint);\\n    function seizeVerify(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) virtual external;\\n\\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) virtual external;\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        uint repayAmount) virtual external view returns (uint, uint);\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/EIP20NonStandardInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface EIP20NonStandardInterface {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/ErrorReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\ncontract ComptrollerErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        COMPTROLLER_MISMATCH,\\n        INSUFFICIENT_SHORTFALL,\\n        INSUFFICIENT_LIQUIDITY,\\n        INVALID_CLOSE_FACTOR,\\n        INVALID_COLLATERAL_FACTOR,\\n        INVALID_LIQUIDATION_INCENTIVE,\\n        MARKET_NOT_ENTERED, // no longer possible\\n        MARKET_NOT_LISTED,\\n        MARKET_ALREADY_LISTED,\\n        MATH_ERROR,\\n        NONZERO_BORROW_BALANCE,\\n        PRICE_ERROR,\\n        REJECTION,\\n        SNAPSHOT_ERROR,\\n        TOO_MANY_ASSETS,\\n        TOO_MUCH_REPAY,\\n        CANNOT_BORROW_ASSET\\n    }\\n\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n        EXIT_MARKET_BALANCE_OWED,\\n        EXIT_MARKET_REJECTION,\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\n        SET_CLOSE_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\n        SUPPORT_MARKET_EXISTS,\\n        SUPPORT_MARKET_OWNER_CHECK,\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\ncontract TokenErrorReporter {\\n    uint public constant NO_ERROR = 0; // support legacy return codes\\n\\n    error TransferComptrollerRejection(uint256 errorCode);\\n    error TransferNotAllowed();\\n    error TransferNotEnough();\\n    error TransferTooMuch();\\n\\n    error MintComptrollerRejection(uint256 errorCode);\\n    error MintFreshnessCheck();\\n\\n    error RedeemComptrollerRejection(uint256 errorCode);\\n    error RedeemFreshnessCheck();\\n    error RedeemTransferOutNotPossible();\\n\\n    error BorrowComptrollerRejection(uint256 errorCode);\\n    error BorrowFreshnessCheck();\\n    error BorrowCashNotAvailable();\\n\\n    error RepayBorrowComptrollerRejection(uint256 errorCode);\\n    error RepayBorrowFreshnessCheck();\\n\\n    error LiquidateComptrollerRejection(uint256 errorCode);\\n    error LiquidateFreshnessCheck();\\n    error LiquidateCollateralFreshnessCheck();\\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\n    error LiquidateLiquidatorIsBorrower();\\n    error LiquidateCloseAmountIsZero();\\n    error LiquidateCloseAmountIsUintMax();\\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\\n\\n    error LiquidateSeizeComptrollerRejection(uint256 errorCode);\\n    error LiquidateSeizeLiquidatorIsBorrower();\\n\\n    error AcceptAdminPendingAdminCheck();\\n\\n    error SetComptrollerOwnerCheck();\\n    error SetPendingAdminOwnerCheck();\\n\\n    error SetReserveFactorAdminCheck();\\n    error SetReserveFactorFreshCheck();\\n    error SetReserveFactorBoundsCheck();\\n\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\n\\n    error ReduceReservesAdminCheck();\\n    error ReduceReservesFreshCheck();\\n    error ReduceReservesCashNotAvailable();\\n    error ReduceReservesCashValidation();\\n\\n    error SetInterestRateModelOwnerCheck();\\n    error SetInterestRateModelFreshCheck();\\n    error SetStakedGlpAddressOwnerCheck();\\n    error SignalTransferOwnerCheck();\\n    error SetAutoCompoundOwnerCheck();\\n}\\n\"\r\n    },\r\n    \"contracts/IGmxRewardRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IGmxRewardRouter {\\n    function stakedGmxTracker() external view returns (address);\\n\\n    function bonusGmxTracker() external view returns (address);\\n\\n    function feeGmxTracker() external view returns (address);\\n\\n    function stakedGlpTracker() external view returns (address);\\n\\n    function feeGlpTracker() external view returns (address);\\n\\n    function glpManager() external view returns (address);\\n\\n    function handleRewards(\\n        bool _shouldClaimGmx,\\n        bool _shouldStakeGmx,\\n        bool _shouldClaimEsGmx,\\n        bool _shouldStakeEsGmx,\\n        bool _shouldStakeMultiplierPoints,\\n        bool _shouldClaimWeth,\\n        bool _shouldConvertWethToEth\\n    ) external;\\n\\n    function signalTransfer(address _receiver) external;\\n\\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns (uint256) ;\\n\\n    function mintAndStakeGlpETH(uint256 _minUsdg, uint256 _minGlp) external payable returns (uint256);\\n\\n    function stakeGmx(uint256 amount) external;\\n\\n    function unstakeGmx(uint256 amount) external;\\n\\n}\"\r\n    },\r\n    \"contracts/IStakedGlp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n\\ninterface IStakedGlp {\\n    \\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n\\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\\n\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/IRewardTracker.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\ninterface IRewardTracker {\\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\\n    function stakedAmounts(address _account) external returns (uint256);\\n    function updateRewards() external;\\n    function stake(address _depositToken, uint256 _amount) external;\\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\\n    function unstake(address _depositToken, uint256 _amount) external;\\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\\n    function tokensPerInterval() external view returns (uint256);\\n    function claim(address _receiver) external returns (uint256);\\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\\n    function claimable(address _account) external view returns (uint256);\\n    function averageStakedAmounts(address _account) external view returns (uint256);\\n    function cumulativeRewards(address _account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/CErc20Gmx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CTokenGmx.sol\\\";\\nimport \\\"./IGmxRewardRouter.sol\\\";\\nimport \\\"./IStakedGlp.sol\\\";\\nimport \\\"./IRewardTracker.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface CompLike {\\n    function delegate(address delegatee) external;\\n}\\n\\n/**\\n * @title Compound's CErc20 Contract\\n * @notice CTokens which wrap an EIP-20 underlying\\n * @author Compound\\n */\\ncontract CErc20Gmx is CTokenGmx, CErc20Interface {\\n    /**\\n     * @notice Initialize the new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     */\\n    function initialize(address underlying_,\\n                        ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_\\n                        ) public {\\n        // CToken initialize does the bulk of the work\\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        EIP20Interface(underlying).totalSupply();\\n    }\\n\\n    function tinit(address underlying_,\\n                        ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_\\n                        ) public {\\n        require(admin == address(0), \\\"admin may only be set once\\\");\\n        admin = payable(msg.sender);\\n        // CToken initialize does the bulk of the work\\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        EIP20Interface(underlying).totalSupply();\\n    }\\n    \\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) override external returns (uint) {\\n        mintInternal(mintAmount);\\n        comptroller.addToMarketExternal(address(this), msg.sender);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) override external returns (uint) {\\n        redeemInternal(redeemTokens);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\\n        redeemUnderlyingInternal(redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) override external returns (uint) {\\n        borrowInternal(borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) override external returns (uint) {\\n        repayBorrowInternal(repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\\n        repayBorrowBehalfInternal(borrower, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\\n        liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(EIP20NonStandardInterface token) override external {\\n        require(msg.sender == admin, \\\"CErc20::sweepToken: only admin can sweep tokens\\\");\\n        require(address(token) != underlying, \\\"CErc20::sweepToken: can not sweep underlying token\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        token.transfer(admin, balance);\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n        \\n    function depositNFT(address _NFTAddress, uint256 _TokenID) override external {\\n        require(msg.sender == admin, \\\"only admins can deposit NFT's\\\");\\n        IERC721(_NFTAddress).safeTransferFrom(msg.sender, address(this), _TokenID);\\n    }\\n\\n    function withdrawNFT(address _NFTAddress, uint256 _TokenID) override external {\\n        require(msg.sender == admin, \\\"only admins can withdraw NFT's\\\");\\n        IERC721(_NFTAddress).safeTransferFrom(address(this), admin, _TokenID);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount fo underlying token to add as reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) override external returns (uint) {\\n        return _addReservesInternal(addAmount);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function getCashPrior() virtual override internal view returns (uint256) {\\n        uint256 cashPrior;\\n        cashPrior = stakedGmxTracker.depositBalances(address(this), underlying);\\n        return cashPrior;\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n     *      This will revert due to insufficient balance or insufficient allowance.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferIn(address from, uint amount) virtual override internal returns (uint) {\\n        // Read from storage once\\n        address underlying_ = underlying;\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\\n        uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\\n        token.transferFrom(from, address(this), amount);\\n\\n        \\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {                       // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                      // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of override external call\\n                }\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n        \\n        \\n        // Calculate the amount that was *actually* transferred\\n        uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\\n        uint256 currentBalance = balanceAfter - balanceBefore;\\n        EIP20Interface(underlying).approve(address(stakedGmxTracker), amount);\\n        glpRewardRouter.stakeGmx(currentBalance);\\n        return currentBalance;   // underflow already checked above, just subtract\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n     *      it is >= amount, this should not revert in normal conditions.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferOut(address payable to, uint amount) virtual override internal {\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\\n        glpRewardRouter.unstakeGmx(amount);\\n        token.transfer(to, amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {                      // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                     // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of override external call\\n                }\\n                default {                     // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n        \\n        \\n    }\\n\\n    /**\\n    * @notice Admin call to delegate the votes of the COMP-like underlying\\n    * @param compLikeDelegatee The address to delegate votes to\\n    * @dev CTokens whose underlying are not CompLike should revert here\\n    */\\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\\n        require(msg.sender == admin, \\\"only the admin may set the comp-like delegate\\\");\\n        CompLike(underlying).delegate(compLikeDelegatee);\\n    }\\n}\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\"\r\n    },\r\n    \"contracts/CTokenGmx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\n\\nimport \\\"./ComptrollerInterface.sol\\\";\\nimport \\\"./CTokenInterfaces.sol\\\";\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\nimport \\\"./IGmxRewardRouter.sol\\\";\\nimport \\\"./IStakedGlp.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./ISwapRouter.sol\\\";\\n\\n/**\\n * @title Compound's CToken Contract\\n * @notice Abstract base for CTokens\\n * @author Compound\\n */\\nabstract contract CTokenGmx is CTokenInterface, ExponentialNoError, TokenErrorReporter {\\n    /**\\n     * @notice Initialize the money market\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ EIP-20 name of this token\\n     * @param symbol_ EIP-20 symbol of this token\\n     * @param decimals_ EIP-20 decimal precision of this token\\n     */\\n    function initialize(ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_\\n                        ) public {\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        // Set the comptroller\\n        uint err = _setComptroller(comptroller_);\\n        require(err == NO_ERROR, \\\"setting comptroller failed\\\");\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = getBlockNumber();\\n        borrowIndex = mantissaOne;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        err = _setInterestRateModelFresh(interestRateModel_);\\n        require(err == NO_ERROR, \\\"setting interest rate model failed\\\");\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n    }\\n\\n    ISwapRouter public immutable swapRouter = ISwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\\n\\n    uint24 public constant poolFee = 3000;\\n\\n\\n    /// @notice swapExactInputSingle swaps a fixed amount of WETH for a maximum possible amount of GMX\\n    /// using the GMX/WETH 0.3% pool by calling `exactInputSingle` in the swap router.\\n    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its WETH for this function to succeed.\\n    /// @param amountIn The exact amount of WETH that will be swapped for GMX.\\n    /// @return amountOut The amount of GMX received.\\n    function swapExactInputSingle(uint256 amountIn) internal returns (uint256 amountOut) {\\n        \\n        // Approve the router to spend WETH.\\n        TransferHelper.safeApprove(WETH, address(swapRouter), amountIn);\\n\\n        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.\\n        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.\\n        ISwapRouter.ExactInputSingleParams memory params =\\n            ISwapRouter.ExactInputSingleParams({\\n                tokenIn: WETH,\\n                tokenOut: gmxToken,\\n                fee: poolFee,\\n                recipient: msg.sender,\\n                deadline: block.timestamp,\\n                amountIn: amountIn,\\n                amountOutMinimum: 0,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n        // The call to `exactInputSingle` executes the swap.\\n        amountOut = swapRouter.exactInputSingle(params);\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     * @return 0 if the transfer succeeded, else revert\\n     */\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\n        /* Fail if transfer not allowed */\\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\\n        if (allowed != 0) {\\n            revert TransferComptrollerRejection(allowed);\\n        }\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            revert TransferNotAllowed();\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint startingAllowance = 0;\\n        if (spender == src) {\\n            startingAllowance = type(uint).max;\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        uint allowanceNew = startingAllowance - tokens;\\n        uint srcTokensNew = accountTokens[src] - tokens;\\n        uint dstTokensNew = accountTokens[dst] + tokens;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != type(uint).max) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n\\n        // unused function\\n        // comptroller.transferVerify(address(this), src, dst, tokens);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) override external returns (bool) {\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) override external view returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) override external view returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) override external returns (uint) {\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\\n        return (\\n            NO_ERROR,\\n            accountTokens[account],\\n            borrowBalanceStoredInternal(account),\\n            exchangeRateStoredInternal()\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     */\\n    function getBlockNumber() virtual internal view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() override external view returns (uint) {\\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() override external view returns (uint) {\\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        return borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) override public view returns (uint) {\\n        return borrowBalanceStoredInternal(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\\n     */\\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return 0;\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\\n        accrueInterest();\\n        return exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() override public view returns (uint) {\\n        return exchangeRateStoredInternal();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\\n        uint _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return initialExchangeRateMantissa;\\n        } else {\\n            /*\\n             * Otherwise:\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n             */\\n            uint totalCash = getCashPrior();\\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\\n            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\\n\\n            return exchangeRate;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this cToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() override external view returns (uint) {\\n        return getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     */\\n    function accrueInterest() virtual override public returns (uint) {\\n        \\n        /* Remember the initial block number */\\n        uint currentBlockNumber = getBlockNumber();\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint cashPrior = getCashPrior();\\n        uint borrowsPrior = totalBorrows;\\n        uint reservesPrior = totalReserves;\\n        uint borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\n\\n        /*\\n        * Calculate the interest accumulated into borrows and reserves and the new index:\\n        *  simpleInterestFactor = borrowRate * blockDelta\\n        *  interestAccumulated = simpleInterestFactor * totalBorrows\\n        *  totalBorrowsNew = interestAccumulated + totalBorrows\\n        *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n        *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n        */\\n\\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        uint totalBorrowsNew = interestAccumulated + borrowsPrior;\\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = borrowIndexNew;\\n        totalBorrows = totalBorrowsNew;\\n        totalReserves = totalReservesNew;\\n\\n        if(totalSupply > 0){\\n            glpRewardRouter.handleRewards(true, true, true, true, true, true, false);\\n            if(autocompound){\\n                uint ethBalance =  EIP20Interface(WETH).balanceOf(address(this));\\n                if(ethBalance > 0){\\n                    uint ethManagementFee = mul_(ethBalance, div_(managementFee, 100));\\n                    uint ethToCompound = sub_(ethBalance, ethManagementFee);\\n                    EIP20Interface(WETH).transfer(admin, ethManagementFee);\\n                    uint256 amountOfGmxReceived = swapExactInputSingle(ethToCompound);\\n                    glpRewardRouter.stakeGmx(amountOfGmxReceived);\\n                }\\n            } \\n        }\\n\\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n        \\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function mintInternal(uint mintAmount) internal nonReentrant {\\n        accrueInterest();\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        mintFresh(msg.sender, mintAmount);\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives cTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function mintFresh(address minter, uint mintAmount) internal {\\n        /* Fail if mint not allowed */\\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\\n        if (allowed != 0) {\\n            revert MintComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert MintFreshnessCheck();\\n        }\\n\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n        /*\\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         * And write them into storage\\n         */\\n        totalSupply = totalSupply + mintTokens;\\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, actualMintAmount, mintTokens);\\n        emit Transfer(address(this), minter, mintTokens);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\\n    }\\n\\n    function _setAutocompoundRewards(bool autocompound_) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetAutoCompoundOwnerCheck();\\n        }\\n        EIP20Interface(WETH).approve(glpManager, type(uint256).max);\\n        autocompound = autocompound_;\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     */\\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\\n        accrueInterest();\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\\n     */\\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\\n        accrueInterest();\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\\n    }\\n\\n    /**\\n     * @notice User redeems cTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     */\\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\\n\\n        uint redeemTokens;\\n        uint redeemAmount;\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n             */\\n            redeemTokens = redeemTokensIn;\\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             *  redeemAmount = redeemAmountIn\\n             */\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\n            redeemAmount = redeemAmountIn;\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\\n        if (allowed != 0) {\\n            revert RedeemComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert RedeemFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (getCashPrior() < redeemAmount) {\\n            revert RedeemTransferOutNotPossible();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\n         */\\n        totalSupply = totalSupply - redeemTokens;\\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\\n\\n\\n\\n        /*\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken has redeemAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        \\n        bool isRedeemerVip = comptroller.getIsAccountVip(redeemer);\\n\\n        if(!isRedeemerVip){\\n            uint256 withdrawFeeAmount = div_(mul_(redeemAmount, sub_(100, withdrawFee)), 100);\\n            uint256 actualRedeemAmount = sub_(redeemAmount, withdrawFee);\\n            doTransferOut(admin, withdrawFeeAmount);\\n            doTransferOut(redeemer, actualRedeemAmount);\\n        } else {\\n            doTransferOut(redeemer, redeemAmount);\\n        }\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), redeemTokens);\\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      */\\n    function borrowInternal(uint borrowAmount) internal nonReentrant {\\n        accrueInterest();\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        borrowFresh(payable(msg.sender), borrowAmount);\\n    }\\n\\n    /**\\n      * @notice Users borrow assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      */\\n    function borrowFresh(address payable borrower, uint borrowAmount) internal {\\n        /* Fail if borrow not allowed */\\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\\n        if (allowed != 0) {\\n            revert BorrowComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert BorrowFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (getCashPrior() < borrowAmount) {\\n            revert BorrowCashNotAvailable();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n        uint totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\n        `*/\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /*\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken borrowAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(borrower, borrowAmount);\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     */\\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant {\\n        accrueInterest();\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     */\\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\\n        accrueInterest();\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\\n     * @return (uint) the actual repayment amount.\\n     */\\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\\n        /* Fail if repayBorrow not allowed */\\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\n        if (allowed != 0) {\\n            revert RepayBorrowComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert RepayBorrowFreshnessCheck();\\n        }\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n\\n        /* If repayAmount == -1, repayAmount = accountBorrows */\\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the payer and the repayAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional repayAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n        uint totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n        return actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     */\\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\\n        accrueInterest();\\n\\n        uint error = cTokenCollateral.accrueInterest();\\n        if (error != NO_ERROR) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\n        }\\n\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     */\\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal {\\n        /* Fail if liquidate not allowed */\\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\\n        if (allowed != 0) {\\n            revert LiquidateComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert LiquidateFreshnessCheck();\\n        }\\n\\n        /* Verify cTokenCollateral market's block number equals current block number */\\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\n            revert LiquidateCollateralFreshnessCheck();\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateLiquidatorIsBorrower();\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            revert LiquidateCloseAmountIsZero();\\n        }\\n\\n        /* Fail if repayAmount = -1 */\\n        if (repayAmount == type(uint).max) {\\n            revert LiquidateCloseAmountIsUintMax();\\n        }\\n\\n        /* Fail if repayBorrow fails */\\n        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\\n        require(amountSeizeError == NO_ERROR, \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\n        if (address(cTokenCollateral) == address(this)) {\\n            seizeInternal(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, \\\"token seizure failed\\\");\\n        }\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) {\\n        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     */\\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal {\\n        /* Fail if seize not allowed */\\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n        if (allowed != 0) {\\n            revert LiquidateSeizeComptrollerRejection(allowed);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        uint protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\\n        uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n        uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n        uint totalReservesNew = totalReserves + protocolSeizeAmount;\\n\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the calculated values into storage */\\n        totalReserves = totalReservesNew;\\n        totalSupply = totalSupply - protocolSeizeTokens;\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            revert SetPendingAdminOwnerCheck();\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() override external returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            revert AcceptAdminPendingAdminCheck();\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = payable(address(0));\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sets a new comptroller for the market\\n      * @dev Admin function to set a new comptroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetComptrollerOwnerCheck();\\n        }\\n\\n        ComptrollerInterface oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n      * @dev Admin function to set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetReserveFactorAdminCheck();\\n        }\\n\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert SetReserveFactorFreshCheck();\\n        }\\n\\n        // Check newReserveFactor \u2264 maxReserveFactor\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\n            revert SetReserveFactorBoundsCheck();\\n        }\\n\\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\n     * @param addAmount Amount of addition to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\\n        accrueInterest();\\n\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\n        _addReservesFresh(addAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\n     */\\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\\n        // totalReserves + actualAddAmount\\n        uint totalReservesNew;\\n        uint actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the caller and the addAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional addAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *  it returns the amount actually transferred, in case of a fee.\\n         */\\n\\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\\n\\n        totalReservesNew = totalReserves + actualAddAmount;\\n\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\n        totalReserves = totalReservesNew;\\n\\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        /* Return (NO_ERROR, actualAddAmount) */\\n        return (NO_ERROR, actualAddAmount);\\n    }\\n\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n        return _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to admin\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\n        // totalReserves - reduceAmount\\n        uint totalReservesNew;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert ReduceReservesAdminCheck();\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert ReduceReservesFreshCheck();\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (getCashPrior() < reduceAmount) {\\n            revert ReduceReservesCashNotAvailable();\\n        }\\n\\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            revert ReduceReservesCashValidation();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        doTransferOut(admin, reduceAmount);\\n\\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\\n        accrueInterest();\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n        return _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\\n\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModel oldInterestRateModel;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetInterestRateModelOwnerCheck();\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert SetInterestRateModelFreshCheck();\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Updates the addresses for the GLP contracts using _setStakedGlpAddresses\\n     * @dev Admin function to update the stakedGLP contract address\\n     * @param stakedGLP_ the stakedGLP contract to use\\n     * @param glpRewardRouter_ the rewardrouter contract address to use\\n     * @param glpManager_ the glpManager contract address to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setGlpAddresses(IStakedGlp stakedGLP_, IGmxRewardRouter glpRewardRouter_, address glpManager_) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetStakedGlpAddressOwnerCheck();\\n        }\\n        stakedGLP = stakedGLP_;\\n        glpRewardRouter = glpRewardRouter_;\\n        glpManager = glpManager_;\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Updates the fees for the vault strategy markets\\n     * @dev Admin function to update the fees\\n     * @param withdrawFee_ fee to withdraw funds\\n     * @param managementFee_ fee taken from autocompounded rewards\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setVaultFees(uint256 withdrawFee_, uint256 managementFee_) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetStakedGlpAddressOwnerCheck();\\n        }\\n\\n        withdrawFee = withdrawFee_;\\n        managementFee = managementFee_;\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfers all esGmx assets to the recipient\\n     * @dev Admin function to remove all esGmx assets from the contract\\n     * @param recipient the address to send all the assets to\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _signalTransfer(address recipient) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SignalTransferOwnerCheck();\\n        }\\n        if(getCashPrior() == 0){\\n            glpRewardRouter.signalTransfer(recipient);\\n        }\\n        return NO_ERROR;\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying owned by this contract\\n     */\\n    function getCashPrior() virtual internal view returns (uint256);\\n\\n    /**\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\n     *  This may revert due to insufficient balance or insufficient allowance.\\n     */\\n    function doTransferIn(address from, uint amount) virtual internal returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n     */\\n    function doTransferOut(address payable to, uint amount) virtual internal;\\n\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n}\\n\\n\\n\\n\"\r\n    },\r\n    \"contracts/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/EIP20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return a + b;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return a * b;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\"\r\n    },\r\n    \"contracts/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.10;\\npragma abicoder v2;\\n\\nimport \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.10;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/ERC165.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Comptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./ComptrollerInterface.sol\\\";\\nimport \\\"./ComptrollerStorage.sol\\\";\\nimport \\\"./Unitroller.sol\\\";\\nimport \\\"./Governance/Comp.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title Compound's Comptroller Contract\\n * @author Compound\\n */\\ncontract Comptroller is\\n    ComptrollerV7Storage,\\n    ComptrollerInterface,\\n    ComptrollerErrorReporter,\\n    ExponentialNoError\\n{\\n    /// @notice Emitted when an admin supports a market\\n    event MarketListed(CToken cToken);\\n\\n    /// @notice Emitted when an account enters a market\\n    event MarketEntered(CToken cToken, address account);\\n\\n    /// @notice Emitted when an account exits a market\\n    event MarketExited(CToken cToken, address account);\\n\\n    /// @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(\\n        uint256 oldCloseFactorMantissa,\\n        uint256 newCloseFactorMantissa\\n    );\\n\\n    /// @notice Emitted when the collateral factors are changed by admin\\n    event NewFactorsAndThresholds(\\n        CToken cToken,\\n        uint256 oldCollateralFactorMantissa,\\n        uint256 newCollateralFactorMantissa,\\n        uint256 oldCollateralFactorMantissaVip,\\n        uint256 newCollateralFactorMantissaVip,\\n        uint256 oldliquidationThresholdMantissa,\\n        uint256 newliquidationThresholdMantissa,\\n        uint256 oldliquidationThresholdMantissaVip,\\n        uint256 newliquidationThresholdMantissaVip\\n    );\\n\\n    /// @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(\\n        uint256 oldLiquidationIncentiveMantissa,\\n        uint256 newLiquidationIncentiveMantissa\\n    );\\n\\n    /// @notice Emitted when price oracle is changed\\n    event NewPriceOracle(\\n        PriceOracle oldPriceOracle,\\n        PriceOracle newPriceOracle\\n    );\\n\\n    /// @notice Emitted when pause guardian is changed\\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\n\\n    /// @notice Emitted when an action is paused globally\\n    event ActionPaused(string action, bool pauseState);\\n\\n    /// @notice Emitted when an action is paused on a market\\n    event ActionPaused(CToken cToken, string action, bool pauseState);\\n\\n    /// @notice Emitted when a new borrow-side COMP speed is calculated for a market\\n    event CompBorrowSpeedUpdated(CToken indexed cToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when a new supply-side COMP speed is calculated for a market\\n    event CompSupplySpeedUpdated(CToken indexed cToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when a new COMP speed is set for a contributor\\n    event ContributorCompSpeedUpdated(\\n        address indexed contributor,\\n        uint256 newSpeed\\n    );\\n\\n    /// @notice Emitted when COMP is distributed to a supplier\\n    event DistributedSupplierComp(\\n        CToken indexed cToken,\\n        address indexed supplier,\\n        uint256 compDelta,\\n        uint256 compSupplyIndex\\n    );\\n\\n    /// @notice Emitted when COMP is distributed to a borrower\\n    event DistributedBorrowerComp(\\n        CToken indexed cToken,\\n        address indexed borrower,\\n        uint256 compDelta,\\n        uint256 compBorrowIndex\\n    );\\n\\n    /// @notice Emitted when borrow cap for a cToken is changed\\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\\n\\n    /// @notice Emitted when borrow cap for a cToken is changed\\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\\n\\n\\n    /// @notice Emitted when borrow cap guardian is changed\\n    event NewBorrowCapGuardian(\\n        address oldBorrowCapGuardian,\\n        address newBorrowCapGuardian\\n    );\\n\\n    /// @notice Emitted when COMP is granted by admin\\n    event CompGranted(address recipient, uint256 amount);\\n\\n    /// @notice Emitted when COMP accrued for a user has been manually adjusted.\\n    event CompAccruedAdjusted(\\n        address indexed user,\\n        uint256 oldCompAccrued,\\n        uint256 newCompAccrued\\n    );\\n\\n    /// @notice Emitted when COMP receivable for a user has been updated.\\n    event CompReceivableUpdated(\\n        address indexed user,\\n        uint256 oldCompReceivable,\\n        uint256 newCompReceivable\\n    );\\n\\n    /// @notice The initial COMP index for a market\\n    uint224 public constant compInitialIndex = 1e36;\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\\n\\n    // No liquidationThresholdMantissa may exceed this value\\n    uint256 internal constant liquidationThresholdMaxMantissa = 0.98e18; // 0.98\\n\\n    constructor() {\\n        admin = msg.sender;\\n        whitelistedUser[admin] = true;\\n        immutableCompAddress = false;\\n    }\\n\\n    /*** Assets You Are In ***/\\n\\n    /**\\n     * @notice Returns the assets an account has entered\\n     * @param account The address of the account to pull assets for\\n     * @return A dynamic list with the assets the account has entered\\n     */\\n    function getAssetsIn(address account)\\n        external\\n        view\\n        returns (CToken[] memory)\\n    {\\n        CToken[] memory assetsIn = accountAssets[account];\\n\\n        return assetsIn;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account is entered in the given asset\\n     * @param account The address of the account to check\\n     * @param cToken The cToken to check\\n     * @return True if the account is in the asset, otherwise false.\\n     */\\n    function checkMembership(address account, CToken cToken)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return markets[address(cToken)].accountMembership[account];\\n    }\\n\\n    /**\\n     * @notice Add assets to be included in account liquidity calculation\\n     * @param cTokens The list of addresses of the cToken markets to be enabled\\n     * @return Success indicator for whether each corresponding market was entered\\n     */\\n    function enterMarkets(address[] memory cTokens)\\n        public\\n        override\\n        returns (uint256[] memory)\\n    {\\n        uint256 len = cTokens.length;\\n\\n        uint256[] memory results = new uint256[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            CToken cToken = CToken(cTokens[i]);\\n\\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param cToken The market to enter\\n     * @param borrower The address of the account to modify\\n     */\\n    function addToMarketExternal(address cToken, address borrower)\\n        external\\n        override\\n    {\\n        require(msg.sender == cToken, \\\"not cToken\\\");\\n        addToMarketInternal(CToken(cToken), borrower);\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param cToken The market to enter\\n     * @param borrower The address of the account to modify\\n     * @return Success indicator for whether the market was entered\\n     */\\n    function addToMarketInternal(CToken cToken, address borrower)\\n        internal\\n        returns (Error)\\n    {\\n        Market storage marketToJoin = markets[address(cToken)];\\n\\n        if (!marketToJoin.isListed) {\\n            // market is not listed, cannot join\\n            return Error.MARKET_NOT_LISTED;\\n        }\\n\\n        if (marketToJoin.isPrivate) {\\n            //market is private, make sure user has admin rights\\n            require(\\n                whitelistedUser[borrower],\\n                \\\"market is private\\\"\\n            );\\n        }\\n\\n        if (marketToJoin.accountMembership[borrower] == true) {\\n            // already joined\\n            return Error.NO_ERROR;\\n        }\\n\\n        // survived the gauntlet, add to list\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\n        //  this avoids having to iterate through the list for the most common use cases\\n        //  that is, only when we need to perform liquidity checks\\n        //  and not whenever we want to check if an account is in a particular market\\n        marketToJoin.accountMembership[borrower] = true;\\n        accountAssets[borrower].push(cToken);\\n\\n        emit MarketEntered(cToken, borrower);\\n\\n        return Error.NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Removes asset from sender's account liquidity calculation\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\n     *  or be providing necessary collateral for an outstanding borrow.\\n     * @param cTokenAddress The address of the asset to be removed\\n     * @return Whether or not the account successfully exited the market\\n     */\\n    function exitMarket(address cTokenAddress)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        CToken cToken = CToken(cTokenAddress);\\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken\\n            .getAccountSnapshot(msg.sender);\\n        require(oErr == 0, \\\"exitMarket: getAccountSnapshot failed\\\"); // semi-opaque error code\\n\\n        /* Fail if the sender has a borrow balance */\\n        if (amountOwed != 0) {\\n            return\\n                fail(\\n                    Error.NONZERO_BORROW_BALANCE,\\n                    FailureInfo.EXIT_MARKET_BALANCE_OWED\\n                );\\n        }\\n\\n        /* Fail if the sender is not permitted to redeem all of their tokens */\\n        uint256 allowed = redeemAllowedInternal(\\n            cTokenAddress,\\n            msg.sender,\\n            tokensHeld\\n        );\\n        if (allowed != 0) {\\n            return\\n                failOpaque(\\n                    Error.REJECTION,\\n                    FailureInfo.EXIT_MARKET_REJECTION,\\n                    allowed\\n                );\\n        }\\n\\n        Market storage marketToExit = markets[address(cToken)];\\n\\n        /* Return true if the sender is not already \u2018in\u2019 the market */\\n        if (!marketToExit.accountMembership[msg.sender]) {\\n            return uint256(Error.NO_ERROR);\\n        }\\n\\n        /* Set cToken account membership to false */\\n        delete marketToExit.accountMembership[msg.sender];\\n\\n        /* Delete cToken from the account\u2019s list of assets */\\n        // load into memory for faster iteration\\n        CToken[] memory userAssetList = accountAssets[msg.sender];\\n        uint256 len = userAssetList.length;\\n        uint256 assetIndex = len;\\n        for (uint256 i = 0; i < len; i++) {\\n            if (userAssetList[i] == cToken) {\\n                assetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\n        assert(assetIndex < len);\\n\\n        // copy last item in list to location of item to be removed, reduce length by 1\\n        CToken[] storage storedList = accountAssets[msg.sender];\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\n        storedList.pop();\\n\\n        emit MarketExited(cToken, msg.sender);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /*** Policy Hooks ***/\\n\\n    /**\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param cToken The market to verify the mint against\\n     * @param minter The account which would get the minted tokens\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function mintAllowed(\\n        address cToken,\\n        address minter,\\n        uint256 mintAmount\\n    ) external override returns (uint256) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!mintGuardianPaused[cToken], \\\"mint paused\\\");\\n\\n        // Shh - currently unused\\n        minter;\\n        mintAmount;\\n\\n        if (!markets[cToken].isListed) {\\n            return uint256(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        uint256 supplyCap = supplyCaps[cToken];\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        if (supplyCaps[cToken] != 0) {\\n            uint256 totalDeposits = CToken(cToken).totalBorrows() + CToken(cToken).getCash() + CToken(cToken).totalReserves();\\n            uint256 nextTotalDeposit = add_(totalDeposits, mintAmount);\\n            require(nextTotalDeposit < supplyCap, \\\"supply cap reached\\\");\\n        }\\n\\n\\n        if (markets[cToken].isPrivate) {\\n            //market is private, make sure user has admin rights\\n            require(\\n                whitelistedUser[minter],\\n                \\\"this market is currently private\\\"\\n            );\\n        }\\n\\n        // Keep the flywheel moving\\n        updateCompSupplyIndex(cToken);\\n        distributeSupplierComp(cToken, minter);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates mint and reverts on rejection. May emit logs.\\n     * @param cToken Asset being minted\\n     * @param minter The address minting the tokens\\n     * @param actualMintAmount The amount of the underlying asset being minted\\n     * @param mintTokens The number of tokens being minted\\n     */\\n    function mintVerify(\\n        address cToken,\\n        address minter,\\n        uint256 actualMintAmount,\\n        uint256 mintTokens\\n    ) external override {\\n        // Shh - currently unused\\n        cToken;\\n        minter;\\n        actualMintAmount;\\n        mintTokens;\\n\\n        // Shh - we don't ever want this hook to be marked pure\\n        if (false) {\\n            maxAssets = maxAssets;\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\n     * @param cToken The market to verify the redeem against\\n     * @param redeemer The account which would redeem the tokens\\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function redeemAllowed(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) external override returns (uint256) {\\n        uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\\n        if (allowed != uint256(Error.NO_ERROR)) {\\n            return allowed;\\n        }\\n\\n        // Keep the flywheel moving\\n        updateCompSupplyIndex(cToken);\\n        distributeSupplierComp(cToken, redeemer);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    function redeemAllowedInternal(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) internal view returns (uint256) {\\n        if (!markets[cToken].isListed) {\\n            return uint256(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n        if (!markets[cToken].accountMembership[redeemer]) {\\n            return uint256(Error.NO_ERROR);\\n        }\\n\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n        (\\n            Error err,\\n            ,\\n            uint256 shortfall\\n        ) = getHypotheticalAccountLiquidityInternal(\\n                redeemer,\\n                CToken(cToken),\\n                redeemTokens,\\n                0,\\n                false\\n            );\\n        if (err != Error.NO_ERROR) {\\n            return uint256(err);\\n        }\\n        if (shortfall > 0) {\\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\\n        }\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates redeem and reverts on rejection. May emit logs.\\n     * @param cToken Asset being redeemed\\n     * @param redeemer The address redeeming the tokens\\n     * @param redeemAmount The amount of the underlying asset being redeemed\\n     * @param redeemTokens The number of tokens being redeemed\\n     */\\n    function redeemVerify(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    ) external override {\\n        // Shh - currently unused\\n        cToken;\\n        redeemer;\\n\\n        // Require tokens is zero or amount is also zero\\n        if (redeemTokens == 0 && redeemAmount > 0) {\\n            revert(\\\"redeemTokens zero\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n     * @param cToken The market to verify the borrow against\\n     * @param borrower The account which would borrow the asset\\n     * @param borrowAmount The amount of underlying the account would borrow\\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function borrowAllowed(\\n        address cToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external override returns (uint256) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!borrowGuardianPaused[cToken], \\\"borrow is paused\\\");\\n\\n        if (!markets[cToken].isListed) {\\n            return uint256(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        CToken cToken_ = CToken(cToken);\\n\\n        if (cToken_.isGLP()) {\\n            return uint256(Error.CANNOT_BORROW_ASSET);\\n        }\\n\\n        if (markets[cToken].isPrivate || markets[cToken].onlyWhitelistedBorrow) {\\n            //market is private, make sure user is whitelisted \\n            require(\\n                whitelistedUser[borrower],\\n                \\\"this market is currently private\\\"\\n            );\\n        }\\n\\n        if (!markets[cToken].accountMembership[borrower]) {\\n            // only cTokens may call borrowAllowed if borrower not in market\\n            require(msg.sender == cToken, \\\"sender must be cToken\\\");\\n\\n            // attempt to add borrower to the market\\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\\n            if (err != Error.NO_ERROR) {\\n                return uint256(err);\\n            }\\n\\n            // it should be impossible to break the important invariant\\n            assert(markets[cToken].accountMembership[borrower]);\\n        }\\n\\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\\n            return uint256(Error.PRICE_ERROR);\\n        }\\n\\n        uint256 borrowCap = borrowCaps[cToken];\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        if (borrowCap != 0) {\\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\\n            uint256 nextTotalBorrows = add_(totalBorrows, borrowAmount);\\n            require(nextTotalBorrows < borrowCap, \\\"market borrow cap reached\\\");\\n        }\\n\\n        (\\n            Error err,\\n            ,\\n            uint256 shortfall\\n        ) = getHypotheticalAccountLiquidityInternal(\\n                borrower,\\n                CToken(cToken),\\n                0,\\n                borrowAmount,\\n                false\\n            );\\n        if (err != Error.NO_ERROR) {\\n            return uint256(err);\\n        }\\n        if (shortfall > 0) {\\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\\n        }\\n\\n        // Keep the flywheel moving\\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\\n        updateCompBorrowIndex(cToken, borrowIndex);\\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates borrow and reverts on rejection. May emit logs.\\n     * @param cToken Asset whose underlying is being borrowed\\n     * @param borrower The address borrowing the underlying\\n     * @param borrowAmount The amount of the underlying asset requested to borrow\\n     */\\n    function borrowVerify(\\n        address cToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external override {\\n        // Shh - currently unused\\n        cToken;\\n        borrower;\\n        borrowAmount;\\n\\n        // Shh - we don't ever want this hook to be marked pure\\n        if (false) {\\n            maxAssets = maxAssets;\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\n     * @param cToken The market to verify the repay against\\n     * @param payer The account which would repay the asset\\n     * @param borrower The account which would borrowed the asset\\n     * @param repayAmount The amount of the underlying asset the account would repay\\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function repayBorrowAllowed(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external override returns (uint256) {\\n        // Shh - currently unused\\n        payer;\\n        borrower;\\n        repayAmount;\\n\\n        if (!markets[cToken].isListed) {\\n            return uint256(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        CToken cToken_ = CToken(cToken);\\n\\n        if (cToken_.isGLP()) {\\n            return uint256(Error.CANNOT_BORROW_ASSET);\\n        }\\n\\n        // Keep the flywheel moving\\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\\n        updateCompBorrowIndex(cToken, borrowIndex);\\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\\n     * @param cToken Asset being repaid\\n     * @param payer The address repaying the borrow\\n     * @param borrower The address of the borrower\\n     * @param actualRepayAmount The amount of underlying being repaid\\n     */\\n    function repayBorrowVerify(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint256 actualRepayAmount,\\n        uint256 borrowerIndex\\n    ) external override {\\n        // Shh - currently unused\\n        cToken;\\n        payer;\\n        borrower;\\n        actualRepayAmount;\\n        borrowerIndex;\\n\\n        // Shh - we don't ever want this hook to be marked pure\\n        if (false) {\\n            maxAssets = maxAssets;\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     */\\n    function liquidateBorrowAllowed(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external view override returns (uint256) {\\n        // Shh - currently unused\\n        liquidator;\\n\\n        if (\\n            !markets[cTokenBorrowed].isListed ||\\n            !markets[cTokenCollateral].isListed\\n        ) {\\n            return uint256(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(\\n            borrower\\n        );\\n\\n        /* allow accounts to be liquidated if the market is deprecated */\\n        if (isDeprecated(CToken(cTokenBorrowed))) {\\n            require(\\n                borrowBalance >= repayAmount,\\n                \\\"Can not repay more than the total borrow\\\"\\n            );\\n        } else {\\n            /* The borrower must have shortfall in order to be liquidatable */\\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(\\n                borrower\\n            );\\n            if (err != Error.NO_ERROR) {\\n                return uint256(err);\\n            }\\n\\n            if (shortfall == 0) {\\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\\n            }\\n\\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\\n            uint256 maxClose = mul_ScalarTruncate(\\n                Exp({mantissa: closeFactorMantissa}),\\n                borrowBalance\\n            );\\n            if (repayAmount > maxClose) {\\n                return uint256(Error.TOO_MUCH_REPAY);\\n            }\\n        }\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param actualRepayAmount The amount of underlying being repaid\\n     */\\n    function liquidateBorrowVerify(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 actualRepayAmount,\\n        uint256 seizeTokens\\n    ) external override {\\n        // Shh - currently unused\\n        cTokenBorrowed;\\n        cTokenCollateral;\\n        liquidator;\\n        borrower;\\n        actualRepayAmount;\\n        seizeTokens;\\n\\n        // Shh - we don't ever want this hook to be marked pure\\n        if (false) {\\n            maxAssets = maxAssets;\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the seizing of assets should be allowed to occur\\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param seizeTokens The number of collateral tokens to seize\\n     */\\n    function seizeAllowed(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external override returns (uint256) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!seizeGuardianPaused, \\\"seize is paused\\\");\\n\\n        // Shh - currently unused\\n        seizeTokens;\\n\\n        if (\\n            !markets[cTokenCollateral].isListed ||\\n            !markets[cTokenBorrowed].isListed\\n        ) {\\n            return uint256(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        if (\\n            CToken(cTokenCollateral).comptroller() !=\\n            CToken(cTokenBorrowed).comptroller()\\n        ) {\\n            return uint256(Error.COMPTROLLER_MISMATCH);\\n        }\\n\\n        // Keep the flywheel moving\\n        updateCompSupplyIndex(cTokenCollateral);\\n        distributeSupplierComp(cTokenCollateral, borrower);\\n        distributeSupplierComp(cTokenCollateral, liquidator);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates seize and reverts on rejection. May emit logs.\\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param seizeTokens The number of collateral tokens to seize\\n     */\\n    function seizeVerify(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external override {\\n        // Shh - currently unused\\n        cTokenCollateral;\\n        cTokenBorrowed;\\n        liquidator;\\n        borrower;\\n        seizeTokens;\\n\\n        // Shh - we don't ever want this hook to be marked pure\\n        if (false) {\\n            maxAssets = maxAssets;\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\n     * @param cToken The market to verify the transfer against\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of cTokens to transfer\\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function transferAllowed(\\n        address cToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external override returns (uint256) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!transferGuardianPaused, \\\"transfer is paused\\\");\\n\\n        // Currently the only consideration is whether or not\\n        //  the src is allowed to redeem this many tokens\\n        uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\\n        if (allowed != uint256(Error.NO_ERROR)) {\\n            return allowed;\\n        }\\n\\n        // Keep the flywheel moving\\n        updateCompSupplyIndex(cToken);\\n        distributeSupplierComp(cToken, src);\\n        distributeSupplierComp(cToken, dst);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates transfer and reverts on rejection. May emit logs.\\n     * @param cToken Asset being transferred\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of cTokens to transfer\\n     */\\n    function transferVerify(\\n        address cToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external override {\\n        // Shh - currently unused\\n        cToken;\\n        src;\\n        dst;\\n        transferTokens;\\n\\n        // Shh - we don't ever want this hook to be marked pure\\n        if (false) {\\n            maxAssets = maxAssets;\\n        }\\n    }\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    /**\\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\\n     */\\n    struct AccountLiquidityLocalVars {\\n        uint256 sumCollateral;\\n        uint256 sumBorrowPlusEffects;\\n        uint256 cTokenBalance;\\n        uint256 borrowBalance;\\n        uint256 exchangeRateMantissa;\\n        uint256 oraclePriceMantissa;\\n        Exp collateralFactor;\\n        Exp exchangeRate;\\n        Exp oraclePrice;\\n        Exp tokensToDenom;\\n    }\\n\\n    struct oldFactorsAndThresholds {\\n        uint256 oldCollateralFactorMantissa;\\n        uint256 oldCollateralFactorMantissaVip;\\n        uint256 oldLiquidationThresholdMantissa;\\n        uint256 oldLiquidationThresholdMantissaVip;\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return (possible error code (semi-opaque),\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements)\\n     */\\n    function getAccountLiquidity(address account)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (\\n            Error err,\\n            uint256 liquidity,\\n            uint256 shortfall\\n        ) = getHypotheticalAccountLiquidityInternal(\\n                account,\\n                CToken(address(0)),\\n                0,\\n                0,\\n                true\\n            );\\n\\n        return (uint256(err), liquidity, shortfall);\\n    }\\n\\n    function getIsAccountVip(address _account)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        if (vipNft != address(0)) {\\n            if (IERC721(vipNft).balanceOf(_account) > 0) {\\n                return true;\\n            }\\n        }\\n\\n        if (whitelistedUser[_account]) {\\n            return true;\\n        }\\n        \\n        if (compAddress != address(0)) {\\n            if (EIP20Interface(compAddress).balanceOf(_account) >= tokenBalanceVipThreshold) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return (possible error code,\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements)\\n     */\\n    function getAccountLiquidityInternal(address account)\\n        internal\\n        view\\n        returns (\\n            Error,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return\\n            getHypotheticalAccountLiquidityInternal(\\n                account,\\n                CToken(address(0)),\\n                0,\\n                0,\\n                true\\n            );\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param cTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return (possible error code (semi-opaque),\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n    function getHypotheticalAccountLiquidity(\\n        address account,\\n        address cTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount\\n    )\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (\\n            Error err,\\n            uint256 liquidity,\\n            uint256 shortfall\\n        ) = getHypotheticalAccountLiquidityInternal(\\n                account,\\n                CToken(cTokenModify),\\n                redeemTokens,\\n                borrowAmount,\\n                false\\n            );\\n        return (uint256(err), liquidity, shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param cTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @param liquidation Whether the calls is for liquidation or not\\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return (possible error code,\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n    function getHypotheticalAccountLiquidityInternal(\\n        address account,\\n        CToken cTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount,\\n        bool liquidation\\n    )\\n        internal\\n        view\\n        returns (\\n            Error,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\n        uint256 oErr;\\n\\n        // For each asset the account is in\\n        CToken[] memory assets = accountAssets[account];\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            CToken asset = assets[i];\\n\\n            // Read the balances and exchange rate from the cToken\\n            (\\n                oErr,\\n                vars.cTokenBalance,\\n                vars.borrowBalance,\\n                vars.exchangeRateMantissa\\n            ) = asset.getAccountSnapshot(account);\\n            if (oErr != 0) {\\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\\n                return (Error.SNAPSHOT_ERROR, 0, 0);\\n            }\\n            if(!liquidation){\\n                vars.collateralFactor = getIsAccountVip(account)\\n                    ? Exp({\\n                        mantissa: markets[address(asset)]\\n                            .collateralFactorMantissaVip\\n                    })\\n                    : Exp({\\n                        mantissa: markets[address(asset)].collateralFactorMantissa\\n                    });\\n            } else {\\n                vars.collateralFactor = getIsAccountVip(account)\\n                ? Exp({\\n                    mantissa: markets[address(asset)]\\n                        .liquidationThresholdMantissaVip\\n                })\\n                : Exp({\\n                    mantissa: markets[address(asset)]\\n                        .liquidationThresholdMantissa\\n                });\\n            }\\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\\n\\n            // Get the normalized price of the asset\\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\\n            if (vars.oraclePriceMantissa == 0) {\\n                return (Error.PRICE_ERROR, 0, 0);\\n            }\\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\\n\\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\n            vars.tokensToDenom = mul_(\\n                mul_(vars.collateralFactor, vars.exchangeRate),\\n                vars.oraclePrice\\n            );\\n\\n            // sumCollateral += tokensToDenom * cTokenBalance\\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\\n                vars.tokensToDenom,\\n                vars.cTokenBalance,\\n                vars.sumCollateral\\n            );\\n\\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\\n                vars.oraclePrice,\\n                vars.borrowBalance,\\n                vars.sumBorrowPlusEffects\\n            );\\n\\n            // Calculate effects of interacting with cTokenModify\\n            if (asset == cTokenModify) {\\n                // redeem effect\\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\\n                    vars.tokensToDenom,\\n                    redeemTokens,\\n                    vars.sumBorrowPlusEffects\\n                );\\n\\n                // borrow effect\\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\\n                    vars.oraclePrice,\\n                    borrowAmount,\\n                    vars.sumBorrowPlusEffects\\n                );\\n            }\\n        }\\n\\n        // These are safe, as the underflow condition is checked first\\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\\n            return (\\n                Error.NO_ERROR,\\n                vars.sumCollateral - vars.sumBorrowPlusEffects,\\n                0\\n            );\\n        } else {\\n            return (\\n                Error.NO_ERROR,\\n                0,\\n                vars.sumBorrowPlusEffects - vars.sumCollateral\\n            );\\n        }\\n    }\\n    \\n    /**\\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\\n     * @param cTokenBorrowed The address of the borrowed cToken\\n     * @param cTokenCollateral The address of the collateral cToken\\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\\n     */\\n    function liquidateCalculateSeizeTokens(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        uint256 actualRepayAmount\\n    ) external view override returns (uint256, uint256) {\\n        /* Read oracle prices for borrowed and collateral markets */\\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(\\n            CToken(cTokenBorrowed)\\n        );\\n        uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(\\n            CToken(cTokenCollateral)\\n        );\\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\\n            return (uint256(Error.PRICE_ERROR), 0);\\n        }\\n\\n        /*\\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n         *  seizeTokens = seizeAmount / exchangeRate\\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n         */\\n        uint256 exchangeRateMantissa = CToken(cTokenCollateral)\\n            .exchangeRateStored(); // Note: reverts on error\\n        uint256 seizeTokens;\\n        Exp memory numerator;\\n        Exp memory denominator;\\n        Exp memory ratio;\\n\\n        numerator = mul_(\\n            Exp({mantissa: liquidationIncentiveMantissa}),\\n            Exp({mantissa: priceBorrowedMantissa})\\n        );\\n        denominator = mul_(\\n            Exp({mantissa: priceCollateralMantissa}),\\n            Exp({mantissa: exchangeRateMantissa})\\n        );\\n        ratio = div_(numerator, denominator);\\n\\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\n\\n        return (uint256(Error.NO_ERROR), seizeTokens);\\n    }\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n     * @notice Sets a new price oracle for the comptroller\\n     * @dev Admin function to set a new price oracle\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return\\n                fail(\\n                    Error.UNAUTHORIZED,\\n                    FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK\\n                );\\n        }\\n\\n        // Track the old oracle for the comptroller\\n        PriceOracle oldOracle = oracle;\\n\\n        // Set comptroller's oracle to newOracle\\n        oracle = newOracle;\\n\\n        // Emit NewPriceOracle(oldOracle, newOracle)\\n        emit NewPriceOracle(oldOracle, newOracle);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sets the closeFactor used when liquidating borrows\\n     * @dev Admin function to set closeFactor\\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n     * @return uint 0=success, otherwise a failure\\n     */\\n    function _setCloseFactor(uint256 newCloseFactorMantissa)\\n        external\\n        returns (uint256)\\n    {\\n        // Check caller is admin\\n        require(msg.sender == admin, \\\"only admin can set close factor\\\");\\n\\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = newCloseFactorMantissa;\\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    function _setFactorsAndThresholds(\\n        CToken cToken,\\n        uint256 newCollateralFactorMantissa,\\n        uint256 newCollateralFactorMantissaVip,\\n        uint256 newLiquidationThresholdMantissa,\\n        uint256 newLiquidationThresholdMantissaVip\\n    ) external returns (uint256) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return\\n                fail(\\n                    Error.UNAUTHORIZED,\\n                    FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK\\n                );\\n        }   \\n\\n        require(newCollateralFactorMantissa <= newCollateralFactorMantissaVip, \\\"collateral factor cannot be greater than vip\\\");\\n        require(newLiquidationThresholdMantissa <= newLiquidationThresholdMantissaVip, \\\"liquidation threshold cannot be greater than vip\\\");\\n        require(newCollateralFactorMantissaVip <= newLiquidationThresholdMantissaVip, \\\"Collateral factor must be lower than liquidation threshold\\\");\\n\\n        // Verify market is listed\\n        Market storage market = markets[address(cToken)];\\n        if (!market.isListed) {\\n            return\\n                fail(\\n                    Error.MARKET_NOT_LISTED,\\n                    FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS\\n                );\\n        }\\n\\n        Exp memory newLiquidationThresholdExp = Exp({\\n            mantissa: newLiquidationThresholdMantissa\\n        });\\n\\n        // Check collateral factor <= max\\n        Exp memory highLimitLT = Exp({mantissa: liquidationThresholdMaxMantissa});\\n\\n        if (lessThanExp(highLimitLT, newLiquidationThresholdExp)) {\\n            return\\n                fail(\\n                    Error.INVALID_COLLATERAL_FACTOR,\\n                    FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION\\n                );\\n        }\\n\\n        // If collateral factor != 0, fail if price == 0\\n        if (\\n            oracle.getUnderlyingPrice(cToken) == 0\\n        ) {\\n            return\\n                fail(\\n                    Error.PRICE_ERROR,\\n                    FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE\\n                );\\n        }\\n\\n        oldFactorsAndThresholds memory oldVars;\\n\\n        oldVars.oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\\n\\n        oldVars.oldCollateralFactorMantissaVip = market.collateralFactorMantissaVip;\\n        market.collateralFactorMantissaVip = newCollateralFactorMantissaVip;\\n\\n        oldVars.oldLiquidationThresholdMantissa = market\\n            .liquidationThresholdMantissa;\\n        market.liquidationThresholdMantissa = newLiquidationThresholdMantissa;\\n\\n        oldVars.oldLiquidationThresholdMantissaVip = market\\n            .liquidationThresholdMantissaVip;\\n        market.liquidationThresholdMantissaVip = newLiquidationThresholdMantissaVip;\\n\\n        emit NewFactorsAndThresholds(\\n            cToken,\\n            oldVars.oldCollateralFactorMantissa,\\n            newCollateralFactorMantissa,\\n            oldVars.oldCollateralFactorMantissaVip,\\n            newCollateralFactorMantissaVip,\\n            oldVars.oldLiquidationThresholdMantissa,\\n            newLiquidationThresholdMantissa,\\n            oldVars.oldLiquidationThresholdMantissaVip,\\n            newLiquidationThresholdMantissaVip\\n        );\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sets liquidationIncentive\\n     * @dev Admin function to set liquidationIncentive\\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n     */\\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\\n        external\\n        returns (uint256)\\n    {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return\\n                fail(\\n                    Error.UNAUTHORIZED,\\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK\\n                );\\n        }\\n\\n        // Save current value for use in log\\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n        // Set liquidation incentive to new incentive\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n        // Emit event with old incentive, new incentive\\n        emit NewLiquidationIncentive(\\n            oldLiquidationIncentiveMantissa,\\n            newLiquidationIncentiveMantissa\\n        );\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Add the market to the markets mapping and set it as listed\\n     * @dev Admin function to set isListed and add support for the market\\n     * @param cToken The address of the market (token) to list\\n     * @param isComped_ Will this market receive rewards\\n     * @param isPrivate_ Is this market open to the public\\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n     */\\n    function _supportMarket(\\n        CToken cToken,\\n        bool isComped_,\\n        bool isPrivate_,\\n        bool onlyWhitelistedBorrow_\\n    ) external returns (uint256) {\\n        if (msg.sender != admin) {\\n            return\\n                fail(\\n                    Error.UNAUTHORIZED,\\n                    FailureInfo.SUPPORT_MARKET_OWNER_CHECK\\n                );\\n        }\\n\\n        if (markets[address(cToken)].isListed) {\\n            return\\n                fail(\\n                    Error.MARKET_ALREADY_LISTED,\\n                    FailureInfo.SUPPORT_MARKET_EXISTS\\n                );\\n        }\\n\\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\\n\\n        // Note that isComped is not in active use anymore\\n        Market storage newMarket = markets[address(cToken)];\\n        newMarket.isListed = true;\\n        newMarket.isComped = isComped_;\\n        newMarket.isPrivate = isPrivate_;\\n        newMarket.onlyWhitelistedBorrow = onlyWhitelistedBorrow_;\\n        newMarket.collateralFactorMantissa = 0;\\n        newMarket.liquidationThresholdMantissa = 0;\\n        newMarket.collateralFactorMantissaVip = 0;\\n        newMarket.liquidationThresholdMantissaVip = 0;\\n\\n        _addMarketInternal(address(cToken));\\n        _initializeMarket(address(cToken));\\n\\n        emit MarketListed(cToken);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    function _addMarketInternal(address cToken) internal {\\n        for (uint256 i = 0; i < allMarkets.length; i++) {\\n            require(allMarkets[i] != CToken(cToken), \\\"market already added\\\");\\n        }\\n        allMarkets.push(CToken(cToken));\\n    }\\n\\n    function _initializeMarket(address cToken) internal {\\n        uint32 blockNumber = safe32(\\n            getBlockNumber(),\\n            \\\"block number exceeds 32 bits\\\"\\n        );\\n\\n        CompMarketState storage supplyState = compSupplyState[cToken];\\n        CompMarketState storage borrowState = compBorrowState[cToken];\\n\\n        /*\\n         * Update market state indices\\n         */\\n        if (supplyState.index == 0) {\\n            // Initialize supply state index with default value\\n            supplyState.index = compInitialIndex;\\n        }\\n\\n        if (borrowState.index == 0) {\\n            // Initialize borrow state index with default value\\n            borrowState.index = compInitialIndex;\\n        }\\n\\n        /*\\n         * Update market state block numbers\\n         */\\n        supplyState.block = borrowState.block = blockNumber;\\n    }\\n\\n    /**\\n     * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\n     * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\\n     * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\\n     */\\n    function _setMarketBorrowCaps(\\n        CToken[] calldata cTokens,\\n        uint256[] calldata newBorrowCaps,\\n        uint256[] calldata newSupplyCaps\\n    ) external {\\n        require(\\n            msg.sender == admin || msg.sender == borrowCapGuardian,\\n            \\\"not authorized\\\"\\n        );\\n\\n        uint256 numMarkets = cTokens.length;\\n        uint256 numBorrowCaps = newBorrowCaps.length;\\n        uint256 numSupplyCaps = newSupplyCaps.length;\\n\\n        require(\\n            numMarkets != 0 && numMarkets == numBorrowCaps && numBorrowCaps == numSupplyCaps,\\n            \\\"invalid input\\\"\\n        );\\n\\n        for (uint256 i = 0; i < numMarkets; i++) {\\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\\n            supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\\n            emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Admin function to change the Borrow Cap Guardian\\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\\n     */\\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\\n        require(msg.sender == admin, \\\"not authorized\\\");\\n\\n        // Save current value for inclusion in log\\n        address oldBorrowCapGuardian = borrowCapGuardian;\\n\\n        // Store borrowCapGuardian with value newBorrowCapGuardian\\n        borrowCapGuardian = newBorrowCapGuardian;\\n\\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\\n    }\\n\\n    /**\\n     * @notice Admin function to change the Pause Guardian\\n     * @param newPauseGuardian The address of the new Pause Guardian\\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n     */\\n    function _setPauseGuardian(address newPauseGuardian)\\n        public\\n        returns (uint256)\\n    {\\n        if (msg.sender != admin) {\\n            return\\n                fail(\\n                    Error.UNAUTHORIZED,\\n                    FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK\\n                );\\n        }\\n\\n        // Save current value for inclusion in log\\n        address oldPauseGuardian = pauseGuardian;\\n\\n        // Store pauseGuardian with value newPauseGuardian\\n        pauseGuardian = newPauseGuardian;\\n\\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\\n\\n        return uint256(Error.NO_ERROR);\\n    }\\n\\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\\n        require(\\n            markets[address(cToken)].isListed,\\n            \\\"cannot pause - listed\\\"\\n        );\\n        require(\\n            msg.sender == pauseGuardian || msg.sender == admin,\\n            \\\"not authorized\\\"\\n        );\\n        require(msg.sender == admin || state == true, \\\"not authorized\\\");\\n\\n        mintGuardianPaused[address(cToken)] = state;\\n        emit ActionPaused(cToken, \\\"Mint\\\", state);\\n        return state;\\n    }\\n\\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\\n        require(\\n            markets[address(cToken)].isListed,\\n            \\\"cannot pause - not listed\\\"\\n        );\\n        require(\\n            msg.sender == pauseGuardian || msg.sender == admin,\\n            \\\"not authorized\\\"\\n        );\\n        require(msg.sender == admin || state == true, \\\"not authorized\\\");\\n\\n        borrowGuardianPaused[address(cToken)] = state;\\n        emit ActionPaused(cToken, \\\"Borrow\\\", state);\\n        return state;\\n    }\\n\\n    function _setTransferPaused(bool state) public returns (bool) {\\n        require(\\n            msg.sender == pauseGuardian || msg.sender == admin,\\n            \\\"not authorized\\\"\\n        );\\n        require(msg.sender == admin || state == true, \\\"not authorized\\\");\\n\\n        transferGuardianPaused = state;\\n        emit ActionPaused(\\\"Transfer\\\", state);\\n        return state;\\n    }\\n\\n    function _setSeizePaused(bool state) public returns (bool) {\\n        require(\\n            msg.sender == pauseGuardian || msg.sender == admin,\\n            \\\"not authorized\\\"\\n        );\\n        require(msg.sender == admin || state == true, \\\"not authorized\\\");\\n\\n        seizeGuardianPaused = state;\\n        emit ActionPaused(\\\"Seize\\\", state);\\n        return state;\\n    }\\n\\n    function _become(Unitroller unitroller) public {\\n        require(\\n            msg.sender == unitroller.admin(),\\n            \\\"only unitroller admin can change brains\\\"\\n        );\\n        require(\\n            unitroller._acceptImplementation() == 0,\\n            \\\"not authorized\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\\n     */\\n    function adminOrInitializing() internal view returns (bool) {\\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\\n    }\\n\\n    /*** Comp Distribution ***/\\n\\n    /**\\n     * @notice Set COMP speed for a single market\\n     * @param cToken The market whose COMP speed to update\\n     * @param supplySpeed New supply-side COMP speed for market\\n     * @param borrowSpeed New borrow-side COMP speed for market\\n     */\\n    function setCompSpeedInternal(\\n        CToken cToken,\\n        uint256 supplySpeed,\\n        uint256 borrowSpeed\\n    ) internal {\\n        Market storage market = markets[address(cToken)];\\n        require(market.isListed, \\\"comp market not listed\\\");\\n\\n        if (compSupplySpeeds[address(cToken)] != supplySpeed) {\\n            // Supply speed updated so let's update supply state to ensure that\\n            //  1. COMP accrued properly for the old speed, and\\n            //  2. COMP accrued at the new speed starts after this block.\\n            updateCompSupplyIndex(address(cToken));\\n\\n            // Update speed and emit event\\n            compSupplySpeeds[address(cToken)] = supplySpeed;\\n            emit CompSupplySpeedUpdated(cToken, supplySpeed);\\n        }\\n\\n        if (compBorrowSpeeds[address(cToken)] != borrowSpeed) {\\n            // Borrow speed updated so let's update borrow state to ensure that\\n            //  1. COMP accrued properly for the old speed, and\\n            //  2. COMP accrued at the new speed starts after this block.\\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\\n            updateCompBorrowIndex(address(cToken), borrowIndex);\\n\\n            // Update speed and emit event\\n            compBorrowSpeeds[address(cToken)] = borrowSpeed;\\n            emit CompBorrowSpeedUpdated(cToken, borrowSpeed);\\n        }\\n    }\\n\\n    /**\\n     * @notice Accrue COMP to the market by updating the supply index\\n     * @param cToken The market whose supply index to update\\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\\n     */\\n    function updateCompSupplyIndex(address cToken) internal {\\n        CompMarketState storage supplyState = compSupplyState[cToken];\\n        uint256 supplySpeed = compSupplySpeeds[cToken];\\n        uint32 blockNumber = safe32(\\n            getBlockNumber(),\\n            \\\"block number exceeds 32 bits\\\"\\n        );\\n        uint256 deltaBlocks = sub_(\\n            uint256(blockNumber),\\n            uint256(supplyState.block)\\n        );\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\n            uint256 supplyTokens = CToken(cToken).totalSupply();\\n            uint256 compAccrued = mul_(deltaBlocks, supplySpeed);\\n            Double memory ratio = supplyTokens > 0\\n                ? fraction(compAccrued, supplyTokens)\\n                : Double({mantissa: 0});\\n            supplyState.index = safe224(\\n                add_(Double({mantissa: supplyState.index}), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            supplyState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            supplyState.block = blockNumber;\\n        }\\n    }\\n\\n    /**\\n     * @notice Accrue COMP to the market by updating the borrow index\\n     * @param cToken The market whose borrow index to update\\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\\n     */\\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex)\\n        internal\\n    {\\n        CompMarketState storage borrowState = compBorrowState[cToken];\\n        uint256 borrowSpeed = compBorrowSpeeds[cToken];\\n        uint32 blockNumber = safe32(\\n            getBlockNumber(),\\n            \\\"block number exceeds 32 bits\\\"\\n        );\\n        uint256 deltaBlocks = sub_(\\n            uint256(blockNumber),\\n            uint256(borrowState.block)\\n        );\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\n            uint256 borrowAmount = div_(\\n                CToken(cToken).totalBorrows(),\\n                marketBorrowIndex\\n            );\\n            uint256 compAccrued = mul_(deltaBlocks, borrowSpeed);\\n            Double memory ratio = borrowAmount > 0\\n                ? fraction(compAccrued, borrowAmount)\\n                : Double({mantissa: 0});\\n            borrowState.index = safe224(\\n                add_(Double({mantissa: borrowState.index}), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            borrowState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            borrowState.block = blockNumber;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\\n     * @param cToken The market in which the supplier is interacting\\n     * @param supplier The address of the supplier to distribute COMP to\\n     */\\n    function distributeSupplierComp(address cToken, address supplier) internal {\\n        // TODO: Don't distribute supplier COMP if the user is not in the supplier market.\\n        // This check should be as gas efficient as possible as distributeSupplierComp is called in many places.\\n        // - We really don't want to call an external contract as that's quite expensive.\\n\\n        CompMarketState storage supplyState = compSupplyState[cToken];\\n        uint256 supplyIndex = supplyState.index;\\n        uint256 supplierIndex = compSupplierIndex[cToken][supplier];\\n\\n        // Update supplier's index to the current index since we are distributing accrued COMP\\n        compSupplierIndex[cToken][supplier] = supplyIndex;\\n\\n        if (supplierIndex == 0 && supplyIndex >= compInitialIndex) {\\n            // Covers the case where users supplied tokens before the market's supply state index was set.\\n            // Rewards the user with COMP accrued from the start of when supplier rewards were first\\n            // set for the market.\\n            supplierIndex = compInitialIndex;\\n        }\\n\\n        // Calculate change in the cumulative sum of the COMP per cToken accrued\\n        Double memory deltaIndex = Double({\\n            mantissa: sub_(supplyIndex, supplierIndex)\\n        });\\n\\n        uint256 supplierTokens = CToken(cToken).balanceOf(supplier);\\n\\n        // Calculate COMP accrued: cTokenAmount * accruedPerCToken\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\n\\n        uint256 supplierAccrued = add_(compAccrued[supplier], supplierDelta);\\n        compAccrued[supplier] = supplierAccrued;\\n\\n        emit DistributedSupplierComp(\\n            CToken(cToken),\\n            supplier,\\n            supplierDelta,\\n            supplyIndex\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\\n     * @param cToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute COMP to\\n     */\\n    function distributeBorrowerComp(\\n        address cToken,\\n        address borrower,\\n        Exp memory marketBorrowIndex\\n    ) internal {\\n        // TODO: Don't distribute supplier COMP if the user is not in the borrower market.\\n        // This check should be as gas efficient as possible as distributeBorrowerComp is called in many places.\\n        // - We really don't want to call an external contract as that's quite expensive.\\n\\n        CompMarketState storage borrowState = compBorrowState[cToken];\\n        uint256 borrowIndex = borrowState.index;\\n        uint256 borrowerIndex = compBorrowerIndex[cToken][borrower];\\n\\n        // Update borrowers's index to the current index since we are distributing accrued COMP\\n        compBorrowerIndex[cToken][borrower] = borrowIndex;\\n\\n        if (borrowerIndex == 0 && borrowIndex >= compInitialIndex) {\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\n            // Rewards the user with COMP accrued from the start of when borrower rewards were first\\n            // set for the market.\\n            borrowerIndex = compInitialIndex;\\n        }\\n\\n        // Calculate change in the cumulative sum of the COMP per borrowed unit accrued\\n        Double memory deltaIndex = Double({\\n            mantissa: sub_(borrowIndex, borrowerIndex)\\n        });\\n\\n        uint256 borrowerAmount = div_(\\n            CToken(cToken).borrowBalanceStored(borrower),\\n            marketBorrowIndex\\n        );\\n\\n        // Calculate COMP accrued: cTokenAmount * accruedPerBorrowedUnit\\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\n\\n        uint256 borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\\n        compAccrued[borrower] = borrowerAccrued;\\n\\n        emit DistributedBorrowerComp(\\n            CToken(cToken),\\n            borrower,\\n            borrowerDelta,\\n            borrowIndex\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculate additional accrued COMP for a contributor since last accrual\\n     * @param contributor The address to calculate contributor rewards for\\n     */\\n    function updateContributorRewards(address contributor) public {\\n        uint256 compSpeed = compContributorSpeeds[contributor];\\n        uint256 blockNumber = getBlockNumber();\\n        uint256 deltaBlocks = sub_(\\n            blockNumber,\\n            lastContributorBlock[contributor]\\n        );\\n        if (deltaBlocks > 0 && compSpeed > 0) {\\n            uint256 newAccrued = mul_(deltaBlocks, compSpeed);\\n            uint256 contributorAccrued = add_(\\n                compAccrued[contributor],\\n                newAccrued\\n            );\\n\\n            compAccrued[contributor] = contributorAccrued;\\n            lastContributorBlock[contributor] = blockNumber;\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim all the comp accrued by holder in all markets\\n     * @param holder The address to claim COMP for\\n     */\\n    function claimComp(address holder) public {\\n        return claimComp(holder, allMarkets);\\n    }\\n\\n    /**\\n     * @notice Claim all the comp accrued by holder in the specified markets\\n     * @param holder The address to claim COMP for\\n     * @param cTokens The list of markets to claim COMP in\\n     */\\n    function claimComp(address holder, CToken[] memory cTokens) public {\\n        address[] memory holders = new address[](1);\\n        holders[0] = holder;\\n        claimComp(holders, cTokens, true, true);\\n    }\\n\\n    /**\\n     * @notice Claim all comp accrued by the holders\\n     * @param holders The addresses to claim COMP for\\n     * @param cTokens The list of markets to claim COMP in\\n     * @param borrowers Whether or not to claim COMP earned by borrowing\\n     * @param suppliers Whether or not to claim COMP earned by supplying\\n     */\\n    function claimComp(\\n        address[] memory holders,\\n        CToken[] memory cTokens,\\n        bool borrowers,\\n        bool suppliers\\n    ) public {\\n        for (uint256 i = 0; i < cTokens.length; i++) {\\n            CToken cToken = cTokens[i];\\n            require(markets[address(cToken)].isListed, \\\"market not listed\\\");\\n            if (borrowers == true) {\\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\\n                updateCompBorrowIndex(address(cToken), borrowIndex);\\n                for (uint256 j = 0; j < holders.length; j++) {\\n                    distributeBorrowerComp(\\n                        address(cToken),\\n                        holders[j],\\n                        borrowIndex\\n                    );\\n                }\\n            }\\n            if (suppliers == true) {\\n                updateCompSupplyIndex(address(cToken));\\n                for (uint256 j = 0; j < holders.length; j++) {\\n                    distributeSupplierComp(address(cToken), holders[j]);\\n                }\\n            }\\n        }\\n        for (uint256 j = 0; j < holders.length; j++) {\\n            compAccrued[holders[j]] = grantCompInternal(\\n                holders[j],\\n                compAccrued[holders[j]]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer COMP to the user\\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\\n     * @param user The address of the user to transfer COMP to\\n     * @param amount The amount of COMP to (possibly) transfer\\n     * @return The amount of COMP which was NOT transferred to the user\\n     */\\n    function grantCompInternal(address user, uint256 amount)\\n        internal\\n        returns (uint256)\\n    {\\n        Comp comp = Comp(getCompAddress());\\n        uint256 compRemaining = comp.balanceOf(address(this));\\n        if (amount > 0 && amount <= compRemaining) {\\n            comp.transfer(user, amount);\\n            return 0;\\n        }\\n        return amount;\\n    }\\n\\n    /*** Comp Distribution Admin ***/\\n\\n    /**\\n     * @notice Transfer COMP to the recipient\\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\\n     * @param recipient The address of the recipient to transfer COMP to\\n     * @param amount The amount of COMP to (possibly) transfer\\n     */\\n    function _grantComp(address recipient, uint256 amount) public {\\n        require(adminOrInitializing(), \\\"not authorized\\\");\\n        uint256 amountLeft = grantCompInternal(recipient, amount);\\n        require(amountLeft == 0, \\\"insufficient comp for grant\\\");\\n        emit CompGranted(recipient, amount);\\n    }\\n\\n    /**\\n     * @notice Set COMP borrow and supply speeds for the specified markets.\\n     * @param cTokens The markets whose COMP speed to update.\\n     * @param supplySpeeds New supply-side COMP speed for the corresponding market.\\n     * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\\n     */\\n    function _setCompSpeeds(\\n        CToken[] memory cTokens,\\n        uint256[] memory supplySpeeds,\\n        uint256[] memory borrowSpeeds\\n    ) public {\\n        require(adminOrInitializing(), \\\"not authorized\\\");\\n\\n        uint256 numTokens = cTokens.length;\\n        require(\\n            numTokens == supplySpeeds.length &&\\n                numTokens == borrowSpeeds.length,\\n            \\\"Comptroller::_setCompSpeeds invalid input\\\"\\n        );\\n\\n        for (uint256 i = 0; i < numTokens; ++i) {\\n            setCompSpeedInternal(cTokens[i], supplySpeeds[i], borrowSpeeds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set COMP speed for a single contributor\\n     * @param contributor The contributor whose COMP speed to update\\n     * @param compSpeed New COMP speed for contributor\\n     */\\n    function _setContributorCompSpeed(address contributor, uint256 compSpeed)\\n        public\\n    {\\n        require(adminOrInitializing(), \\\"not authorized\\\");\\n\\n        // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\\n        updateContributorRewards(contributor);\\n        if (compSpeed == 0) {\\n            // release storage\\n            delete lastContributorBlock[contributor];\\n        } else {\\n            lastContributorBlock[contributor] = getBlockNumber();\\n        }\\n        compContributorSpeeds[contributor] = compSpeed;\\n\\n        emit ContributorCompSpeedUpdated(contributor, compSpeed);\\n    }\\n\\n    /**\\n     * @notice Return all of the markets\\n     * @dev The automatic getter may be used to access an individual market.\\n     * @return The list of market addresses\\n     */\\n    function getAllMarkets() public view returns (CToken[] memory) {\\n        return allMarkets;\\n    }\\n\\n    /**\\n     * @notice Returns true if the given cToken market has been deprecated\\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\\n     * @param cToken The market to check if deprecated\\n     */\\n    function isDeprecated(CToken cToken) public view returns (bool) {\\n        return\\n            markets[address(cToken)].collateralFactorMantissa == 0 &&\\n            borrowGuardianPaused[address(cToken)] == true &&\\n            cToken.reserveFactorMantissa() == 1e18;\\n    }\\n\\n    function getBlockNumber() public view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Return the address of the COMP token\\n     * @return The address of COMP\\n     */\\n    function getCompAddress() public view virtual returns (address) {\\n        return compAddress;\\n    }\\n\\n    function setCompAddress(address compAddress_) external {\\n        require(msg.sender == admin, \\\"only admin can set compAddress\\\");\\n        if (!immutableCompAddress) {\\n            compAddress = compAddress_;\\n        }\\n    }\\n\\n    function setImmutableCompAddress() external {\\n        require(msg.sender == admin, \\\"only admin can set compAddress\\\");\\n        immutableCompAddress = true;\\n    }\\n\\n    function setMarketVariables(address cToken_, bool isPrivate_,  bool onlyWhitelistedCanBorrow_, bool isComped_) external {\\n        require(msg.sender == admin, \\\"only admin can set market to private\\\");\\n        markets[cToken_].isPrivate = isPrivate_;\\n        markets[cToken_].onlyWhitelistedBorrow = onlyWhitelistedCanBorrow_;\\n        markets[cToken_].isComped = isComped_;\\n    }\\n\\n    function setVipNft(address _vipNft) external {\\n        require(msg.sender == admin, \\\"only admin can set Vip NFT\\\");\\n        vipNft = _vipNft;\\n    }\\n\\n    function setTokenBalanceVipThreshold(uint256 _tokenBalanceVipThreshold)\\n        external\\n    {\\n        require(\\n            msg.sender == admin,\\n            \\\"not authorized\\\"\\n        );\\n        tokenBalanceVipThreshold = _tokenBalanceVipThreshold;\\n    }\\n\\n    function setWhitelistedUser(address user_, bool isWhiteListed_) external {\\n        require(msg.sender == admin, \\\"only admin can whitelist users\\\");\\n        whitelistedUser[user_] = isWhiteListed_;\\n    }\\n}\\n\\n\\n\\n\"\r\n    },\r\n    \"contracts/CToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ComptrollerInterface.sol\\\";\\nimport \\\"./CTokenInterfaces.sol\\\";\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\nimport \\\"./IGmxRewardRouter.sol\\\";\\nimport \\\"./IStakedGlp.sol\\\";\\n\\n/**\\n * @title Compound's CToken Contract\\n * @notice Abstract base for CTokens\\n * @author Compound\\n */\\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\\n    /**\\n     * @notice Initialize the money market\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ EIP-20 name of this token\\n     * @param symbol_ EIP-20 symbol of this token\\n     * @param decimals_ EIP-20 decimal precision of this token\\n     * @param isGLP_ Wether or not the market being created is for the GLP token\\n     */\\n    function initialize(ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_,\\n                        bool isGLP_) public {\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        // Set the comptroller\\n        uint err = _setComptroller(comptroller_);\\n        require(err == NO_ERROR, \\\"setting comptroller failed\\\");\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = getBlockNumber();\\n        borrowIndex = mantissaOne;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        err = _setInterestRateModelFresh(interestRateModel_);\\n        require(err == NO_ERROR, \\\"setting interest rate model failed\\\");\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n        isGLP = isGLP_;\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     * @return 0 if the transfer succeeded, else revert\\n     */\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\n        /* Fail if transfer not allowed */\\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\\n        if (allowed != 0) {\\n            revert TransferComptrollerRejection(allowed);\\n        }\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            revert TransferNotAllowed();\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint startingAllowance = 0;\\n        if (spender == src) {\\n            startingAllowance = type(uint).max;\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        uint allowanceNew = startingAllowance - tokens;\\n        uint srcTokensNew = accountTokens[src] - tokens;\\n        uint dstTokensNew = accountTokens[dst] + tokens;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != type(uint).max) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n\\n        // unused function\\n        // comptroller.transferVerify(address(this), src, dst, tokens);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) override external returns (bool) {\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) override external view returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) override external view returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) override external returns (uint) {\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\\n        return (\\n            NO_ERROR,\\n            accountTokens[account],\\n            borrowBalanceStoredInternal(account),\\n            exchangeRateStoredInternal()\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     */\\n    function getBlockNumber() virtual internal view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() override external view returns (uint) {\\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() override external view returns (uint) {\\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        return borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) override public view returns (uint) {\\n        return borrowBalanceStoredInternal(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\\n     */\\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return 0;\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\\n        accrueInterest();\\n        return exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() override public view returns (uint) {\\n        return exchangeRateStoredInternal();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\\n        uint _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return initialExchangeRateMantissa;\\n        } else {\\n            /*\\n             * Otherwise:\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n             */\\n            uint totalCash = getCashPrior();\\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\\n            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\\n\\n            return exchangeRate;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this cToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() override external view returns (uint) {\\n        return getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     */\\n    function accrueInterest() virtual override public returns (uint) {\\n        // if this is a GLP cToken, claim the ETH and esGMX rewards and stake the esGMX Rewards\\n        if (isGLP){\\n            if(totalSupply > 0){\\n                if(autocompound){\\n                    glpRewardRouter.handleRewards(true, false, true, true, true, true, false);\\n                    uint ethBalance =  EIP20Interface(WETH).balanceOf(address(this));\\n                    \\n                    if(ethBalance > 0){\\n                        uint ethManagementFee = mul_(ethBalance, div_(managementFee, 100));\\n                        uint ethToCompound = sub_(ethBalance, ethManagementFee);\\n                        EIP20Interface(WETH).transfer(admin, ethManagementFee);\\n                        glpRewardRouter.mintAndStakeGlp(WETH, ethToCompound, 0, 0);\\n                        \\n                    }\\n                } else {\\n                    glpRewardRouter.handleRewards(true, false, true, true, true, true, false);\\n                }\\n            }\\n        } else {\\n            /* Remember the initial block number */\\n            uint currentBlockNumber = getBlockNumber();\\n            uint accrualBlockNumberPrior = accrualBlockNumber;\\n\\n            /* Short-circuit accumulating 0 interest */\\n            if (accrualBlockNumberPrior == currentBlockNumber) {\\n                return NO_ERROR;\\n            }\\n\\n            /* Read the previous values out of storage */\\n            uint cashPrior = getCashPrior();\\n            uint borrowsPrior = totalBorrows;\\n            uint reservesPrior = totalReserves;\\n            uint borrowIndexPrior = borrowIndex;\\n\\n            /* Calculate the current borrow interest rate */\\n            uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\n            require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n\\n            /* Calculate the number of blocks elapsed since the last accrual */\\n            uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\n\\n            /*\\n            * Calculate the interest accumulated into borrows and reserves and the new index:\\n            *  simpleInterestFactor = borrowRate * blockDelta\\n            *  interestAccumulated = simpleInterestFactor * totalBorrows\\n            *  totalBorrowsNew = interestAccumulated + totalBorrows\\n            *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n            *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n            */\\n\\n            Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n            uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n            uint totalBorrowsNew = interestAccumulated + borrowsPrior;\\n            uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\\n            uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n            /////////////////////////\\n            // EFFECTS & INTERACTIONS\\n            // (No safe failures beyond this point)\\n\\n            /* We write the previously calculated values into storage */\\n            accrualBlockNumber = currentBlockNumber;\\n            borrowIndex = borrowIndexNew;\\n            totalBorrows = totalBorrowsNew;\\n            totalReserves = totalReservesNew;\\n\\n            /* We emit an AccrueInterest event */\\n            emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n        }\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function mintInternal(uint mintAmount) internal nonReentrant {\\n        accrueInterest();\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        mintFresh(msg.sender, mintAmount);\\n    }\\n\\n\\n    function _setAutocompoundRewards(bool autocompound_) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetAutoCompoundOwnerCheck();\\n        }\\n        EIP20Interface(WETH).approve(glpManager, type(uint256).max);\\n        autocompound = autocompound_;\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives cTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function mintFresh(address minter, uint mintAmount) internal {\\n        /* Fail if mint not allowed */\\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\\n        if (allowed != 0) {\\n            revert MintComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber() && !isGLP) {\\n            revert MintFreshnessCheck();\\n        }\\n\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n        /*\\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         * And write them into storage\\n         */\\n        totalSupply = totalSupply + mintTokens;\\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, actualMintAmount, mintTokens);\\n        emit Transfer(address(this), minter, mintTokens);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     */\\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\\n        accrueInterest();\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\\n     */\\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\\n        accrueInterest();\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\\n    }\\n\\n    /**\\n     * @notice User redeems cTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     */\\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\\n\\n        uint redeemTokens;\\n        uint redeemAmount;\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n             */\\n            redeemTokens = redeemTokensIn;\\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             *  redeemAmount = redeemAmountIn\\n             */\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\n            redeemAmount = redeemAmountIn;\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\\n        if (allowed != 0) {\\n            revert RedeemComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber() && !isGLP) {\\n            revert RedeemFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (getCashPrior() < redeemAmount) {\\n            revert RedeemTransferOutNotPossible();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\n         */\\n        totalSupply = totalSupply - redeemTokens;\\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\\n\\n        /*\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken has redeemAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        bool isRedeemerVip = comptroller.getIsAccountVip(redeemer);\\n\\n        if(isGLP && !isRedeemerVip  ){\\n            uint256 withdrawFeeAmount = div_(mul_(redeemAmount, sub_(100, withdrawFee)), 100);\\n            uint256 actualRedeemAmount = sub_(redeemAmount, withdrawFee);\\n            doTransferOut(admin, withdrawFeeAmount);\\n            doTransferOut(redeemer, actualRedeemAmount);\\n        } else {\\n            doTransferOut(redeemer, redeemAmount);\\n        }\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), redeemTokens);\\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      */\\n    function borrowInternal(uint borrowAmount) internal nonReentrant {\\n        accrueInterest();\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        borrowFresh(payable(msg.sender), borrowAmount);\\n    }\\n\\n    /**\\n      * @notice Users borrow assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      */\\n    function borrowFresh(address payable borrower, uint borrowAmount) internal {\\n        /* Fail if borrow not allowed */\\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\\n        if (allowed != 0) {\\n            revert BorrowComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert BorrowFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (getCashPrior() < borrowAmount) {\\n            revert BorrowCashNotAvailable();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n        uint totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\n        `*/\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /*\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken borrowAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(borrower, borrowAmount);\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     */\\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant {\\n        accrueInterest();\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     */\\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\\n        accrueInterest();\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\\n     * @return (uint) the actual repayment amount.\\n     */\\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\\n        /* Fail if repayBorrow not allowed */\\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\n        if (allowed != 0) {\\n            revert RepayBorrowComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert RepayBorrowFreshnessCheck();\\n        }\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n\\n        /* If repayAmount == -1, repayAmount = accountBorrows */\\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the payer and the repayAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional repayAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n        uint totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n        return actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     */\\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\\n        accrueInterest();\\n\\n        uint error = cTokenCollateral.accrueInterest();\\n        if (error != NO_ERROR) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\n        }\\n\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     */\\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal {\\n        /* Fail if liquidate not allowed */\\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\\n        if (allowed != 0) {\\n            revert LiquidateComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert LiquidateFreshnessCheck();\\n        }\\n\\n        /* Verify cTokenCollateral market's block number equals current block number */\\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\n            revert LiquidateCollateralFreshnessCheck();\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateLiquidatorIsBorrower();\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            revert LiquidateCloseAmountIsZero();\\n        }\\n\\n        /* Fail if repayAmount = -1 */\\n        if (repayAmount == type(uint).max) {\\n            revert LiquidateCloseAmountIsUintMax();\\n        }\\n\\n        /* Fail if repayBorrow fails */\\n        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\\n        require(amountSeizeError == NO_ERROR, \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\n        if (address(cTokenCollateral) == address(this)) {\\n            seizeInternal(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, \\\"token seizure failed\\\");\\n        }\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) {\\n        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     */\\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal {\\n        /* Fail if seize not allowed */\\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n        if (allowed != 0) {\\n            revert LiquidateSeizeComptrollerRejection(allowed);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        uint protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\\n        uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n        uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n        uint totalReservesNew = totalReserves + protocolSeizeAmount;\\n\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the calculated values into storage */\\n        totalReserves = totalReservesNew;\\n        totalSupply = totalSupply - protocolSeizeTokens;\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            revert SetPendingAdminOwnerCheck();\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() override external returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            revert AcceptAdminPendingAdminCheck();\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = payable(address(0));\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sets a new comptroller for the market\\n      * @dev Admin function to set a new comptroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetComptrollerOwnerCheck();\\n        }\\n\\n        ComptrollerInterface oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n      * @dev Admin function to set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetReserveFactorAdminCheck();\\n        }\\n\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert SetReserveFactorFreshCheck();\\n        }\\n\\n        // Check newReserveFactor \u2264 maxReserveFactor\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\n            revert SetReserveFactorBoundsCheck();\\n        }\\n\\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\n     * @param addAmount Amount of addition to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\\n        accrueInterest();\\n\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\n        _addReservesFresh(addAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\n     */\\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\\n        // totalReserves + actualAddAmount\\n        uint totalReservesNew;\\n        uint actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the caller and the addAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional addAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *  it returns the amount actually transferred, in case of a fee.\\n         */\\n\\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\\n\\n        totalReservesNew = totalReserves + actualAddAmount;\\n\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\n        totalReserves = totalReservesNew;\\n\\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        /* Return (NO_ERROR, actualAddAmount) */\\n        return (NO_ERROR, actualAddAmount);\\n    }\\n\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n        return _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to admin\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\n        // totalReserves - reduceAmount\\n        uint totalReservesNew;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert ReduceReservesAdminCheck();\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert ReduceReservesFreshCheck();\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (getCashPrior() < reduceAmount) {\\n            revert ReduceReservesCashNotAvailable();\\n        }\\n\\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            revert ReduceReservesCashValidation();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        doTransferOut(admin, reduceAmount);\\n\\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\\n        accrueInterest();\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n        return _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\\n\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModel oldInterestRateModel;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetInterestRateModelOwnerCheck();\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert SetInterestRateModelFreshCheck();\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Updates the addresses for the GLP contracts using _setStakedGlpAddresses\\n     * @dev Admin function to update the stakedGLP contract address\\n     * @param stakedGLP_ the stakedGLP contract to use\\n     * @param glpRewardRouter_ the rewardrouter contract address to use\\n     * @param glpManager_ the glpManager contract address to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setGlpAddresses(IStakedGlp stakedGLP_, IGmxRewardRouter glpRewardRouter_, address glpManager_) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetStakedGlpAddressOwnerCheck();\\n        }\\n        stakedGLP = stakedGLP_;\\n        glpRewardRouter = glpRewardRouter_;\\n        glpManager = glpManager_;\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Updates the fees for the vault strategy markets\\n     * @dev Admin function to update the fees\\n     * @param withdrawFee_ fee to withdraw funds\\n     * @param managementFee_ fee taken from autocompounded rewards\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setVaultFees(uint256 withdrawFee_, uint256 managementFee_) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetStakedGlpAddressOwnerCheck();\\n        }\\n\\n        withdrawFee = withdrawFee_;\\n        managementFee = managementFee_;\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfers all esGmx assets to the recipient\\n     * @dev Admin function to remove all esGmx assets from the contract\\n     * @param recipient the address to send all the assets to\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _signalTransfer(address recipient) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SignalTransferOwnerCheck();\\n        }\\n        if(getCashPrior() == 0){\\n            glpRewardRouter.signalTransfer(recipient);\\n        }\\n        return NO_ERROR;\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying owned by this contract\\n     */\\n    function getCashPrior() virtual internal view returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\n     *  This may revert due to insufficient balance or insufficient allowance.\\n     */\\n    function doTransferIn(address from, uint amount) virtual internal returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n     */\\n    function doTransferOut(address payable to, uint amount) virtual internal;\\n\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\n\\nabstract contract PriceOracle {\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\n    bool public constant isPriceOracle = true;\\n\\n    /**\\n      * @notice Get the underlying price of a cToken asset\\n      * @param cToken The cToken to get the underlying price of\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\n      *  Zero means the price is unavailable.\\n      */\\n    function getUnderlyingPrice(CToken cToken) virtual external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/ComptrollerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\n\\ncontract UnitrollerAdminStorage {\\n    /**\\n    * @notice Administrator for this contract\\n    */\\n    address public admin;\\n\\n    /**\\n    * @notice Pending administrator for this contract\\n    */\\n    address public pendingAdmin;\\n\\n    /**\\n    * @notice Active brains of Unitroller\\n    */\\n    address public comptrollerImplementation;\\n\\n    /**\\n    * @notice Pending brains of Unitroller\\n    */\\n    address public pendingComptrollerImplementation;\\n}\\n\\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    PriceOracle public oracle;\\n\\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint public closeFactorMantissa;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\\n     */\\n    uint public maxAssets;\\n\\n    /**\\n     * @notice Per-account mapping of \\\"assets you are in\\\", capped by maxAssets\\n     */\\n    mapping(address => CToken[]) public accountAssets;\\n\\n}\\n\\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\\n    struct Market {\\n        // Whether or not this market is listed\\n        bool isListed;\\n\\n        //  Multiplier representing the most one can borrow against their collateral in this market.\\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint collateralFactorMantissa;\\n\\n        //  Multiplier representing the threshold one can hold a borrow position against their collateral in this market.\\n        //  For instance, 0.95 to set the liqduidation threshold to borrowing 95% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint liquidationThresholdMantissa;\\n\\n        //  Multiplier representing the most one can borrow against their collateral in this market.\\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint collateralFactorMantissaVip;\\n\\n        //  Multiplier representing the threshold one can hold a borrow position against their collateral in this market.\\n        //  For instance, 0.95 to set the liqduidation threshold to borrowing 95% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint liquidationThresholdMantissaVip;\\n\\n        // Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address => bool) accountMembership;\\n\\n        // Whether or not this market receives COMP\\n        bool isComped;\\n\\n        bool isPrivate;\\n\\n        bool onlyWhitelistedBorrow;\\n    }\\n\\n    /**\\n     * @notice Official mapping of cTokens -> Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address => Market) public markets;\\n\\n\\n    /**\\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\n     *  Actions which allow users to remove their own assets cannot be paused.\\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n     */\\n    address public pauseGuardian;\\n    bool public _mintGuardianPaused;\\n    bool public _borrowGuardianPaused;\\n    bool public transferGuardianPaused;\\n    bool public seizeGuardianPaused;\\n    mapping(address => bool) public mintGuardianPaused;\\n    mapping(address => bool) public borrowGuardianPaused;\\n}\\n\\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\\n    struct CompMarketState {\\n        // The market's last updated compBorrowIndex or compSupplyIndex\\n        uint224 index;\\n\\n        // The block number the index was last updated at\\n        uint32 block;\\n    }\\n\\n    /// @notice A list of all markets\\n    CToken[] public allMarkets;\\n\\n    /// @notice The rate at which the flywheel distributes COMP, per block\\n    uint public compRate;\\n\\n    /// @notice The portion of compRate that each market currently receives\\n    mapping(address => uint) public compSpeeds;\\n\\n    /// @notice The COMP market supply state for each market\\n    mapping(address => CompMarketState) public compSupplyState;\\n\\n    /// @notice The COMP market borrow state for each market\\n    mapping(address => CompMarketState) public compBorrowState;\\n\\n    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\\n    mapping(address => mapping(address => uint)) public compSupplierIndex;\\n\\n    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\\n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\\n\\n    /// @notice The COMP accrued but not yet transferred to each user\\n    mapping(address => uint) public compAccrued;\\n\\n    /// @notice The users who are allowed to participate in private pools\\n    mapping(address => bool) public whitelistedUser;\\n\\n    /// @notice The address of the reward token\\n    address public compAddress;\\n\\n    /// @notice Can the reward token address be modified\\n    bool public immutableCompAddress;\\n}\\n\\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\\n    address public borrowCapGuardian;\\n\\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\\n    mapping(address => uint) public borrowCaps;\\n\\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\\n    mapping(address => uint) public supplyCaps;\\n}\\n\\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\\n    /// @notice The portion of COMP that each contributor receives per block\\n    mapping(address => uint) public compContributorSpeeds;\\n\\n    /// @notice Last block at which a contributor's COMP rewards have been allocated\\n    mapping(address => uint) public lastContributorBlock;\\n}\\n\\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\\n    /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)\\n    mapping(address => uint) public compBorrowSpeeds;\\n\\n    /// @notice The rate at which comp is distributed to the corresponding supply market (per block)\\n    mapping(address => uint) public compSupplySpeeds;\\n}\\n\\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\\n\\n    /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.\\n    mapping(address => uint) public compReceivable;\\n\\n    address public vipNft;\\n\\n    uint256 public tokenBalanceVipThreshold;\\n\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/Unitroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./ComptrollerStorage.sol\\\";\\n/**\\n * @title ComptrollerCore\\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\\n * CTokens should reference this contract as their comptroller.\\n */\\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\\n\\n    /**\\n      * @notice Emitted when pendingComptrollerImplementation is changed\\n      */\\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\\n      */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is changed\\n      */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n      */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() public {\\n        // Set admin to caller\\n        admin = msg.sender;\\n    }\\n\\n    /*** Admin Functions ***/\\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\\n\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\\n        }\\n\\n        address oldPendingImplementation = pendingComptrollerImplementation;\\n\\n        pendingComptrollerImplementation = newPendingImplementation;\\n\\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\\n    * @dev Admin function for new implementation to accept it's role as implementation\\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n    */\\n    function _acceptImplementation() public returns (uint) {\\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldImplementation = comptrollerImplementation;\\n        address oldPendingImplementation = pendingComptrollerImplementation;\\n\\n        comptrollerImplementation = pendingComptrollerImplementation;\\n\\n        pendingComptrollerImplementation = address(0);\\n\\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() public returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    fallback() payable external {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\\n\\n        assembly {\\n              let free_mem_ptr := mload(0x40)\\n              returndatacopy(free_mem_ptr, 0, returndatasize())\\n\\n              switch success\\n              case 0 { revert(free_mem_ptr, returndatasize()) }\\n              default { return(free_mem_ptr, returndatasize()) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/Comp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\ncontract Comp {\\n    /// @notice EIP-20 token name for this token\\n    string public constant name = \\\"Compound\\\";\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public constant symbol = \\\"COMP\\\";\\n\\n    /// @notice EIP-20 token decimals for this token\\n    uint8 public constant decimals = 18;\\n\\n    /// @notice Total number of tokens in circulation\\n    uint public constant totalSupply = 10000000e18; // 10 million Comp\\n\\n    /// @notice Allowance amounts on behalf of others\\n    mapping (address => mapping (address => uint96)) internal allowances;\\n\\n    /// @notice Official record of token balances for each account\\n    mapping (address => uint96) internal balances;\\n\\n    /// @notice A record of each accounts delegate\\n    mapping (address => address) public delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /// @notice The standard EIP-20 transfer event\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @notice The standard EIP-20 approval event\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Construct a new Comp token\\n     * @param account The initial account to grant all the tokens\\n     */\\n    constructor(address account) public {\\n        balances[account] = uint96(totalSupply);\\n        emit Transfer(address(0), account, totalSupply);\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\\n     * @param account The address of the account holding the funds\\n     * @param spender The address of the account spending the funds\\n     * @return The number of tokens approved\\n     */\\n    function allowance(address account, address spender) external view returns (uint) {\\n        return allowances[account][spender];\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint rawAmount) external returns (bool) {\\n        uint96 amount;\\n        if (rawAmount == type(uint).max) {\\n            amount = type(uint96).max;\\n        } else {\\n            amount = safe96(rawAmount, \\\"Comp::approve: amount exceeds 96 bits\\\");\\n        }\\n\\n        allowances[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens held by the `account`\\n     * @param account The address of the account to get the balance of\\n     * @return The number of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint) {\\n        return balances[account];\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint rawAmount) external returns (bool) {\\n        uint96 amount = safe96(rawAmount, \\\"Comp::transfer: amount exceeds 96 bits\\\");\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\\n        address spender = msg.sender;\\n        uint96 spenderAllowance = allowances[src][spender];\\n        uint96 amount = safe96(rawAmount, \\\"Comp::approve: amount exceeds 96 bits\\\");\\n\\n        if (spender != src && spenderAllowance != type(uint96).max) {\\n            uint96 newAllowance = sub96(spenderAllowance, amount, \\\"Comp::transferFrom: transfer amount exceeds spender allowance\\\");\\n            allowances[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) public {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"Comp::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"Comp::delegateBySig: invalid nonce\\\");\\n        require(block.timestamp <= expiry, \\\"Comp::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, \\\"Comp::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        address currentDelegate = delegates[delegator];\\n        uint96 delegatorBalance = balances[delegator];\\n        delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _transferTokens(address src, address dst, uint96 amount) internal {\\n        require(src != address(0), \\\"Comp::_transferTokens: cannot transfer from the zero address\\\");\\n        require(dst != address(0), \\\"Comp::_transferTokens: cannot transfer to the zero address\\\");\\n\\n        balances[src] = sub96(balances[src], amount, \\\"Comp::_transferTokens: transfer amount exceeds balance\\\");\\n        balances[dst] = add96(balances[dst], amount, \\\"Comp::_transferTokens: transfer amount overflows\\\");\\n        emit Transfer(src, dst, amount);\\n\\n        _moveDelegates(delegates[src], delegates[dst], amount);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"Comp::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"Comp::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"Comp::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[delegatee] = nCheckpoints + 1;\\n      }\\n\\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function getChainId() internal view returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Reservoir.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Reservoir Contract\\n * @notice Distributes a token to a different contract at a fixed rate.\\n * @dev This contract must be poked via the `drip()` function every so often.\\n * @author Compound\\n */\\ncontract Reservoir {\\n\\n  /// @notice The block number when the Reservoir started (immutable)\\n  uint public dripStart;\\n\\n  /// @notice Tokens per block that to drip to target (immutable)\\n  uint public dripRate;\\n\\n  /// @notice Reference to token to drip (immutable)\\n  EIP20Interface public token;\\n\\n  /// @notice Target to receive dripped tokens (immutable)\\n  address public target;\\n\\n  /// @notice Amount that has already been dripped\\n  uint public dripped;\\n\\n  /**\\n    * @notice Constructs a Reservoir\\n    * @param dripRate_ Numer of tokens per block to drip\\n    * @param token_ The token to drip\\n    * @param target_ The recipient of dripped tokens\\n    */\\n  constructor(uint dripRate_, EIP20Interface token_, address target_) public {\\n    dripStart = block.number;\\n    dripRate = dripRate_;\\n    token = token_;\\n    target = target_;\\n    dripped = 0;\\n  }\\n\\n  /**\\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\\n    * @dev Note: this will only drip up to the amount of tokens available.\\n    * @return The amount of tokens dripped in this call\\n    */\\n  function drip() public returns (uint) {\\n    // First, read storage into memory\\n    EIP20Interface token_ = token;\\n    uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\\n    uint dripRate_ = dripRate;\\n    uint dripStart_ = dripStart;\\n    uint dripped_ = dripped;\\n    address target_ = target;\\n    uint blockNumber_ = block.number;\\n\\n    // Next, calculate intermediate values\\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \\\"dripTotal overflow\\\");\\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \\\"deltaDrip underflow\\\");\\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\\n    uint drippedNext_ = add(dripped_, toDrip_, \\\"tautological\\\");\\n\\n    // Finally, write new `dripped` value and transfer tokens to target\\n    dripped = drippedNext_;\\n    token_.transfer(target_, toDrip_);\\n\\n    return toDrip_;\\n  }\\n\\n  /* Internal helper functions for safe math */\\n\\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n    uint c;\\n    unchecked { c = a + b; }\\n    require(c >= a, errorMessage);\\n    return c;\\n  }\\n\\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n    require(b <= a, errorMessage);\\n    uint c = a - b;\\n    return c;\\n  }\\n\\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint c;\\n    unchecked { c = a * b; }\\n    require(c / a == b, errorMessage);\\n    return c;\\n  }\\n\\n  function min(uint a, uint b) internal pure returns (uint) {\\n    if (a <= b) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  }\\n}\\n\\nimport \\\"./EIP20Interface.sol\\\";\\n\"\r\n    },\r\n    \"contracts/Lens/CompoundLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"../CErc20.sol\\\";\\nimport \\\"../CToken.sol\\\";\\nimport \\\"../PriceOracle.sol\\\";\\nimport \\\"../EIP20Interface.sol\\\";\\nimport \\\"../Governance/GovernorAlpha.sol\\\";\\nimport \\\"../Governance/Comp.sol\\\";\\n\\ninterface ComptrollerLensInterface {\\n    function markets(address) external view returns (bool, uint);\\n    function oracle() external view returns (PriceOracle);\\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\\n    function getAssetsIn(address) external view returns (CToken[] memory);\\n    function claimComp(address) external;\\n    function compAccrued(address) external view returns (uint);\\n    function compSpeeds(address) external view returns (uint);\\n    function compSupplySpeeds(address) external view returns (uint);\\n    function compBorrowSpeeds(address) external view returns (uint);\\n    function borrowCaps(address) external view returns (uint);\\n}\\n\\ninterface GovernorBravoInterface {\\n    struct Receipt {\\n        bool hasVoted;\\n        uint8 support;\\n        uint96 votes;\\n    }\\n    struct Proposal {\\n        uint id;\\n        address proposer;\\n        uint eta;\\n        uint startBlock;\\n        uint endBlock;\\n        uint forVotes;\\n        uint againstVotes;\\n        uint abstainVotes;\\n        bool canceled;\\n        bool executed;\\n    }\\n    function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas);\\n    function proposals(uint proposalId) external view returns (Proposal memory);\\n    function getReceipt(uint proposalId, address voter) external view returns (Receipt memory);\\n}\\n\\ncontract CompoundLens {\\n    struct CTokenMetadata {\\n        address cToken;\\n        uint exchangeRateCurrent;\\n        uint supplyRatePerBlock;\\n        uint borrowRatePerBlock;\\n        uint reserveFactorMantissa;\\n        uint totalBorrows;\\n        uint totalReserves;\\n        uint totalSupply;\\n        uint totalCash;\\n        bool isListed;\\n        uint collateralFactorMantissa;\\n        address underlyingAssetAddress;\\n        uint cTokenDecimals;\\n        uint underlyingDecimals;\\n        uint compSupplySpeed;\\n        uint compBorrowSpeed;\\n        uint borrowCap;\\n    }\\n\\n    function getCompSpeeds(ComptrollerLensInterface comptroller, CToken cToken) internal returns (uint, uint) {\\n        // Getting comp speeds is gnarly due to not every network having the\\n        // split comp speeds from Proposal 62 and other networks don't even\\n        // have comp speeds.\\n        uint compSupplySpeed = 0;\\n        (bool compSupplySpeedSuccess, bytes memory compSupplySpeedReturnData) =\\n            address(comptroller).call(\\n                abi.encodePacked(\\n                    comptroller.compSupplySpeeds.selector,\\n                    abi.encode(address(cToken))\\n                )\\n            );\\n        if (compSupplySpeedSuccess) {\\n            compSupplySpeed = abi.decode(compSupplySpeedReturnData, (uint));\\n        }\\n\\n        uint compBorrowSpeed = 0;\\n        (bool compBorrowSpeedSuccess, bytes memory compBorrowSpeedReturnData) =\\n            address(comptroller).call(\\n                abi.encodePacked(\\n                    comptroller.compBorrowSpeeds.selector,\\n                    abi.encode(address(cToken))\\n                )\\n            );\\n        if (compBorrowSpeedSuccess) {\\n            compBorrowSpeed = abi.decode(compBorrowSpeedReturnData, (uint));\\n        }\\n\\n        // If the split comp speeds call doesn't work, try the  oldest non-spit version.\\n        if (!compSupplySpeedSuccess || !compBorrowSpeedSuccess) {\\n            (bool compSpeedSuccess, bytes memory compSpeedReturnData) =\\n            address(comptroller).call(\\n                abi.encodePacked(\\n                    comptroller.compSpeeds.selector,\\n                    abi.encode(address(cToken))\\n                )\\n            );\\n            if (compSpeedSuccess) {\\n                compSupplySpeed = compBorrowSpeed = abi.decode(compSpeedReturnData, (uint));\\n            }\\n        }\\n        return (compSupplySpeed, compBorrowSpeed);\\n    }\\n\\n    function cTokenMetadata(CToken cToken) public returns (CTokenMetadata memory) {\\n        uint exchangeRateCurrent = cToken.exchangeRateCurrent();\\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\\n        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(cToken));\\n        address underlyingAssetAddress;\\n        uint underlyingDecimals;\\n\\n        if (compareStrings(cToken.symbol(), \\\"cETH\\\")) {\\n            underlyingAssetAddress = address(0);\\n            underlyingDecimals = 18;\\n        } else {\\n            CErc20 cErc20 = CErc20(address(cToken));\\n            underlyingAssetAddress = cErc20.underlying();\\n            underlyingDecimals = EIP20Interface(cErc20.underlying()).decimals();\\n        }\\n\\n        (uint compSupplySpeed, uint compBorrowSpeed) = getCompSpeeds(comptroller, cToken);\\n\\n        uint borrowCap = 0;\\n        (bool borrowCapSuccess, bytes memory borrowCapReturnData) =\\n            address(comptroller).call(\\n                abi.encodePacked(\\n                    comptroller.borrowCaps.selector,\\n                    abi.encode(address(cToken))\\n                )\\n            );\\n        if (borrowCapSuccess) {\\n            borrowCap = abi.decode(borrowCapReturnData, (uint));\\n        }\\n\\n        return CTokenMetadata({\\n            cToken: address(cToken),\\n            exchangeRateCurrent: exchangeRateCurrent,\\n            supplyRatePerBlock: cToken.supplyRatePerBlock(),\\n            borrowRatePerBlock: cToken.borrowRatePerBlock(),\\n            reserveFactorMantissa: cToken.reserveFactorMantissa(),\\n            totalBorrows: cToken.totalBorrows(),\\n            totalReserves: cToken.totalReserves(),\\n            totalSupply: cToken.totalSupply(),\\n            totalCash: cToken.getCash(),\\n            isListed: isListed,\\n            collateralFactorMantissa: collateralFactorMantissa,\\n            underlyingAssetAddress: underlyingAssetAddress,\\n            cTokenDecimals: cToken.decimals(),\\n            underlyingDecimals: underlyingDecimals,\\n            compSupplySpeed: compSupplySpeed,\\n            compBorrowSpeed: compBorrowSpeed,\\n            borrowCap: borrowCap\\n        });\\n    }\\n\\n    function cTokenMetadataAll(CToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\\n        uint cTokenCount = cTokens.length;\\n        CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\\n        for (uint i = 0; i < cTokenCount; i++) {\\n            res[i] = cTokenMetadata(cTokens[i]);\\n        }\\n        return res;\\n    }\\n\\n    struct CTokenBalances {\\n        address cToken;\\n        uint balanceOf;\\n        uint borrowBalanceCurrent;\\n        uint balanceOfUnderlying;\\n        uint tokenBalance;\\n        uint tokenAllowance;\\n    }\\n\\n    function cTokenBalances(CToken cToken, address payable account) public returns (CTokenBalances memory) {\\n        uint balanceOf = cToken.balanceOf(account);\\n        uint borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\\n        uint balanceOfUnderlying = cToken.balanceOfUnderlying(account);\\n        uint tokenBalance;\\n        uint tokenAllowance;\\n\\n        if (compareStrings(cToken.symbol(), \\\"cETH\\\")) {\\n            tokenBalance = account.balance;\\n            tokenAllowance = account.balance;\\n        } else {\\n            CErc20 cErc20 = CErc20(address(cToken));\\n            EIP20Interface underlying = EIP20Interface(cErc20.underlying());\\n            tokenBalance = underlying.balanceOf(account);\\n            tokenAllowance = underlying.allowance(account, address(cToken));\\n        }\\n\\n        return CTokenBalances({\\n            cToken: address(cToken),\\n            balanceOf: balanceOf,\\n            borrowBalanceCurrent: borrowBalanceCurrent,\\n            balanceOfUnderlying: balanceOfUnderlying,\\n            tokenBalance: tokenBalance,\\n            tokenAllowance: tokenAllowance\\n        });\\n    }\\n\\n    function cTokenBalancesAll(CToken[] calldata cTokens, address payable account) external returns (CTokenBalances[] memory) {\\n        uint cTokenCount = cTokens.length;\\n        CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\\n        for (uint i = 0; i < cTokenCount; i++) {\\n            res[i] = cTokenBalances(cTokens[i], account);\\n        }\\n        return res;\\n    }\\n\\n    struct CTokenUnderlyingPrice {\\n        address cToken;\\n        uint underlyingPrice;\\n    }\\n\\n    function cTokenUnderlyingPrice(CToken cToken) public returns (CTokenUnderlyingPrice memory) {\\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\\n        PriceOracle priceOracle = comptroller.oracle();\\n\\n        return CTokenUnderlyingPrice({\\n            cToken: address(cToken),\\n            underlyingPrice: priceOracle.getUnderlyingPrice(cToken)\\n        });\\n    }\\n\\n    function cTokenUnderlyingPriceAll(CToken[] calldata cTokens) external returns (CTokenUnderlyingPrice[] memory) {\\n        uint cTokenCount = cTokens.length;\\n        CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\\n        for (uint i = 0; i < cTokenCount; i++) {\\n            res[i] = cTokenUnderlyingPrice(cTokens[i]);\\n        }\\n        return res;\\n    }\\n\\n    struct AccountLimits {\\n        CToken[] markets;\\n        uint liquidity;\\n        uint shortfall;\\n    }\\n\\n    function getAccountLimits(ComptrollerLensInterface comptroller, address account) public returns (AccountLimits memory) {\\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\\n        require(errorCode == 0);\\n\\n        return AccountLimits({\\n            markets: comptroller.getAssetsIn(account),\\n            liquidity: liquidity,\\n            shortfall: shortfall\\n        });\\n    }\\n\\n    struct GovReceipt {\\n        uint proposalId;\\n        bool hasVoted;\\n        bool support;\\n        uint96 votes;\\n    }\\n\\n    function getGovReceipts(GovernorAlpha governor, address voter, uint[] memory proposalIds) public view returns (GovReceipt[] memory) {\\n        uint proposalCount = proposalIds.length;\\n        GovReceipt[] memory res = new GovReceipt[](proposalCount);\\n        for (uint i = 0; i < proposalCount; i++) {\\n            GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\\n            res[i] = GovReceipt({\\n                proposalId: proposalIds[i],\\n                hasVoted: receipt.hasVoted,\\n                support: receipt.support,\\n                votes: receipt.votes\\n            });\\n        }\\n        return res;\\n    }\\n\\n    struct GovBravoReceipt {\\n        uint proposalId;\\n        bool hasVoted;\\n        uint8 support;\\n        uint96 votes;\\n    }\\n\\n    function getGovBravoReceipts(GovernorBravoInterface governor, address voter, uint[] memory proposalIds) public view returns (GovBravoReceipt[] memory) {\\n        uint proposalCount = proposalIds.length;\\n        GovBravoReceipt[] memory res = new GovBravoReceipt[](proposalCount);\\n        for (uint i = 0; i < proposalCount; i++) {\\n            GovernorBravoInterface.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\\n            res[i] = GovBravoReceipt({\\n                proposalId: proposalIds[i],\\n                hasVoted: receipt.hasVoted,\\n                support: receipt.support,\\n                votes: receipt.votes\\n            });\\n        }\\n        return res;\\n    }\\n\\n    struct GovProposal {\\n        uint proposalId;\\n        address proposer;\\n        uint eta;\\n        address[] targets;\\n        uint[] values;\\n        string[] signatures;\\n        bytes[] calldatas;\\n        uint startBlock;\\n        uint endBlock;\\n        uint forVotes;\\n        uint againstVotes;\\n        bool canceled;\\n        bool executed;\\n    }\\n\\n    function setProposal(GovProposal memory res, GovernorAlpha governor, uint proposalId) internal view {\\n        (\\n            ,\\n            address proposer,\\n            uint eta,\\n            uint startBlock,\\n            uint endBlock,\\n            uint forVotes,\\n            uint againstVotes,\\n            bool canceled,\\n            bool executed\\n        ) = governor.proposals(proposalId);\\n        res.proposalId = proposalId;\\n        res.proposer = proposer;\\n        res.eta = eta;\\n        res.startBlock = startBlock;\\n        res.endBlock = endBlock;\\n        res.forVotes = forVotes;\\n        res.againstVotes = againstVotes;\\n        res.canceled = canceled;\\n        res.executed = executed;\\n    }\\n\\n    function getGovProposals(GovernorAlpha governor, uint[] calldata proposalIds) external view returns (GovProposal[] memory) {\\n        GovProposal[] memory res = new GovProposal[](proposalIds.length);\\n        for (uint i = 0; i < proposalIds.length; i++) {\\n            (\\n                address[] memory targets,\\n                uint[] memory values,\\n                string[] memory signatures,\\n                bytes[] memory calldatas\\n            ) = governor.getActions(proposalIds[i]);\\n            res[i] = GovProposal({\\n                proposalId: 0,\\n                proposer: address(0),\\n                eta: 0,\\n                targets: targets,\\n                values: values,\\n                signatures: signatures,\\n                calldatas: calldatas,\\n                startBlock: 0,\\n                endBlock: 0,\\n                forVotes: 0,\\n                againstVotes: 0,\\n                canceled: false,\\n                executed: false\\n            });\\n            setProposal(res[i], governor, proposalIds[i]);\\n        }\\n        return res;\\n    }\\n\\n    struct GovBravoProposal {\\n        uint proposalId;\\n        address proposer;\\n        uint eta;\\n        address[] targets;\\n        uint[] values;\\n        string[] signatures;\\n        bytes[] calldatas;\\n        uint startBlock;\\n        uint endBlock;\\n        uint forVotes;\\n        uint againstVotes;\\n        uint abstainVotes;\\n        bool canceled;\\n        bool executed;\\n    }\\n\\n    function setBravoProposal(GovBravoProposal memory res, GovernorBravoInterface governor, uint proposalId) internal view {\\n        GovernorBravoInterface.Proposal memory p = governor.proposals(proposalId);\\n\\n        res.proposalId = proposalId;\\n        res.proposer = p.proposer;\\n        res.eta = p.eta;\\n        res.startBlock = p.startBlock;\\n        res.endBlock = p.endBlock;\\n        res.forVotes = p.forVotes;\\n        res.againstVotes = p.againstVotes;\\n        res.abstainVotes = p.abstainVotes;\\n        res.canceled = p.canceled;\\n        res.executed = p.executed;\\n    }\\n\\n    function getGovBravoProposals(GovernorBravoInterface governor, uint[] calldata proposalIds) external view returns (GovBravoProposal[] memory) {\\n        GovBravoProposal[] memory res = new GovBravoProposal[](proposalIds.length);\\n        for (uint i = 0; i < proposalIds.length; i++) {\\n            (\\n                address[] memory targets,\\n                uint[] memory values,\\n                string[] memory signatures,\\n                bytes[] memory calldatas\\n            ) = governor.getActions(proposalIds[i]);\\n            res[i] = GovBravoProposal({\\n                proposalId: 0,\\n                proposer: address(0),\\n                eta: 0,\\n                targets: targets,\\n                values: values,\\n                signatures: signatures,\\n                calldatas: calldatas,\\n                startBlock: 0,\\n                endBlock: 0,\\n                forVotes: 0,\\n                againstVotes: 0,\\n                abstainVotes: 0,\\n                canceled: false,\\n                executed: false\\n            });\\n            setBravoProposal(res[i], governor, proposalIds[i]);\\n        }\\n        return res;\\n    }\\n\\n    struct CompBalanceMetadata {\\n        uint balance;\\n        uint votes;\\n        address delegate;\\n    }\\n\\n    function getCompBalanceMetadata(Comp comp, address account) external view returns (CompBalanceMetadata memory) {\\n        return CompBalanceMetadata({\\n            balance: comp.balanceOf(account),\\n            votes: uint256(comp.getCurrentVotes(account)),\\n            delegate: comp.delegates(account)\\n        });\\n    }\\n\\n    struct CompBalanceMetadataExt {\\n        uint balance;\\n        uint votes;\\n        address delegate;\\n        uint allocated;\\n    }\\n\\n    function getCompBalanceMetadataExt(Comp comp, ComptrollerLensInterface comptroller, address account) external returns (CompBalanceMetadataExt memory) {\\n        uint balance = comp.balanceOf(account);\\n        comptroller.claimComp(account);\\n        uint newBalance = comp.balanceOf(account);\\n        uint accrued = comptroller.compAccrued(account);\\n        uint total = add(accrued, newBalance, \\\"sum comp total\\\");\\n        uint allocated = sub(total, balance, \\\"sub allocated\\\");\\n\\n        return CompBalanceMetadataExt({\\n            balance: balance,\\n            votes: uint256(comp.getCurrentVotes(account)),\\n            delegate: comp.delegates(account),\\n            allocated: allocated\\n        });\\n    }\\n\\n    struct CompVotes {\\n        uint blockNumber;\\n        uint votes;\\n    }\\n\\n    function getCompVotes(Comp comp, address account, uint32[] calldata blockNumbers) external view returns (CompVotes[] memory) {\\n        CompVotes[] memory res = new CompVotes[](blockNumbers.length);\\n        for (uint i = 0; i < blockNumbers.length; i++) {\\n            res[i] = CompVotes({\\n                blockNumber: uint256(blockNumbers[i]),\\n                votes: uint256(comp.getPriorVotes(account, blockNumbers[i]))\\n            });\\n        }\\n        return res;\\n    }\\n\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n\\n    function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n        require(b <= a, errorMessage);\\n        uint c = a - b;\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface CompLike {\\n    function delegate(address delegatee) external;\\n}\\n\\n/**\\n * @title Compound's CErc20 Contract\\n * @notice CTokens which wrap an EIP-20 underlying\\n * @author Compound\\n */\\ncontract CErc20 is CToken, CErc20Interface {\\n    /**\\n     * @notice Initialize the new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param isGLP_ Wether or not the market being created is for the GLP token\\n     */\\n    function initialize(address underlying_,\\n                        ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_,\\n                        bool isGLP_) public {\\n        // CToken initialize does the bulk of the work\\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, isGLP_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        EIP20Interface(underlying).totalSupply();\\n    }\\n\\n    function tinit(address underlying_,\\n                        ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_,\\n                        bool isGLP_) public {\\n        require(admin == address(0), \\\"admin may only be set once\\\");\\n        admin = payable(msg.sender);\\n        // CToken initialize does the bulk of the work\\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, isGLP_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        EIP20Interface(underlying).totalSupply();\\n    }\\n    \\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) override external returns (uint) {\\n        mintInternal(mintAmount);\\n        comptroller.addToMarketExternal(address(this), msg.sender);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) override external returns (uint) {\\n        redeemInternal(redeemTokens);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\\n        redeemUnderlyingInternal(redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) override external returns (uint) {\\n        borrowInternal(borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) override external returns (uint) {\\n        repayBorrowInternal(repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\\n        repayBorrowBehalfInternal(borrower, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\\n        liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(EIP20NonStandardInterface token) override external {\\n        require(msg.sender == admin, \\\"CErc20::sweepToken: only admin can sweep tokens\\\");\\n        require(address(token) != underlying, \\\"CErc20::sweepToken: can not sweep underlying token\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        token.transfer(admin, balance);\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n        \\n    function depositNFT(address _NFTAddress, uint256 _TokenID) override external {\\n        IERC721(_NFTAddress).safeTransferFrom(msg.sender, address(this), _TokenID);\\n    }\\n\\n    function withdrawNFT(address _NFTAddress, uint256 _TokenID) override external {\\n        IERC721(_NFTAddress).safeTransferFrom(address(this), admin, _TokenID);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount fo underlying token to add as reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) override external returns (uint) {\\n        return _addReservesInternal(addAmount);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function getCashPrior() virtual override internal view returns (uint) {\\n        EIP20Interface token = EIP20Interface(underlying);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n     *      This will revert due to insufficient balance or insufficient allowance.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferIn(address from, uint amount) virtual override internal returns (uint) {\\n        // Read from storage once\\n        address underlying_ = underlying;\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\\n        uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\\n        if(isGLP){\\n            stakedGLP.transferFrom(from, address(this), amount);\\n        } else {\\n            token.transferFrom(from, address(this), amount);\\n\\n            bool success;\\n            assembly {\\n                switch returndatasize()\\n                    case 0 {                       // This is a non-standard ERC-20\\n                        success := not(0)          // set success to true\\n                    }\\n                    case 32 {                      // This is a compliant ERC-20\\n                        returndatacopy(0, 0, 32)\\n                        success := mload(0)        // Set `success = returndata` of override external call\\n                    }\\n                    default {                      // This is an excessively non-compliant ERC-20, revert.\\n                        revert(0, 0)\\n                    }\\n            }\\n            require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n        }\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n     *      it is >= amount, this should not revert in normal conditions.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferOut(address payable to, uint amount) virtual override internal {\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\\n        if(isGLP){\\n            stakedGLP.transfer(to, amount);\\n        } else {\\n            token.transfer(to, amount);\\n\\n            bool success;\\n            assembly {\\n                switch returndatasize()\\n                    case 0 {                      // This is a non-standard ERC-20\\n                        success := not(0)          // set success to true\\n                    }\\n                    case 32 {                     // This is a compliant ERC-20\\n                        returndatacopy(0, 0, 32)\\n                        success := mload(0)        // Set `success = returndata` of override external call\\n                    }\\n                    default {                     // This is an excessively non-compliant ERC-20, revert.\\n                        revert(0, 0)\\n                    }\\n            }\\n            require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n        }\\n        \\n    }\\n\\n    /**\\n    * @notice Admin call to delegate the votes of the COMP-like underlying\\n    * @param compLikeDelegatee The address to delegate votes to\\n    * @dev CTokens whose underlying are not CompLike should revert here\\n    */\\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\\n        require(msg.sender == admin, \\\"only the admin may set the comp-like delegate\\\");\\n        CompLike(underlying).delegate(compLikeDelegatee);\\n    }\\n}\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/GovernorAlpha.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\ncontract GovernorAlpha {\\n    /// @notice The name of this contract\\n    string public constant name = \\\"Compound Governor Alpha\\\";\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    function quorumVotes() public pure returns (uint) { return 400000e18; } // 400,000 = 4% of Comp\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    function proposalThreshold() public pure returns (uint) { return 100000e18; } // 100,000 = 1% of Comp\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    function votingPeriod() virtual public pure returns (uint) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\\n\\n    /// @notice The address of the Compound Protocol Timelock\\n    TimelockInterface public timelock;\\n\\n    /// @notice The address of the Compound governance token\\n    CompInterface public comp;\\n\\n    /// @notice The address of the Governor Guardian\\n    address public guardian;\\n\\n    /// @notice The total number of proposals\\n    uint public proposalCount;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint id;\\n\\n        /// @notice Creator of the proposal\\n        address proposer;\\n\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint eta;\\n\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint[] values;\\n\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint startBlock;\\n\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint endBlock;\\n\\n        /// @notice Current number of votes in favor of this proposal\\n        uint forVotes;\\n\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint againstVotes;\\n\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping (address => Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        /// @notice Whether or not the voter supports the proposal\\n        bool support;\\n\\n        /// @notice The number of votes the voter had, which were cast\\n        uint96 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping (uint => Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping (address => uint) public latestProposalIds;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint id, uint eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint id);\\n\\n    constructor(address timelock_, address comp_, address guardian_) public {\\n        timelock = TimelockInterface(timelock_);\\n        comp = CompInterface(comp_);\\n        guardian = guardian_;\\n    }\\n\\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\");\\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"GovernorAlpha::propose: must provide actions\\\");\\n        require(targets.length <= proposalMaxOperations(), \\\"GovernorAlpha::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = add256(block.number, votingDelay());\\n        uint endBlock = add256(startBlock, votingPeriod());\\n\\n        proposalCount++;\\n        uint proposalId = proposalCount;\\n        Proposal storage newProposal = proposals[proposalId];\\n        // This should never happen but add a check in case.\\n        require(newProposal.id == 0, \\\"GovernorAlpha::propose: ProposalID collsion\\\");\\n        newProposal.id = proposalId;\\n        newProposal.proposer = msg.sender;\\n        newProposal.eta = 0;\\n        newProposal.targets = targets;\\n        newProposal.values = values;\\n        newProposal.signatures = signatures;\\n        newProposal.calldatas = calldatas;\\n        newProposal.startBlock = startBlock;\\n        newProposal.endBlock = endBlock;\\n        newProposal.forVotes = 0;\\n        newProposal.againstVotes = 0;\\n        newProposal.canceled = false;\\n        newProposal.executed = false;\\n\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    function queue(uint proposalId) public {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint eta = add256(block.timestamp, timelock.delay());\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\");\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    function execute(uint proposalId) public payable {\\n        require(state(proposalId) == ProposalState.Queued, \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.executeTransaction{value: proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    function cancel(uint proposalId) public {\\n        ProposalState state = state(proposalId);\\n        require(state != ProposalState.Executed, \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \\\"GovernorAlpha::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    function state(uint proposalId) public view returns (ProposalState) {\\n        require(proposalCount >= proposalId && proposalId > 0, \\\"GovernorAlpha::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number <= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    function castVote(uint proposalId, bool support) public {\\n        return _castVote(msg.sender, proposalId, support);\\n    }\\n\\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"GovernorAlpha::castVoteBySig: invalid signature\\\");\\n        return _castVote(signatory, proposalId, support);\\n    }\\n\\n    function _castVote(address voter, uint proposalId, bool support) internal {\\n        require(state(proposalId) == ProposalState.Active, \\\"GovernorAlpha::_castVote: voting is closed\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"GovernorAlpha::_castVote: voter already voted\\\");\\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support) {\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\n        } else {\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(voter, proposalId, support, votes);\\n    }\\n\\n    function __acceptAdmin() public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__acceptAdmin: sender must be gov guardian\\\");\\n        timelock.acceptAdmin();\\n    }\\n\\n    function __abdicate() public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__abdicate: sender must be gov guardian\\\");\\n        guardian = address(0);\\n    }\\n\\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function getChainId() internal view returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\\ninterface TimelockInterface {\\n    function delay() external view returns (uint);\\n    function GRACE_PERIOD() external view returns (uint);\\n    function acceptAdmin() external;\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\\n}\\n\\ninterface CompInterface {\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\\n}\\n\"\r\n    },\r\n    \"contracts/MockPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"./CToken.sol\\\";\\n\\npragma solidity ^0.8.10;\\n\\ncontract MockPriceOracle {\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\n    bool public constant isPriceOracle = true;\\n    uint value;\\n\\n    mapping(address => uint) public prices;\\n\\n    // this is a stub for the price oracle interface\\n    function updatePrice(CToken cToken) external {\\n\\n    }\\n    \\n    /**\\n      * @notice Update the price of an underlying asset\\n      * @param cToken The cToken to update the underlying price of\\n      */\\n    function mockUpdatePrice(address cToken, uint price) external{\\n      prices[cToken] = price;\\n    }\\n\\n    /**\\n      * @notice Get the underlying price of a cToken asset\\n      * @param cToken The cToken to get the underlying price of\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\n      *  Zero means the price is unavailable.\\n      */\\n    function getUnderlyingPrice(address cToken) external view returns (uint){\\n      return prices[cToken];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CErc20DelegatorGmx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CTokenInterfaces.sol\\\";\\nimport \\\"./IGmxRewardRouter.sol\\\";\\nimport \\\"./IStakedGlp.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\n\\n/**\\n * @title Compound's CErc20Delegator Contract\\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\\n * @author Compound\\n */\\ncontract CErc20DelegatorGmx is CTokenInterface, CErc20Interface, CDelegatorInterface {\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param implementation_ The address of the implementation the contract delegates to\\n     * @param becomeImplementationData The encoded args for becomeImplementatioN  \\n     */\\n    constructor(address underlying_,\\n                ComptrollerInterface comptroller_,\\n                InterestRateModel interestRateModel_,\\n                uint initialExchangeRateMantissa_,\\n                string memory name_,\\n                string memory symbol_,\\n                uint8 decimals_,\\n                address payable admin_,\\n                address implementation_,\\n                bytes memory becomeImplementationData) {\\n        // Creator of the contract is admin during initialization\\n        admin = payable(msg.sender);\\n\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,address,uint256,string,string,uint8,bool)\\\",\\n                                                            underlying_,\\n                                                            comptroller_,\\n                                                            interestRateModel_,\\n                                                            initialExchangeRateMantissa_,\\n                                                            name_,\\n                                                            symbol_,\\n                                                            decimals_\\n                                                            ));\\n\\n        // // New implementations always get set via the settor (post-initialize)\\n        _setImplementation(implementation_, false, becomeImplementationData);\\n\\n        // Set the proper admin now that initialization is done\\n        admin = admin_;\\n    }\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData)override public {\\n        require(msg.sender == admin, \\\"CErc20Delegator::_setImplementation: Caller must be admin\\\");\\n\\n        if (allowResign) {\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\n        }\\n\\n        address oldImplementation = implementation;\\n        implementation = implementation_;\\n\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\n\\n        emit NewImplementation(oldImplementation, implementation);\\n    }\\n\\n    function proxyType() public pure returns (uint256 proxyTypeId) {\\n        return 2;\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"mint(uint256)\\\", mintAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"redeem(uint256)\\\", redeemTokens));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"redeemUnderlying(uint256)\\\", redeemAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"borrow(uint256)\\\", borrowAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"repayBorrow(uint256)\\\", repayAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"repayBorrowBehalf(address,uint256)\\\", borrower, repayAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"liquidateBorrow(address,uint256,address)\\\", borrower, repayAmount, cTokenCollateral));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint amount) override external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", dst, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) override external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", src, dst, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) override external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"approve(address,uint256)\\\", spender, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"allowance(address,address)\\\", owner, spender));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"balanceOf(address)\\\", owner));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"balanceOfUnderlying(address)\\\", owner));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"getAccountSnapshot(address)\\\", account));\\n        return abi.decode(data, (uint, uint, uint, uint));\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"borrowRatePerBlock()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"supplyRatePerBlock()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"totalBorrowsCurrent()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"borrowBalanceCurrent(address)\\\", account));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) override public view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"borrowBalanceStored(address)\\\", account));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"exchangeRateCurrent()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() override public view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"exchangeRateStored()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this cToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"getCash()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Applies accrued interest to total borrows and reserves.\\n      * @dev This calculates interest accrued from the last checkpointed block\\n      *      up to the current block and writes new checkpoint to storage.\\n      */\\n    function accrueInterest() override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"accrueInterest()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"seize(address,address,uint256)\\\", liquidator, borrower, seizeTokens));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(EIP20NonStandardInterface token) override external {\\n        delegateToImplementation(abi.encodeWithSignature(\\\"sweepToken(address)\\\", token));\\n    }\\n        \\n    function depositNFT(address _NFTAddress, uint256 _TokenID) override external {\\n         delegateToImplementation(abi.encodeWithSignature(\\\"depositNFT(address,uint256)\\\", _NFTAddress, _TokenID));\\n    }\\n\\n    function withdrawNFT(address _NFTAddress, uint256 _TokenID) override external {\\n        delegateToImplementation(abi.encodeWithSignature(\\\"withdrawNFT(address,uint256)\\\", _NFTAddress, _TokenID));\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setPendingAdmin(address)\\\", newPendingAdmin));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Sets a new comptroller for the market\\n      * @dev Admin function to set a new comptroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setComptroller(address)\\\", newComptroller));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setReserveFactor(uint256)\\\", newReserveFactorMantissa));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_acceptAdmin()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrues interest and adds reserves by transferring from admin\\n     * @param addAmount Amount of reserves to add\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_addReserves(uint256)\\\", addAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_reduceReserves(uint256)\\\", reduceAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setInterestRateModel(address)\\\", newInterestRateModel));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Updates the glp contract addresses using _setGlpAddresses\\n     * @dev Admin function to set the GLP contract addresses\\n     * @param stakedGLP_ the stakedGLP contract to use\\n     * @param glpRewardRouter_ the rewardrouter contract address to use\\n     * @param glpManager_ the glpManager contract address to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setGlpAddresses(IStakedGlp stakedGLP_, IGmxRewardRouter glpRewardRouter_, address glpManager_) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setGlpAddresses(address,address,address)\\\", stakedGLP_, glpRewardRouter_, glpManager_));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Updates the fees for the vault strategy markets\\n     * @dev Admin function to update the fees\\n     * @param withdrawFee_ fee to withdraw funds\\n     * @param managementFee_ fee taken from autocompounded rewards\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setVaultFees(uint256 withdrawFee_, uint256 managementFee_) override public returns (uint){\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setVaultFees(uint256,uint256)\\\", withdrawFee_, managementFee_));\\n        return abi.decode(data, (uint));\\n    }\\n\\n\\n    /**\\n     * @notice Transfers all esGmx assets to the recipient\\n     * @dev Admin function to remove all esGmx assets from the contract\\n     * @param recipient the address to send all the assets to\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _signalTransfer(address recipient) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_signalTransfer(address)\\\", recipient));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Toggle wether or not the GLP rewards should be autocompounded\\n     * @dev Admin function to set wether or not GLP rewards should be autocompounded\\n     * @param autocompound_ should the rewards be autocompounded or not\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setAutocompoundRewards(bool autocompound_) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setAutocompoundRewards(bool)\\\", autocompound_));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Internal method to delegate execution to another contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param callee The contract to delegatecall\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return returnData;\\n    }\\n\\n    /**\\n     * @notice Delegates execution to the implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\n        return delegateTo(implementation, data);\\n    }\\n\\n    /**\\n     * @notice Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", data));\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return abi.decode(returnData, (bytes));\\n    }\\n\\n    /**\\n     * @notice Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     */\\n    fallback() external payable {\\n        require(msg.value == 0,\\\"CErc20Delegator:fallback: cannot send value to fallback\\\");\\n\\n        // delegate all other functions to current implementation\\n        (bool success, ) = implementation.delegatecall(msg.data);\\n\\n        assembly {\\n            let free_mem_ptr := mload(0x40)\\n            returndatacopy(free_mem_ptr, 0, returndatasize())\\n\\n            switch success\\n            case 0 { revert(free_mem_ptr, returndatasize()) }\\n            default { return(free_mem_ptr, returndatasize()) }\\n        }\\n    }\\n\\n    function approveGlpRewardRouterWETHSpending() external {\\n        require(msg.sender == admin, \\\"only admin can call approve\\\");\\n        EIP20Interface(WETH).approve(glpManager, type(uint256).max);\\n    }\\n\\n}\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\"\r\n    },\r\n    \"contracts/CErc20Delegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CTokenInterfaces.sol\\\";\\nimport \\\"./IGmxRewardRouter.sol\\\";\\nimport \\\"./IStakedGlp.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\n\\n/**\\n * @title Compound's CErc20Delegator Contract\\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\\n * @author Compound\\n */\\ncontract CErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface {\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param isGLP_ Wether or not the market being created is for the GLP token\\n     * @param admin_ Address of the administrator of this token\\n     * @param implementation_ The address of the implementation the contract delegates to\\n     * @param becomeImplementationData The encoded args for becomeImplementatioN  \\n     */\\n    constructor(address underlying_,\\n                ComptrollerInterface comptroller_,\\n                InterestRateModel interestRateModel_,\\n                uint initialExchangeRateMantissa_,\\n                string memory name_,\\n                string memory symbol_,\\n                uint8 decimals_,\\n                bool isGLP_,\\n                address payable admin_,\\n                address implementation_,\\n                bytes memory becomeImplementationData) {\\n        // Creator of the contract is admin during initialization\\n        admin = payable(msg.sender);\\n\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,address,uint256,string,string,uint8,bool)\\\",\\n                                                            underlying_,\\n                                                            comptroller_,\\n                                                            interestRateModel_,\\n                                                            initialExchangeRateMantissa_,\\n                                                            name_,\\n                                                            symbol_,\\n                                                            decimals_,\\n                                                            isGLP_));\\n\\n        // // New implementations always get set via the settor (post-initialize)\\n        _setImplementation(implementation_, false, becomeImplementationData);\\n\\n        // Set the proper admin now that initialization is done\\n        admin = admin_;\\n    }\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData)override public {\\n        require(msg.sender == admin, \\\"CErc20Delegator::_setImplementation: Caller must be admin\\\");\\n\\n        if (allowResign) {\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\n        }\\n\\n        address oldImplementation = implementation;\\n        implementation = implementation_;\\n\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\n\\n        emit NewImplementation(oldImplementation, implementation);\\n    }\\n\\n    function proxyType() public pure returns (uint256 proxyTypeId) {\\n        return 2;\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"mint(uint256)\\\", mintAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"redeem(uint256)\\\", redeemTokens));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"redeemUnderlying(uint256)\\\", redeemAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"borrow(uint256)\\\", borrowAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"repayBorrow(uint256)\\\", repayAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"repayBorrowBehalf(address,uint256)\\\", borrower, repayAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"liquidateBorrow(address,uint256,address)\\\", borrower, repayAmount, cTokenCollateral));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint amount) override external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", dst, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) override external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", src, dst, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) override external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"approve(address,uint256)\\\", spender, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"allowance(address,address)\\\", owner, spender));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"balanceOf(address)\\\", owner));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"balanceOfUnderlying(address)\\\", owner));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"getAccountSnapshot(address)\\\", account));\\n        return abi.decode(data, (uint, uint, uint, uint));\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"borrowRatePerBlock()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"supplyRatePerBlock()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"totalBorrowsCurrent()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"borrowBalanceCurrent(address)\\\", account));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) override public view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"borrowBalanceStored(address)\\\", account));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"exchangeRateCurrent()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() override public view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"exchangeRateStored()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this cToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() override external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"getCash()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Applies accrued interest to total borrows and reserves.\\n      * @dev This calculates interest accrued from the last checkpointed block\\n      *      up to the current block and writes new checkpoint to storage.\\n      */\\n    function accrueInterest() override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"accrueInterest()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"seize(address,address,uint256)\\\", liquidator, borrower, seizeTokens));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(EIP20NonStandardInterface token) override external {\\n        delegateToImplementation(abi.encodeWithSignature(\\\"sweepToken(address)\\\", token));\\n    }\\n        \\n    function depositNFT(address _NFTAddress, uint256 _TokenID) override external {\\n         delegateToImplementation(abi.encodeWithSignature(\\\"depositNFT(address,uint256)\\\", _NFTAddress, _TokenID));\\n    }\\n\\n    function withdrawNFT(address _NFTAddress, uint256 _TokenID) override external {\\n        delegateToImplementation(abi.encodeWithSignature(\\\"withdrawNFT(address,uint256)\\\", _NFTAddress, _TokenID));\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setPendingAdmin(address)\\\", newPendingAdmin));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Sets a new comptroller for the market\\n      * @dev Admin function to set a new comptroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setComptroller(address)\\\", newComptroller));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setReserveFactor(uint256)\\\", newReserveFactorMantissa));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_acceptAdmin()\\\"));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrues interest and adds reserves by transferring from admin\\n     * @param addAmount Amount of reserves to add\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_addReserves(uint256)\\\", addAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) override external returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_reduceReserves(uint256)\\\", reduceAmount));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setInterestRateModel(address)\\\", newInterestRateModel));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Updates the glp contract addresses using _setGlpAddresses\\n     * @dev Admin function to set the GLP contract addresses\\n     * @param stakedGLP_ the stakedGLP contract to use\\n     * @param glpRewardRouter_ the rewardrouter contract address to use\\n     * @param glpManager_ the glpManager contract address to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setGlpAddresses(IStakedGlp stakedGLP_, IGmxRewardRouter glpRewardRouter_, address glpManager_) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setGlpAddresses(address,address,address)\\\", stakedGLP_, glpRewardRouter_, glpManager_));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Updates the fees for the vault strategy markets\\n     * @dev Admin function to update the fees\\n     * @param withdrawFee_ fee to withdraw funds\\n     * @param managementFee_ fee taken from autocompounded rewards\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setVaultFees(uint256 withdrawFee_, uint256 managementFee_) override public returns (uint){\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setVaultFees(uint256,uint256)\\\", withdrawFee_, managementFee_));\\n        return abi.decode(data, (uint));\\n    }\\n\\n\\n    /**\\n     * @notice Transfers all esGmx assets to the recipient\\n     * @dev Admin function to remove all esGmx assets from the contract\\n     * @param recipient the address to send all the assets to\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _signalTransfer(address recipient) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_signalTransfer(address)\\\", recipient));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Toggle wether or not the GLP rewards should be autocompounded\\n     * @dev Admin function to set wether or not GLP rewards should be autocompounded\\n     * @param autocompound_ should the rewards be autocompounded or not\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setAutocompoundRewards(bool autocompound_) override public returns (uint) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"_setAutocompoundRewards(bool)\\\", autocompound_));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Internal method to delegate execution to another contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param callee The contract to delegatecall\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return returnData;\\n    }\\n\\n    /**\\n     * @notice Delegates execution to the implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\n        return delegateTo(implementation, data);\\n    }\\n\\n    /**\\n     * @notice Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", data));\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return abi.decode(returnData, (bytes));\\n    }\\n\\n    /**\\n     * @notice Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     */\\n    fallback() external payable {\\n        require(msg.value == 0,\\\"CErc20Delegator:fallback: cannot send value to fallback\\\");\\n\\n        // delegate all other functions to current implementation\\n        (bool success, ) = implementation.delegatecall(msg.data);\\n\\n        assembly {\\n            let free_mem_ptr := mload(0x40)\\n            returndatacopy(free_mem_ptr, 0, returndatasize())\\n\\n            switch success\\n            case 0 { revert(free_mem_ptr, returndatasize()) }\\n            default { return(free_mem_ptr, returndatasize()) }\\n        }\\n    }\\n\\n    function approveGlpRewardRouterWETHSpending() external {\\n        require(msg.sender == admin, \\\"only admin can call approve\\\");\\n        EIP20Interface(WETH).approve(glpManager, type(uint256).max);\\n    }\\n\\n}\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/CEther.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\n\\n/**\\n * @title Compound's CEther Contract\\n * @notice CToken which wraps Ether\\n * @author Compound\\n */\\ncontract CEther is CToken {\\n    /**\\n     * @notice Construct a new CEther money market\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param isGLP_ Wether or not the market being created is for the GLP token\\n     */\\n    constructor(ComptrollerInterface comptroller_,\\n                InterestRateModel interestRateModel_,\\n                uint initialExchangeRateMantissa_,\\n                string memory name_,\\n                string memory symbol_,\\n                uint8 decimals_,\\n                address payable admin_,\\n                bool isGLP_) {\\n        // Creator of the contract is admin during initialization\\n        admin = payable(msg.sender);\\n\\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, isGLP_);\\n\\n        // Set the proper admin now that initialization is done\\n        admin = admin_;\\n    }\\n\\n\\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Reverts upon any failure\\n     */\\n    function mint() external payable {\\n        mintInternal(msg.value);\\n        comptroller.addToMarketExternal(address(this), msg.sender);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) external returns (uint) {\\n        redeemInternal(redeemTokens);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\\n        redeemUnderlyingInternal(redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) external returns (uint) {\\n        borrowInternal(borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @dev Reverts upon any failure\\n     */\\n    function repayBorrow() external payable {\\n        repayBorrowInternal(msg.value);\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @dev Reverts upon any failure\\n     * @param borrower the account with the debt being payed off\\n     */\\n    function repayBorrowBehalf(address borrower) external payable {\\n        repayBorrowBehalfInternal(borrower, msg.value);\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @dev Reverts upon any failure\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     */\\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\\n        liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves() external payable returns (uint) {\\n        return _addReservesInternal(msg.value);\\n    }\\n\\n    /**\\n     * @notice Send Ether to CEther to mint\\n     */\\n    receive() external payable {\\n        mintInternal(msg.value);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of Ether, before this message\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of Ether owned by this contract\\n     */\\n    function getCashPrior() override internal view returns (uint) {\\n        return address(this).balance - msg.value;\\n    }\\n\\n    /**\\n     * @notice Perform the actual transfer in, which is a no-op\\n     * @param from Address sending the Ether\\n     * @param amount Amount of Ether being sent\\n     * @return The actual amount of Ether transferred\\n     */\\n    function doTransferIn(address from, uint amount) override internal returns (uint) {\\n        // Sanity checks\\n        require(msg.sender == from, \\\"sender mismatch\\\");\\n        require(msg.value == amount, \\\"value mismatch\\\");\\n        return amount;\\n    }\\n\\n    function doTransferOut(address payable to, uint amount) virtual override internal {\\n        /* Send the Ether, with minimal gas and revert on failure */\\n        to.transfer(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Maximillion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CEther.sol\\\";\\n\\n/**\\n * @title Compound's Maximillion Contract\\n * @author Compound\\n */\\ncontract Maximillion {\\n    /**\\n     * @notice The default cEther market to repay in\\n     */\\n    CEther public cEther;\\n\\n    /**\\n     * @notice Construct a Maximillion to repay max in a CEther market\\n     */\\n    constructor(CEther cEther_) public {\\n        cEther = cEther_;\\n    }\\n\\n    /**\\n     * @notice msg.sender sends Ether to repay an account's borrow in the cEther market\\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\\n     * @param borrower The address of the borrower account to repay on behalf of\\n     */\\n    function repayBehalf(address borrower) public payable {\\n        repayBehalfExplicit(borrower, cEther);\\n    }\\n\\n    /**\\n     * @notice msg.sender sends Ether to repay an account's borrow in a cEther market\\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\\n     * @param borrower The address of the borrower account to repay on behalf of\\n     * @param cEther_ The address of the cEther contract to repay in\\n     */\\n    function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\\n        uint received = msg.value;\\n        uint borrows = cEther_.borrowBalanceCurrent(borrower);\\n        if (received > borrows) {\\n            cEther_.repayBorrowBehalf{value: borrows}(borrower);\\n            payable(msg.sender).transfer(received - borrows);\\n        } else {\\n            cEther_.repayBorrowBehalf{value: received}(borrower);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GMXPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./CErc20.sol\\\";\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ninterface IVaultPriceFeed {\\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\\n    \\n}\\n\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface GlpManager{\\n    function getAumInUsdg(bool maximise) external view returns (uint256);\\n}\\n\\ninterface GmxTokenPriceOracle{\\n    function getPriceInUSD() external view returns (uint256);\\n}\\ncontract GMXPriceOracle is PriceOracle {\\n    using SafeMath for uint256;\\n    \\n    IERC20 public glpToken = IERC20(0x4277f8F2c384827B5273592FF7CeBd9f2C1ac258);\\n    GlpManager public glpManager = GlpManager(0x321F653eED006AD1C29D174e17d96351BDe22649);\\n    IVaultPriceFeed public gmxPriceFeed = IVaultPriceFeed(0xa18BB1003686d0854EF989BB936211c59EB6e363);\\n    GmxTokenPriceOracle public gmxTokenPriceOracle = GmxTokenPriceOracle(0x60E07B25Ba79bf8D40831cdbDA60CF49571c7Ee0);\\n\\n    function _getUnderlyingAddress(CToken cToken) private view returns (address) {\\n        address asset;\\n        if (compareStrings(cToken.symbol(), \\\"tETH\\\")) {\\n            asset = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\\n        } else {\\n            asset = address(CErc20(address(cToken)).underlying());\\n        }\\n        return asset;\\n    }\\n    \\n    function getGlpSupply() public view returns (uint256) {\\n        return glpToken.totalSupply();\\n    }\\n    function getGlpAum() public view returns (uint256) {\\n        return glpManager.getAumInUsdg(true);\\n    }\\n    \\n    function getUnderlyingPrice(CToken cToken) public override view returns (uint) {\\n        if(cToken.isGLP()){\\n            return glpManager.getAumInUsdg(true).mul(1e28).div(glpToken.totalSupply());   \\n        } else if(compareStrings(cToken.symbol(), \\\"tGMX\\\")){\\n            return gmxTokenPriceOracle.getPriceInUSD();\\n        } else {\\n            return gmxPriceFeed.getPrice(_getUnderlyingAddress(cToken), true, true, false).div(100);\\n        }\\n    }\\n\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CErc20Immutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CErc20.sol\\\";\\n\\n/**\\n * @title Compound's CErc20Immutable Contract\\n * @notice CTokens which wrap an EIP-20 underlying and are immutable\\n * @author Compound\\n */\\ncontract CErc20Immutable is CErc20 {\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param isGLP_ Wether or not the market being created is for the GLP token\\n     * @param admin_ Address of the administrator of this token\\n     */\\n    constructor(address underlying_,\\n                ComptrollerInterface comptroller_,\\n                InterestRateModel interestRateModel_,\\n                uint initialExchangeRateMantissa_,\\n                string memory name_,\\n                string memory symbol_,\\n                uint8 decimals_,\\n                bool isGLP_,\\n                address payable admin_) {\\n        // Creator of the contract is admin during initialization\\n        admin = payable(msg.sender);\\n\\n        // Initialize the market\\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, isGLP_);\\n\\n        // Set the proper admin now that initialization is done\\n        admin = admin_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CErc20Delegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.10;\\n\\nimport \\\"./CErc20.sol\\\";\\n\\n/**\\n * @title Compound's CErc20Delegate Contract\\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\\n * @author Compound\\n */\\ncontract CErc20Delegate is CErc20, CDelegateInterface {\\n    /**\\n     * @notice Construct an empty delegate\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\n     * @param data The encoded bytes data for any initialization\\n     */\\n    function _becomeImplementation(bytes memory data) virtual override public {\\n        // Shh -- currently unused\\n        data;\\n\\n        // Shh -- we don't ever want this hook to be marked pure\\n        if (false) {\\n            implementation = address(0);\\n        }\\n\\n        require(msg.sender == admin, \\\"only the admin may call _becomeImplementation\\\");\\n    }\\n\\n    /**\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\n     */\\n    function _resignImplementation() virtual override public {\\n        // Shh -- we don't ever want this hook to be marked pure\\n        if (false) {\\n            implementation = address(0);\\n        }\\n\\n        require(msg.sender == admin, \\\"only the admin may call _resignImplementation\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseJumpRateModelV2Gmx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./InterestRateModel.sol\\\";\\n\\ninterface IRewardDistributor {\\n\\n    function rewardToken() external view returns (address);\\n    function tokensPerInterval() external view returns (uint256);\\n    function pendingRewards() external view returns (uint256);\\n    function distribute() external returns (uint256);\\n\\n}\\n\\ninterface GmxTokenPriceOracle{\\n    function getPriceInUSD() external view returns (uint256);\\n    function getETHPriceInUSD() external view returns (uint256);\\n}\\n\\n/**\\n  * @title Logic for Compound's JumpRateModel Contract V2.\\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\\n  */\\nabstract contract BaseJumpRateModelV2Gmx is InterestRateModel {\\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\\n\\n    uint256 private constant BASE = 1e18;\\n\\n    /**\\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\\n     */\\n    address public owner;\\n\\n    /**\\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\\n     */\\n    uint public constant blocksPerYear = 144752795;\\n\\n    /**\\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\\n     */\\n    uint public multiplierPerBlock;\\n\\n    /**\\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\\n     */\\n    uint public baseRatePerBlock;\\n\\n    /**\\n     * @notice The multiplierPerBlock after hitting a specified utilization point\\n     */\\n    uint public jumpMultiplierPerBlock;\\n\\n    /**\\n     * @notice The utilization point at which the jump multiplier is applied\\n     */\\n    uint public kink;\\n\\n    IRewardDistributor public gmxDistributor = IRewardDistributor(0x1DE098faF30bD74F22753c28DB17A2560D4F5554);\\n\\n    GmxTokenPriceOracle public gmxTokenPriceOracle = GmxTokenPriceOracle(0x60E07B25Ba79bf8D40831cdbDA60CF49571c7Ee0);\\n\\n    /**\\n     * @notice Construct an interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\\n     */\\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal {\\n        owner = owner_;\\n\\n        updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);\\n    }\\n\\n    /**\\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) virtual external {\\n        require(msg.sender == owner, \\\"only the owner may call this function.\\\");\\n\\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\\n    }\\n\\n    /**\\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market (currently unused)\\n     * @return The utilization rate as a mantissa between [0, BASE]\\n     */\\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\\n        // Utilization rate is 0 when there are no borrows\\n        if (borrows == 0) {\\n            return 0;\\n        }\\n\\n        return borrows * BASE / (cash + borrows - reserves);\\n    }\\n\\n    function getGmxAmountTokenPerInterval() internal view returns (uint){\\n        \\n        uint256 ethPerInterval = gmxDistributor.tokensPerInterval();\\n        uint256 ethPrice = gmxTokenPriceOracle.getETHPriceInUSD();\\n        uint256 gmxPrice = gmxTokenPriceOracle.getPriceInUSD();\\n\\n        uint256 gmxPerInterval = (ethPerInterval * ethPrice) / gmxPrice;\\n\\n    }\\n\\n    /**\\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\\n     */\\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\\n        uint util = utilizationRate(cash, borrows, reserves);\\n\\n        if (util <= kink) {\\n            return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\\n        } else {\\n            uint normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\\n            uint excessUtil = util - kink;\\n            return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate + getGmxAmountTokenPerInterval();\\n        }\\n    }\\n\\n    \\n\\n    /**\\n     * @notice Calculates the current supply rate per block\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @param reserveFactorMantissa The current reserve factor for the market\\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\\n     */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual override public view returns (uint) {\\n        uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\\n        uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\\n        return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\\n    }\\n\\n    /**\\n     * @notice Internal function to update the parameters of the interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {\\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\\n        multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\\n        kink = kink_;\\n\\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/GovernorBravoDelegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./GovernorBravoInterfaces.sol\\\";\\n\\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, GovernorBravoEvents {\\n\\n    /// @notice The name of this contract\\n    string public constant name = \\\"Compound Governor Bravo\\\";\\n\\n    /// @notice The minimum setable proposal threshold\\n    uint public constant MIN_PROPOSAL_THRESHOLD = 1000e18; // 1,000 Comp\\n\\n    /// @notice The maximum setable proposal threshold\\n    uint public constant MAX_PROPOSAL_THRESHOLD = 100000e18; //100,000 Comp\\n\\n    /// @notice The minimum setable voting period\\n    uint public constant MIN_VOTING_PERIOD = 5760; // About 24 hours\\n\\n    /// @notice The max setable voting period\\n    uint public constant MAX_VOTING_PERIOD = 80640; // About 2 weeks\\n\\n    /// @notice The min setable voting delay\\n    uint public constant MIN_VOTING_DELAY = 1;\\n\\n    /// @notice The max setable voting delay\\n    uint public constant MAX_VOTING_DELAY = 40320; // About 1 week\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    uint public constant quorumVotes = 400000e18; // 400,000 = 4% of Comp\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    uint public constant proposalMaxOperations = 10; // 10 actions\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,uint8 support)\\\");\\n\\n    /**\\n      * @notice Used to initialize the contract during delegator constructor\\n      * @param timelock_ The address of the Timelock\\n      * @param comp_ The address of the COMP token\\n      * @param votingPeriod_ The initial voting period\\n      * @param votingDelay_ The initial voting delay\\n      * @param proposalThreshold_ The initial proposal threshold\\n      */\\n    function initialize(address timelock_, address comp_, uint votingPeriod_, uint votingDelay_, uint proposalThreshold_) virtual public {\\n        require(address(timelock) == address(0), \\\"GovernorBravo::initialize: can only initialize once\\\");\\n        require(msg.sender == admin, \\\"GovernorBravo::initialize: admin only\\\");\\n        require(timelock_ != address(0), \\\"GovernorBravo::initialize: invalid timelock address\\\");\\n        require(comp_ != address(0), \\\"GovernorBravo::initialize: invalid comp address\\\");\\n        require(votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD, \\\"GovernorBravo::initialize: invalid voting period\\\");\\n        require(votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY, \\\"GovernorBravo::initialize: invalid voting delay\\\");\\n        require(proposalThreshold_ >= MIN_PROPOSAL_THRESHOLD && proposalThreshold_ <= MAX_PROPOSAL_THRESHOLD, \\\"GovernorBravo::initialize: invalid proposal threshold\\\");\\n\\n        timelock = TimelockInterface(timelock_);\\n        comp = CompInterface(comp_);\\n        votingPeriod = votingPeriod_;\\n        votingDelay = votingDelay_;\\n        proposalThreshold = proposalThreshold_;\\n    }\\n\\n    /**\\n      * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\\n      * @param targets Target addresses for proposal calls\\n      * @param values Eth values for proposal calls\\n      * @param signatures Function signatures for proposal calls\\n      * @param calldatas Calldatas for proposal calls\\n      * @param description String description of the proposal\\n      * @return Proposal id of new proposal\\n      */\\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\\n        // Reject proposals before initiating as Governor\\n        require(initialProposalId != 0, \\\"GovernorBravo::propose: Governor Bravo not active\\\");\\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold || isWhitelisted(msg.sender), \\\"GovernorBravo::propose: proposer votes below proposal threshold\\\");\\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \\\"GovernorBravo::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"GovernorBravo::propose: must provide actions\\\");\\n        require(targets.length <= proposalMaxOperations, \\\"GovernorBravo::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = add256(block.number, votingDelay);\\n        uint endBlock = add256(startBlock, votingPeriod);\\n\\n        proposalCount++;\\n        uint newProposalID = proposalCount;\\n        Proposal storage newProposal = proposals[newProposalID];\\n        // This should never happen but add a check in case.\\n        require(newProposal.id == 0, \\\"GovernorBravo::propose: ProposalID collsion\\\");\\n        newProposal.id = newProposalID;\\n        newProposal.proposer = msg.sender;\\n        newProposal.eta = 0;\\n        newProposal.targets = targets;\\n        newProposal.values = values;\\n        newProposal.signatures = signatures;\\n        newProposal.calldatas = calldatas;\\n        newProposal.startBlock = startBlock;\\n        newProposal.endBlock = endBlock;\\n        newProposal.forVotes = 0;\\n        newProposal.againstVotes = 0;\\n        newProposal.abstainVotes = 0;\\n        newProposal.canceled = false;\\n        newProposal.executed = false;\\n\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    /**\\n      * @notice Queues a proposal of state succeeded\\n      * @param proposalId The id of the proposal to queue\\n      */\\n    function queue(uint proposalId) external {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"GovernorBravo::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint eta = add256(block.timestamp, timelock.delay());\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            queueOrRevertInternal(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function queueOrRevertInternal(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \\\"GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta\\\");\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    /**\\n      * @notice Executes a queued proposal if eta has passed\\n      * @param proposalId The id of the proposal to execute\\n      */\\n    function execute(uint proposalId) external payable {\\n        require(state(proposalId) == ProposalState.Queued, \\\"GovernorBravo::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.executeTransaction{value: proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    /**\\n      * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\\n      * @param proposalId The id of the proposal to cancel\\n      */\\n    function cancel(uint proposalId) external {\\n        require(state(proposalId) != ProposalState.Executed, \\\"GovernorBravo::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        // Proposer can cancel\\n        if(msg.sender != proposal.proposer) {\\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\\n            if(isWhitelisted(proposal.proposer)) {\\n                require((comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold) && msg.sender == whitelistGuardian, \\\"GovernorBravo::cancel: whitelisted proposer\\\");\\n            }\\n            else {\\n                require((comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold), \\\"GovernorBravo::cancel: proposer above threshold\\\");\\n            }\\n        }\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    /**\\n      * @notice Gets actions of a proposal\\n      * @param proposalId the id of the proposal\\n      * @return targets of the proposal actions\\n      * @return values of the proposal actions\\n      * @return signatures of the proposal actions\\n      * @return calldatas of the proposal actions\\n      */\\n    function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    /**\\n      * @notice Gets the receipt for a voter on a given proposal\\n      * @param proposalId the id of proposal\\n      * @param voter The address of the voter\\n      * @return The voting receipt\\n      */\\n    function getReceipt(uint proposalId, address voter) external view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    /**\\n      * @notice Gets the state of a proposal\\n      * @param proposalId The id of the proposal\\n      * @return Proposal state\\n      */\\n    function state(uint proposalId) public view returns (ProposalState) {\\n        require(proposalCount >= proposalId && proposalId > initialProposalId, \\\"GovernorBravo::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number <= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    /**\\n      * @notice Cast a vote for a proposal\\n      * @param proposalId The id of the proposal to vote on\\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n      */\\n    function castVote(uint proposalId, uint8 support) external {\\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), \\\"\\\");\\n    }\\n\\n    /**\\n      * @notice Cast a vote for a proposal with a reason\\n      * @param proposalId The id of the proposal to vote on\\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n      * @param reason The reason given for the vote by the voter\\n      */\\n    function castVoteWithReason(uint proposalId, uint8 support, string calldata reason) external {\\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\\n    }\\n\\n    /**\\n      * @notice Cast a vote for a proposal by signature\\n      * @dev External function that accepts EIP-712 signatures for voting on proposals.\\n      */\\n    function castVoteBySig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"GovernorBravo::castVoteBySig: invalid signature\\\");\\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), \\\"\\\");\\n    }\\n\\n    /**\\n      * @notice Internal function that caries out voting logic\\n      * @param voter The voter that is casting their vote\\n      * @param proposalId The id of the proposal to vote on\\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n      * @return The number of votes cast\\n      */\\n    function castVoteInternal(address voter, uint proposalId, uint8 support) internal returns (uint96) {\\n        require(state(proposalId) == ProposalState.Active, \\\"GovernorBravo::castVoteInternal: voting is closed\\\");\\n        require(support <= 2, \\\"GovernorBravo::castVoteInternal: invalid vote type\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"GovernorBravo::castVoteInternal: voter already voted\\\");\\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support == 0) {\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\n        } else if (support == 1) {\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\n        } else if (support == 2) {\\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        return votes;\\n    }\\n\\n    /**\\n     * @notice View function which returns if an account is whitelisted\\n     * @param account Account to check white list status of\\n     * @return If the account is whitelisted\\n     */\\n    function isWhitelisted(address account) public view returns (bool) {\\n        return (whitelistAccountExpirations[account] > block.timestamp);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the voting delay\\n      * @param newVotingDelay new voting delay, in blocks\\n      */\\n    function _setVotingDelay(uint newVotingDelay) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setVotingDelay: admin only\\\");\\n        require(newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY, \\\"GovernorBravo::_setVotingDelay: invalid voting delay\\\");\\n        uint oldVotingDelay = votingDelay;\\n        votingDelay = newVotingDelay;\\n\\n        emit VotingDelaySet(oldVotingDelay,votingDelay);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the voting period\\n      * @param newVotingPeriod new voting period, in blocks\\n      */\\n    function _setVotingPeriod(uint newVotingPeriod) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setVotingPeriod: admin only\\\");\\n        require(newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD, \\\"GovernorBravo::_setVotingPeriod: invalid voting period\\\");\\n        uint oldVotingPeriod = votingPeriod;\\n        votingPeriod = newVotingPeriod;\\n\\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the proposal threshold\\n      * @dev newProposalThreshold must be greater than the hardcoded min\\n      * @param newProposalThreshold new proposal threshold\\n      */\\n    function _setProposalThreshold(uint newProposalThreshold) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setProposalThreshold: admin only\\\");\\n        require(newProposalThreshold >= MIN_PROPOSAL_THRESHOLD && newProposalThreshold <= MAX_PROPOSAL_THRESHOLD, \\\"GovernorBravo::_setProposalThreshold: invalid proposal threshold\\\");\\n        uint oldProposalThreshold = proposalThreshold;\\n        proposalThreshold = newProposalThreshold;\\n\\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the whitelist expiration as a timestamp for an account. Whitelist status allows accounts to propose without meeting threshold\\n     * @param account Account address to set whitelist expiration for\\n     * @param expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\\n     */\\n    function _setWhitelistAccountExpiration(address account, uint expiration) external {\\n        require(msg.sender == admin || msg.sender == whitelistGuardian, \\\"GovernorBravo::_setWhitelistAccountExpiration: admin only\\\");\\n        whitelistAccountExpirations[account] = expiration;\\n\\n        emit WhitelistAccountExpirationSet(account, expiration);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\\n     * @param account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\\n     */\\n     function _setWhitelistGuardian(address account) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setWhitelistGuardian: admin only\\\");\\n        address oldGuardian = whitelistGuardian;\\n        whitelistGuardian = account;\\n\\n        emit WhitelistGuardianSet(oldGuardian, whitelistGuardian);\\n     }\\n\\n    /**\\n      * @notice Initiate the GovernorBravo contract\\n      * @dev Admin only. Sets initial proposal id which initiates the contract, ensuring a continuous proposal id count\\n      * @param governorAlpha The address for the Governor to continue the proposal id count from\\n      */\\n    function _initiate(address governorAlpha) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_initiate: admin only\\\");\\n        require(initialProposalId == 0, \\\"GovernorBravo::_initiate: can only initiate once\\\");\\n        proposalCount = GovernorAlpha(governorAlpha).proposalCount();\\n        initialProposalId = proposalCount;\\n        timelock.acceptAdmin();\\n    }\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) external {\\n        // Check caller = admin\\n        require(msg.sender == admin, \\\"GovernorBravo:_setPendingAdmin: admin only\\\");\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      */\\n    function _acceptAdmin() external {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        require(msg.sender == pendingAdmin && msg.sender != address(0), \\\"GovernorBravo:_acceptAdmin: pending admin only\\\");\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function getChainIdInternal() internal view returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/GovernorBravoInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n\\ncontract GovernorBravoEvents {\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    /// @param voter The address which casted a vote\\n    /// @param proposalId The proposal id which was voted on\\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\\n    /// @param votes Number of votes which were cast by the voter\\n    /// @param reason The reason given for the vote by the voter\\n    event VoteCast(address indexed voter, uint proposalId, uint8 support, uint votes, string reason);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint id, uint eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint id);\\n\\n    /// @notice An event emitted when the voting delay is set\\n    event VotingDelaySet(uint oldVotingDelay, uint newVotingDelay);\\n\\n    /// @notice An event emitted when the voting period is set\\n    event VotingPeriodSet(uint oldVotingPeriod, uint newVotingPeriod);\\n\\n    /// @notice Emitted when implementation is changed\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /// @notice Emitted when proposal threshold is set\\n    event ProposalThresholdSet(uint oldProposalThreshold, uint newProposalThreshold);\\n\\n    /// @notice Emitted when pendingAdmin is changed\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /// @notice Emitted when whitelist account expiration is set\\n    event WhitelistAccountExpirationSet(address account, uint expiration);\\n\\n    /// @notice Emitted when the whitelistGuardian is set\\n    event WhitelistGuardianSet(address oldGuardian, address newGuardian);\\n}\\n\\ncontract GovernorBravoDelegatorStorage {\\n    /// @notice Administrator for this contract\\n    address public admin;\\n\\n    /// @notice Pending administrator for this contract\\n    address public pendingAdmin;\\n\\n    /// @notice Active brains of Governor\\n    address public implementation;\\n}\\n\\n\\n/**\\n * @title Storage for Governor Bravo Delegate\\n * @notice For future upgrades, do not change GovernorBravoDelegateStorageV1. Create a new\\n * contract which implements GovernorBravoDelegateStorageV1 and following the naming convention\\n * GovernorBravoDelegateStorageVX.\\n */\\ncontract GovernorBravoDelegateStorageV1 is GovernorBravoDelegatorStorage {\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n    uint public votingDelay;\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint public votingPeriod;\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    uint public proposalThreshold;\\n\\n    /// @notice Initial proposal id set at become\\n    uint public initialProposalId;\\n\\n    /// @notice The total number of proposals\\n    uint public proposalCount;\\n\\n    /// @notice The address of the Compound Protocol Timelock\\n    TimelockInterface public timelock;\\n\\n    /// @notice The address of the Compound governance token\\n    CompInterface public comp;\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping (uint => Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping (address => uint) public latestProposalIds;\\n\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint id;\\n\\n        /// @notice Creator of the proposal\\n        address proposer;\\n\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint eta;\\n\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint[] values;\\n\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint startBlock;\\n\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint endBlock;\\n\\n        /// @notice Current number of votes in favor of this proposal\\n        uint forVotes;\\n\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint againstVotes;\\n\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint abstainVotes;\\n\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping (address => Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        /// @notice Whether or not the voter supports the proposal or abstains\\n        uint8 support;\\n\\n        /// @notice The number of votes the voter had, which were cast\\n        uint96 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n}\\n\\ncontract GovernorBravoDelegateStorageV2 is GovernorBravoDelegateStorageV1 {\\n    /// @notice Stores the expiration of account whitelist status as a timestamp\\n    mapping (address => uint) public whitelistAccountExpirations;\\n\\n    /// @notice Address which manages whitelisted proposals and whitelist accounts\\n    address public whitelistGuardian;\\n}\\n\\ninterface TimelockInterface {\\n    function delay() external view returns (uint);\\n    function GRACE_PERIOD() external view returns (uint);\\n    function acceptAdmin() external;\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\\n}\\n\\ninterface CompInterface {\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\\n}\\n\\ninterface GovernorAlpha {\\n    /// @notice The total number of proposals\\n    function proposalCount() external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/GovernorBravoDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./GovernorBravoInterfaces.sol\\\";\\n\\ncontract GovernorBravoDelegator is GovernorBravoDelegatorStorage, GovernorBravoEvents {\\n\\tconstructor(\\n\\t\\t\\taddress timelock_,\\n\\t\\t\\taddress comp_,\\n\\t\\t\\taddress admin_,\\n\\t        address implementation_,\\n\\t        uint votingPeriod_,\\n\\t        uint votingDelay_,\\n            uint proposalThreshold_) public {\\n\\n        // Admin set to msg.sender for initialization\\n        admin = msg.sender;\\n\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,uint256,uint256,uint256)\\\",\\n                                                            timelock_,\\n                                                            comp_,\\n                                                            votingPeriod_,\\n                                                            votingDelay_,\\n                                                            proposalThreshold_));\\n\\n        _setImplementation(implementation_);\\n\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n\\n\\t/**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     */\\n    function _setImplementation(address implementation_) public {\\n        require(msg.sender == admin, \\\"GovernorBravoDelegator::_setImplementation: admin only\\\");\\n        require(implementation_ != address(0), \\\"GovernorBravoDelegator::_setImplementation: invalid implementation address\\\");\\n\\n        address oldImplementation = implementation;\\n        implementation = implementation_;\\n\\n        emit NewImplementation(oldImplementation, implementation);\\n    }\\n\\n    /**\\n     * @notice Internal method to delegate execution to another contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param callee The contract to delegatecall\\n     * @param data The raw data to delegatecall\\n     */\\n    function delegateTo(address callee, bytes memory data) internal {\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n    }\\n\\n\\t/**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    fallback () external payable {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = implementation.delegatecall(msg.data);\\n\\n        assembly {\\n              let free_mem_ptr := mload(0x40)\\n              returndatacopy(free_mem_ptr, 0, returndatasize())\\n\\n              switch success\\n              case 0 { revert(free_mem_ptr, returndatasize()) }\\n              default { return(free_mem_ptr, returndatasize()) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/GovernorBravoDelegateG1.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./GovernorBravoInterfaces.sol\\\";\\n\\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV1, GovernorBravoEvents {\\n\\n    /// @notice The name of this contract\\n    string public constant name = \\\"Compound Governor Bravo\\\";\\n\\n    /// @notice The minimum setable proposal threshold\\n    uint public constant MIN_PROPOSAL_THRESHOLD = 50000e18; // 50,000 Comp\\n\\n    /// @notice The maximum setable proposal threshold\\n    uint public constant MAX_PROPOSAL_THRESHOLD = 100000e18; //100,000 Comp\\n\\n    /// @notice The minimum setable voting period\\n    uint public constant MIN_VOTING_PERIOD = 5760; // About 24 hours\\n\\n    /// @notice The max setable voting period\\n    uint public constant MAX_VOTING_PERIOD = 80640; // About 2 weeks\\n\\n    /// @notice The min setable voting delay\\n    uint public constant MIN_VOTING_DELAY = 1;\\n\\n    /// @notice The max setable voting delay\\n    uint public constant MAX_VOTING_DELAY = 40320; // About 1 week\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    uint public constant quorumVotes = 400000e18; // 400,000 = 4% of Comp\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    uint public constant proposalMaxOperations = 10; // 10 actions\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,uint8 support)\\\");\\n\\n    /**\\n      * @notice Used to initialize the contract during delegator constructor\\n      * @param timelock_ The address of the Timelock\\n      * @param comp_ The address of the COMP token\\n      * @param votingPeriod_ The initial voting period\\n      * @param votingDelay_ The initial voting delay\\n      * @param proposalThreshold_ The initial proposal threshold\\n      */\\n    function initialize(address timelock_, address comp_, uint votingPeriod_, uint votingDelay_, uint proposalThreshold_) public {\\n        require(address(timelock) == address(0), \\\"GovernorBravo::initialize: can only initialize once\\\");\\n        require(msg.sender == admin, \\\"GovernorBravo::initialize: admin only\\\");\\n        require(timelock_ != address(0), \\\"GovernorBravo::initialize: invalid timelock address\\\");\\n        require(comp_ != address(0), \\\"GovernorBravo::initialize: invalid comp address\\\");\\n        require(votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD, \\\"GovernorBravo::initialize: invalid voting period\\\");\\n        require(votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY, \\\"GovernorBravo::initialize: invalid voting delay\\\");\\n        require(proposalThreshold_ >= MIN_PROPOSAL_THRESHOLD && proposalThreshold_ <= MAX_PROPOSAL_THRESHOLD, \\\"GovernorBravo::initialize: invalid proposal threshold\\\");\\n\\n        timelock = TimelockInterface(timelock_);\\n        comp = CompInterface(comp_);\\n        votingPeriod = votingPeriod_;\\n        votingDelay = votingDelay_;\\n        proposalThreshold = proposalThreshold_;\\n    }\\n\\n    /**\\n      * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\\n      * @param targets Target addresses for proposal calls\\n      * @param values Eth values for proposal calls\\n      * @param signatures Function signatures for proposal calls\\n      * @param calldatas Calldatas for proposal calls\\n      * @param description String description of the proposal\\n      * @return Proposal id of new proposal\\n      */\\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\\n        // Reject proposals before initiating as Governor\\n        require(initialProposalId != 0, \\\"GovernorBravo::propose: Governor Bravo not active\\\");\\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \\\"GovernorBravo::propose: proposer votes below proposal threshold\\\");\\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \\\"GovernorBravo::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"GovernorBravo::propose: must provide actions\\\");\\n        require(targets.length <= proposalMaxOperations, \\\"GovernorBravo::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = add256(block.number, votingDelay);\\n        uint endBlock = add256(startBlock, votingPeriod);\\n\\n        proposalCount++;\\n        Proposal storage newProposal = proposals[proposalCount];\\n        // This should never happen but add a check in case.\\n        require(newProposal.id == 0, \\\"GovernorBravo::propose: ProposalID collsion\\\");\\n        newProposal.id = proposalCount;\\n        newProposal.proposer = msg.sender;\\n        newProposal.eta = 0;\\n        newProposal.targets = targets;\\n        newProposal.values = values;\\n        newProposal.signatures = signatures;\\n        newProposal.calldatas = calldatas;\\n        newProposal.startBlock = startBlock;\\n        newProposal.endBlock = endBlock;\\n        newProposal.forVotes = 0;\\n        newProposal.againstVotes = 0;\\n        newProposal.abstainVotes = 0;\\n        newProposal.canceled = false;\\n        newProposal.executed = false;\\n\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    /**\\n      * @notice Queues a proposal of state succeeded\\n      * @param proposalId The id of the proposal to queue\\n      */\\n    function queue(uint proposalId) external {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"GovernorBravo::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint eta = add256(block.timestamp, timelock.delay());\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            queueOrRevertInternal(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function queueOrRevertInternal(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \\\"GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta\\\");\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    /**\\n      * @notice Executes a queued proposal if eta has passed\\n      * @param proposalId The id of the proposal to execute\\n      */\\n    function execute(uint proposalId) external payable {\\n        require(state(proposalId) == ProposalState.Queued, \\\"GovernorBravo::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.executeTransaction{value: proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    /**\\n      * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\\n      * @param proposalId The id of the proposal to cancel\\n      */\\n    function cancel(uint proposalId) external {\\n        require(state(proposalId) != ProposalState.Executed, \\\"GovernorBravo::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        require(msg.sender == proposal.proposer || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold, \\\"GovernorBravo::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    /**\\n      * @notice Gets actions of a proposal\\n      * @param proposalId the id of the proposal\\n      * @return targets of the proposal actions\\n      * @return values of the proposal actions\\n      * @return signatures of the proposal actions\\n      * @return calldatas of the proposal actions\\n      */\\n    function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    /**\\n      * @notice Gets the receipt for a voter on a given proposal\\n      * @param proposalId the id of proposal\\n      * @param voter The address of the voter\\n      * @return The voting receipt\\n      */\\n    function getReceipt(uint proposalId, address voter) external view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    /**\\n      * @notice Gets the state of a proposal\\n      * @param proposalId The id of the proposal\\n      * @return Proposal state\\n      */\\n    function state(uint proposalId) public view returns (ProposalState) {\\n        require(proposalCount >= proposalId && proposalId > initialProposalId, \\\"GovernorBravo::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number <= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    /**\\n      * @notice Cast a vote for a proposal\\n      * @param proposalId The id of the proposal to vote on\\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n      */\\n    function castVote(uint proposalId, uint8 support) external {\\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), \\\"\\\");\\n    }\\n\\n    /**\\n      * @notice Cast a vote for a proposal with a reason\\n      * @param proposalId The id of the proposal to vote on\\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n      * @param reason The reason given for the vote by the voter\\n      */\\n    function castVoteWithReason(uint proposalId, uint8 support, string calldata reason) external {\\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\\n    }\\n\\n    /**\\n      * @notice Cast a vote for a proposal by signature\\n      * @dev External function that accepts EIP-712 signatures for voting on proposals.\\n      */\\n    function castVoteBySig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"GovernorBravo::castVoteBySig: invalid signature\\\");\\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), \\\"\\\");\\n    }\\n\\n    /**\\n      * @notice Internal function that caries out voting logic\\n      * @param voter The voter that is casting their vote\\n      * @param proposalId The id of the proposal to vote on\\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n      * @return The number of votes cast\\n      */\\n    function castVoteInternal(address voter, uint proposalId, uint8 support) internal returns (uint96) {\\n        require(state(proposalId) == ProposalState.Active, \\\"GovernorBravo::castVoteInternal: voting is closed\\\");\\n        require(support <= 2, \\\"GovernorBravo::castVoteInternal: invalid vote type\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"GovernorBravo::castVoteInternal: voter already voted\\\");\\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support == 0) {\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\n        } else if (support == 1) {\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\n        } else if (support == 2) {\\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        return votes;\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the voting delay\\n      * @param newVotingDelay new voting delay, in blocks\\n      */\\n    function _setVotingDelay(uint newVotingDelay) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setVotingDelay: admin only\\\");\\n        require(newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY, \\\"GovernorBravo::_setVotingDelay: invalid voting delay\\\");\\n        uint oldVotingDelay = votingDelay;\\n        votingDelay = newVotingDelay;\\n\\n        emit VotingDelaySet(oldVotingDelay,votingDelay);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the voting period\\n      * @param newVotingPeriod new voting period, in blocks\\n      */\\n    function _setVotingPeriod(uint newVotingPeriod) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setVotingPeriod: admin only\\\");\\n        require(newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD, \\\"GovernorBravo::_setVotingPeriod: invalid voting period\\\");\\n        uint oldVotingPeriod = votingPeriod;\\n        votingPeriod = newVotingPeriod;\\n\\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the proposal threshold\\n      * @dev newProposalThreshold must be greater than the hardcoded min\\n      * @param newProposalThreshold new proposal threshold\\n      */\\n    function _setProposalThreshold(uint newProposalThreshold) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_setProposalThreshold: admin only\\\");\\n        require(newProposalThreshold >= MIN_PROPOSAL_THRESHOLD && newProposalThreshold <= MAX_PROPOSAL_THRESHOLD, \\\"GovernorBravo::_setProposalThreshold: invalid proposal threshold\\\");\\n        uint oldProposalThreshold = proposalThreshold;\\n        proposalThreshold = newProposalThreshold;\\n\\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\\n    }\\n\\n    /**\\n      * @notice Initiate the GovernorBravo contract\\n      * @dev Admin only. Sets initial proposal id which initiates the contract, ensuring a continuous proposal id count\\n      * @param governorAlpha The address for the Governor to continue the proposal id count from\\n      */\\n    function _initiate(address governorAlpha) external {\\n        require(msg.sender == admin, \\\"GovernorBravo::_initiate: admin only\\\");\\n        require(initialProposalId == 0, \\\"GovernorBravo::_initiate: can only initiate once\\\");\\n        proposalCount = GovernorAlpha(governorAlpha).proposalCount();\\n        initialProposalId = proposalCount;\\n        timelock.acceptAdmin();\\n    }\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) external {\\n        // Check caller = admin\\n        require(msg.sender == admin, \\\"GovernorBravo:_setPendingAdmin: admin only\\\");\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      */\\n    function _acceptAdmin() external {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        require(msg.sender == pendingAdmin && msg.sender != address(0), \\\"GovernorBravo:_acceptAdmin: pending admin only\\\");\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function getChainIdInternal() internal view returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c;\\n        unchecked { c = a + b; }\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c;\\n        unchecked { c = a + b; }\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c;\\n        unchecked { c = a * b; }\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c;\\n        unchecked { c = a * b; }\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract Timelock {\\n    using SafeMath for uint;\\n\\n    event NewAdmin(address indexed newAdmin);\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\n    event NewDelay(uint indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\\n\\n    uint public constant GRACE_PERIOD = 14 days;\\n    uint public constant MINIMUM_DELAY = 2 days;\\n    uint public constant MAXIMUM_DELAY = 30 days;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    uint public delay;\\n\\n    mapping (bytes32 => bool) public queuedTransactions;\\n\\n\\n    constructor(address admin_, uint delay_) public {\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n\\n        admin = admin_;\\n        delay = delay_;\\n    }\\n\\n    fallback() external payable { }\\n\\n    function setDelay(uint delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function acceptAdmin() public {\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n        admin = msg.sender;\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(admin);\\n    }\\n\\n    function setPendingAdmin(address pendingAdmin_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n        pendingAdmin = pendingAdmin_;\\n\\n        emit NewPendingAdmin(pendingAdmin);\\n    }\\n\\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n        require(eta >= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\n    }\\n\\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n        require(getBlockTimestamp() >= eta, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"contract ComptrollerInterface\",\"name\":\"comptroller_\",\"type\":\"address\"},{\"internalType\":\"contract InterestRateModel\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isGLP_\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"becomeImplementationData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ComptrollerInterface\",\"name\":\"oldComptroller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ComptrollerInterface\",\"name\":\"newComptroller\",\"type\":\"address\"}],\"name\":\"NewComptroller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract InterestRateModel\",\"name\":\"oldInterestRateModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract InterestRateModel\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"NewMarketInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReserveFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"RepayBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"}],\"name\":\"_addReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"_reduceReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"autocompound_\",\"type\":\"bool\"}],\"name\":\"_setAutocompoundRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ComptrollerInterface\",\"name\":\"newComptroller\",\"type\":\"address\"}],\"name\":\"_setComptroller\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStakedGlp\",\"name\":\"stakedGLP_\",\"type\":\"address\"},{\"internalType\":\"contract IGmxRewardRouter\",\"name\":\"glpRewardRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"glpManager_\",\"type\":\"address\"}],\"name\":\"_setGlpAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowResign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"becomeImplementationData\",\"type\":\"bytes\"}],\"name\":\"_setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InterestRateModel\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"_setReserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managementFee_\",\"type\":\"uint256\"}],\"name\":\"_setVaultFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"_signalTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveGlpRewardRouterWETHSpending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autocompound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"internalType\":\"contract ComptrollerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToViewImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_TokenID\",\"type\":\"uint256\"}],\"name\":\"depositNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glpManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glpRewardRouter\",\"outputs\":[{\"internalType\":\"contract IGmxRewardRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gmxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract CTokenInterface\",\"name\":\"cTokenCollateral\",\"type\":\"address\"}],\"name\":\"liquidateBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolSeizeShareMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proxyTypeId\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sbfGMX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedGLP\",\"outputs\":[{\"internalType\":\"contract IStakedGlp\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedGmxTracker\",\"outputs\":[{\"internalType\":\"contract IRewardTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EIP20NonStandardInterface\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowsCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_TokenID\",\"type\":\"uint256\"}],\"name\":\"withdrawNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "CErc20Delegator",
    "CompilerVersion": "v0.8.10+commit.fc410830",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000fd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9000000000000000000000000117e3f342886e18674e50ea88633f9be1127352000000000000000000000000049c67df0d856785739a2e454aa4921d63a51be130000000000000000000000000000000000000000000000000000b5e620f48000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000005b33ec561cb20eaf7d5b41a9b68a690e2ebbc8930000000000000000000000000fc8fe15649fb8fb728b3518c30045ebdda60a4e00000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000455534454000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005745553445400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "None",
    "Proxy": "1",
    "Implementation": "0x0fc8fe15649fb8fb728b3518c30045ebdda60a4e",
    "SwarmSource": "ipfs://2ff345bf3a1f7fc29c5170e2e8053b2c2b1ac73107db64bfa9e5c0965f892fc4"
}