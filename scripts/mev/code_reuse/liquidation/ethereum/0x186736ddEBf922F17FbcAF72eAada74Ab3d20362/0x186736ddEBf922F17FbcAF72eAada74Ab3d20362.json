{
    "SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.11;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n    function decimals() external view returns(uint);\r\n}\r\n\r\ninterface ICToken is IERC20 {\r\n    function underlying() external view returns(address);\r\n    function redeem(uint redeemAmount) external returns (uint);\r\n    function mint(uint amount) external returns(uint);\r\n    function symbol() external returns(string memory);\r\n    function liquidateBorrow(address borrower, uint amount, address collateral) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n}\r\n\r\ninterface SushiRouterLike {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);    \r\n}\r\n\r\ninterface KeeperDAOLike {\r\n    function borrow(address _token, uint256 _amount, bytes calldata _data) external;\r\n}\r\n\r\ncontract Igor {\r\n    ICToken constant fICHI = ICToken(0xaFf95ac1b0A78Bd8E4f1a2933E373c66CC89C0Ce);\r\n    ICToken constant fUSDC = ICToken(0xecE2c0aA6291e3f1222B6f056596dfE0E81039b9);\r\n    IERC20 constant ICHI = IERC20(0x903bEF1736CDdf2A537176cf3C64579C3867A881);\r\n    SushiRouterLike constant SUSHI = SushiRouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address constant IGOR = 0xcfF7303b8E08403438c751bF21c04771252fA413;\r\n    address constant KEEPERDAO = 0x4F868C1aa37fCf307ab38D215382e88FCA6275E2;\r\n\r\n    uint constant loanSize = 2e6 * 1e6; // $2m\r\n\r\n    constructor() public {\r\n        USDC.approve(address(fUSDC), uint(-1));\r\n        ICHI.approve(address(SUSHI), uint(-1));\r\n    }\r\n\r\n    function start(address borrower, uint amount, uint minReturn) external returns(uint newUSDCBalance) {\r\n        require(tx.origin == IGOR, \"!IGOR\");        \r\n        bytes memory data = abi.encodeWithSelector(\r\n            Igor.save.selector,\r\n            borrower, amount, minReturn\r\n        );\r\n\r\n        uint usdcBalanceBefore = USDC.balanceOf(address(this));  \r\n        KeeperDAOLike(KEEPERDAO).borrow(address(USDC), loanSize, data);\r\n\r\n        newUSDCBalance = USDC.balanceOf(address(this));\r\n\r\n        //USDC.transfer(usdcOwner, newUSDCBalance);\r\n\r\n        newUSDCBalance = newUSDCBalance - usdcBalanceBefore;\r\n\r\n        require(minReturn <= newUSDCBalance, \"min return\");\r\n    }\r\n\r\n    function save(address borrower, uint amount, uint minReturn) external {\r\n        require(tx.origin == IGOR, \"!IGOR\");\r\n        //fUSDC.transferFrom(fUSDCOwner, address(this), fUSDAmount);\r\n        //USDC.transferFrom(usdcOwner, address(this), amount);\r\n\r\n        //USDC.approve(address(fUSDC), amount);\r\n             \r\n        require(fUSDC.liquidateBorrow(borrower, amount, address(fICHI)) == 0, \"liquidation failed\");\r\n        \r\n        // redeem ichi\r\n        fICHI.redeem(fICHI.balanceOf(address(this)));\r\n\r\n        // dump ichi to usdc\r\n        uint ichiBalance = ICHI.balanceOf(address(this));\r\n        \r\n        address[] memory path = new address[](3);\r\n        path[0] = address(ICHI);\r\n        path[1] = address(WETH);\r\n        path[2] = address(USDC);\r\n\r\n        SUSHI.swapExactTokensForTokens(ichiBalance, 1, path, address(this), now + 1);\r\n\r\n        // redeem the usdc from the fusdc\r\n        fUSDC.redeemUnderlying(amount);\r\n\r\n        USDC.transfer(KEEPERDAO, loanSize);\r\n    }\r\n\r\n    function getToken(IERC20 token) public {\r\n        require(msg.sender == IGOR, \"!IGOR\");        \r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n}",
    "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"save\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newUSDCBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "Igor",
    "CompilerVersion": "v0.6.11+commit.5ef660b1",
    "OptimizationUsed": "1",
    "Runs": "100",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "BSD-3-Clause",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://d0efe0707c551c75ac1833465b045d415e9cad9cf8c59e57a3b15b09e0ad2dfd"
}