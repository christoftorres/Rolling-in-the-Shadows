{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/LiquidationController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/tokens/WETH.sol\\\";\\nimport { FlashLoanReceiverBase, ILendingPoolAddressesProvider } from \\\"./interfaces/AaveV2Interfaces.sol\\\";\\nimport { bdToken, Stabilizer } from \\\"./interfaces/BaoInterfaces.sol\\\";\\nimport { ISwapRouter } from \\\"./interfaces/UniswapInterfaces.sol\\\";\\nimport { ICurve } from \\\"./interfaces/CurveInterfaces.sol\\\";\\n\\ncontract LiquidationController is FlashLoanReceiverBase {\\n    bdToken constant bdUSD = bdToken(0xc0601094C0C88264Ba285fEf0a1b00eF13e79347);\\n    WETH constant wrappedETH = WETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\\n    ERC20 constant DAI = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\\n    ERC20 constant bSTBL = ERC20(0x5ee08f40b637417bcC9d2C51B62F4820ec9cF5D8);\\n    ERC20 constant bdSTBL = ERC20(0xE0a55c00E6510F4F7df9af78b116B7f8E705cA8F);\\n    ERC20 constant bdETH = ERC20(0xF635fdF9B36b557bD281aa02fdfaeBEc04CD084A);\\n    ERC20 constant bUSD = ERC20(0x7945b0A6674b175695e5d1D08aE1e6F13744Abb0);\\n    ERC20 constant USDC = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\n    ICurve constant curvePoolbUSD = ICurve(0x0FaFaFD3C393ead5F5129cFC7e0E12367088c473); // bUSD-3Pool\\n    ICurve constant curvePoolbSTBL = ICurve(0xA148BD19E26Ff9604f6A608E22BFb7B772D0d1A3); // bSTBL-DAI\\n    ISwapRouter constant swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // UniV3 Router\\n\\n    address immutable public owner; // Only used for the retrieve function, no need to use OZ's Ownable or Solmate's Auth\\n\\n    event log_named_uint(string key, uint val);\\n\\n    mapping(address => uint24) poolFee;\\n\\n    constructor(\\n        address _lpap\\n    ) FlashLoanReceiverBase(ILendingPoolAddressesProvider(_lpap)) {\\n        owner = msg.sender;\\n\\n        // Approve tokens on contract creation to save gas during liquidations\\n        DAI.approve(address(curvePoolbUSD), type(uint256).max);\\n        bUSD.approve(address(curvePoolbUSD), type(uint256).max);\\n        bUSD.approve(address(bdUSD), type(uint256).max);\\n        wrappedETH.approve(address(swapRouter), type(uint256).max);\\n        bSTBL.approve(address(curvePoolbSTBL), type(uint256).max);\\n        USDC.approve(address(swapRouter), type(uint256).max);\\n    }\\n\\n    // This function is called after the contract has received the flash loan\\n    function executeOperation(\\n        address[] calldata,\\n        uint256[] calldata amounts,\\n        uint256[] calldata premiums,\\n        address,\\n        bytes calldata _params\\n    ) external override returns(bool) {\\n        (address _borrower, uint256 _repayAmount, address _bdCollateral) = abi.decode(_params, (address, uint256, address));\\n        // Exchange DAI for bUSD on Curve\\n        curvePoolbUSD.exchange_underlying(1, 0, amounts[0], 0);\\n\\n        // If liquidation doesn't succed, we revert\\n        require(bdUSD.liquidateBorrow(_borrower, _repayAmount, _bdCollateral) == 0);\\n\\n        bdToken bdCollateral = bdToken(_bdCollateral);\\n\\n        bdCollateral.redeem(bdCollateral.balanceOf(address(this)));\\n        ISwapRouter.ExactInputSingleParams memory params;\\n        uint collateralAmount;\\n\\n        // If we are handling eth -> transform to weth before selling\\n        if (_bdCollateral==address(bdETH)) {\\n            collateralAmount = address(this).balance;\\n\\n            // ETH to WETH\\n            wrappedETH.deposit{value: collateralAmount}();\\n\\n            // Define Swap Params\\n            params = ISwapRouter.ExactInputSingleParams({\\n                tokenIn: address(wrappedETH),\\n                tokenOut: address(DAI),\\n                fee: 3000, // Hardcoded cause SLOADs are expensive (361 gas here)\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: collateralAmount,\\n                amountOutMinimum: 0,\\n                sqrtPriceLimitX96: 0\\n            });\\n            // Execute Swap\\n            swapRouter.exactInputSingle(params);\\n        }\\n        else if (_bdCollateral==address(bdSTBL)) {\\n            // Get amount of seized assets\\n            address underlyingCollateral = bdCollateral.underlying();\\n            collateralAmount = ERC20(underlyingCollateral).balanceOf(address(this));\\n            //Swap bSTBL for DAI on Curve\\n            bSTBL.approve(address(curvePoolbSTBL), collateralAmount);\\n            curvePoolbSTBL.exchange(1, 0, collateralAmount, 0);\\n        }\\n        // Swapping USDC for DAI\\n        else {\\n            // Get amount of seized assets\\n            address underlyingCollateral = bdCollateral.underlying();\\n            collateralAmount = ERC20(underlyingCollateral).balanceOf(address(this));\\n\\n            // Define Swap Params\\n            params = ISwapRouter.ExactInputSingleParams({\\n                tokenIn: underlyingCollateral,\\n                tokenOut: address(DAI),\\n                fee: 100, //0.01%\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: collateralAmount,\\n                amountOutMinimum: 0,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n            // Execute Swap\\n            swapRouter.exactInputSingle(params);\\n        }       \\n        uint totalDebt = amounts[0] + premiums[0];\\n        DAI.approve(address(LENDING_POOL), totalDebt);\\n        return true;\\n    }\\n\\n    /**\\n      * @notice Method to liquidate users given an address, amount and asset.\\n      * @param _borrower The addresses whose borrow we are going to repay (liquidations)\\n      * @param _repayAmount The number of borrowed assets we want to repay\\n      * @param _bdCollateral The bdToken address of the collateral we want to claim\\n      */\\n    function executeLiquidations(\\n        address _borrower,\\n        uint256 _repayAmount,\\n        address _bdCollateral,\\n        uint256 _loan_amount,\\n        address _receiver\\n    ) external {\\n        bytes memory params = abi.encode(_borrower,_repayAmount,_bdCollateral);\\n\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = _loan_amount;\\n\\n        address[] memory assets = new address[](1);\\n        assets[0] = address(DAI);\\n\\n        // 0 = no debt, 1 = stable, 2 = variable\\n        uint256[] memory modes = new uint256[](1);\\n        modes[0] = 0;\\n\\n        LENDING_POOL.flashLoan(address(this), assets, amounts, modes, address(this), params, 0);\\n\\n        // Transfer funds to _receiver (to avoid griefing attack)\\n        DAI.transfer(_receiver, DAI.balanceOf(address(this)));\\n    }\\n\\n    // In case any funds are sent to the contract, allow the owner to retrieve them\\n    function retrieve(address token, uint256 amount) external {\\n        require(owner == msg.sender, \\\"Must be owner\\\");\\n\\n        ERC20 tokenContract = ERC20(token);\\n        tokenContract.transfer(msg.sender, amount);\\n    }\\n\\n    // Needed for bdETH redeem\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/AaveV2Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\ninterface ILendingPool {\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata modes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external;\\n}\\n\\ninterface ILendingPoolAddressesProvider {\\n    function getLendingPool() external view returns (address);\\n}\\n\\ninterface IFlashLoanReceiver {\\n    function executeOperation(\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata premiums,\\n        address initiator,\\n        bytes calldata params\\n    ) external returns (bool);\\n\\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\\n\\n    function LENDING_POOL() external view returns (ILendingPool);\\n}\\n\\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\\n    ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\\n    ILendingPool public immutable override LENDING_POOL;\\n\\n    constructor(ILendingPoolAddressesProvider provider) {\\n        ADDRESSES_PROVIDER = provider;\\n        LENDING_POOL = ILendingPool(provider.getLendingPool());\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/BaoInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\n\\nabstract contract bdToken is ERC20 {\\n    address public underlying;\\n\\n    function redeem(uint redeemTokens) virtual external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) virtual external returns (uint);\\n    function mint(uint mintAmount, bool enterMarket) virtual external returns (uint);\\n    function borrow(uint borrowAmount) virtual external returns (uint);\\n}\\n\\ninterface Stabilizer {\\n    function buy(uint amount) external;\\n    function sell(uint amount) external;\\n}\"\r\n    },\r\n    \"src/interfaces/UniswapInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\"\r\n    },\r\n    \"src/interfaces/CurveInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\ninterface ICurve {\\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns(uint256);\\n\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\\n\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns(uint256);\\n}\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpap\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LENDING_POOL\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bdCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loan_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"executeLiquidations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retrieve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "LiquidationController",
    "CompilerVersion": "v0.8.15+commit.e14f2714",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000b53c1a33016b2dc2ff3653530bff1848a515c8c5",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}