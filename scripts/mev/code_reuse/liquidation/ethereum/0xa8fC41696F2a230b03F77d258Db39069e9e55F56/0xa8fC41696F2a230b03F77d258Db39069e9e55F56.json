{
    "SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.17;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC4626 is IERC20 {\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface ILendingPoolAddressesProvider {\r\n    function getPool() external view returns (address);\r\n}\r\n\r\ninterface ILendingPool {\r\n    /**\r\n    * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n    * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n    *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n    * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n    * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n    * @param user The address of the borrower getting liquidated\r\n    * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n    * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n    * to receive the underlying collateral asset directly\r\n    **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n    * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n    * as long as the amount taken plus a fee is returned.\r\n    * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n    * For further details please visit https://developers.aave.com\r\n    * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n    * @param assets The addresses of the assets being flash-borrowed\r\n    * @param amounts The amounts amounts being flash-borrowed\r\n    * @param modes Types of the debt to open if the flash loan is not returned:\r\n    *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n    *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n    *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n    * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n    * @param params Variadic packed params to pass to the receiver as extra information\r\n    * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n    *   0 if the action is executed directly by the user, without any middle-man\r\n    **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n}\r\n\r\ninterface IERC3156FlashBorrower {\r\n\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IERC3156FlashLender {\r\n\r\n    /**\r\n     * @dev The amount of currency available to be lent.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(\r\n        address token\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(\r\n        address token,\r\n        uint256 amount\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IERC3156FlashBorrower receiver,\r\n        address token,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV3Router {\r\n    \r\n    struct ExactInputParams {\r\n        bytes   path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(IUniswapV3Router.ExactInputParams calldata params)\r\n        external payable returns (uint256 amountOut);\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n    * @dev Returns true if `account` is a contract.\r\n    *\r\n    * [IMPORTANT]\r\n    * ====\r\n    * It is unsafe to assume that an address for which this function returns\r\n    * false is an externally-owned account (EOA) and not a contract.\r\n    *\r\n    * Among others, `isContract` will return false for the following\r\n    * types of addresses:\r\n    *\r\n    *  - an externally-owned account\r\n    *  - a contract in construction\r\n    *  - an address where a contract will be created\r\n    *  - an address where a contract lived, but was destroyed\r\n    * ====\r\n    */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            'SafeERC20: approve from non-zero to non-zero allowance'\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), 'SafeERC20: call to non-contract');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, 'SafeERC20: low-level call failed');\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\r\n        }\r\n    }\r\n}\r\n\r\ninterface CurvePoolLike {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns (uint256 dy);\r\n}\r\n\r\ninterface WrappedSTETHLike is IERC20 {\r\n    function stETH() external view returns (IERC20);\r\n    function wrap(uint256 _stETHAmount) external returns (uint256);\r\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\r\n}\r\n\r\ninterface WETHLike is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256) external;\r\n}\r\n\r\ncontract LiquidateLoan is IFlashLoanReceiver, IERC3156FlashBorrower {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    ILendingPoolAddressesProvider public immutable provider;\r\n    ILendingPool public immutable lendingPool;\r\n    IUniswapV3Router public immutable uniswapV3Router;\r\n    address public immutable treasury;\r\n    IERC20 public immutable dai;\r\n    IERC4626 public immutable sdai;\r\n    WrappedSTETHLike public immutable wstETH;\r\n    WETHLike public immutable weth;\r\n    IERC20 public immutable stETH;\r\n    IERC3156FlashLender public immutable daiFlashLender;\r\n    CurvePoolLike public immutable stETHCurvePool;\r\n\r\n    constructor(\r\n        address _addressProvider,\r\n        address _uniswapV3Router,\r\n        address _treasury,\r\n        address _dai,\r\n        address _sdai,\r\n        address _weth,\r\n        address _wstETH,\r\n        address _daiFlashLender,\r\n        address _stETHCurvePool\r\n    ) {\r\n        provider = ILendingPoolAddressesProvider(_addressProvider);\r\n        lendingPool = ILendingPool(provider.getPool());\r\n        uniswapV3Router = IUniswapV3Router(_uniswapV3Router);\r\n        treasury = _treasury;\r\n        dai = IERC20(_dai);\r\n        sdai = IERC4626(_sdai);\r\n        weth = WETHLike(_weth);\r\n        wstETH = WrappedSTETHLike(_wstETH);\r\n        stETH = wstETH.stETH();\r\n        daiFlashLender = IERC3156FlashLender(_daiFlashLender);\r\n        stETHCurvePool = CurvePoolLike(_stETHCurvePool);\r\n\r\n        dai.approve(address(sdai), type(uint256).max);\r\n        stETH.approve(address(wstETH), type(uint256).max);\r\n        stETH.approve(address(stETHCurvePool), type(uint256).max);\r\n    }\r\n\r\n    /**\r\n        Maker DAI flash loan.\r\n     */\r\n    function onFlashLoan(\r\n        address,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32) {\r\n        flashLoanReceived(token, amount, fee, data);\r\n\r\n        IERC20(token).approve(address(daiFlashLender), amount + fee);\r\n        \r\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\r\n    }\r\n\r\n    /**\r\n        Spark Lend flash loan.\r\n     */\r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address,\r\n        bytes calldata params\r\n    )\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        flashLoanReceived(assets[0], amounts[0], premiums[0], params);\r\n\r\n        // Approve the pool to reclaim\r\n        IERC20(assets[0]).approve(address(lendingPool), amounts[0] + premiums[0]);\r\n\r\n        return true;\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    function flashLoanReceived(\r\n        address assetToLiquidiate,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata params\r\n    ) internal {\r\n        //collateral  the address of the token that we will be compensated in\r\n        //userToLiquidate - id of the user to liquidate\r\n        //amountOutMin - minimum amount of asset paid when swapping collateral\r\n        {\r\n            (address collateral, address userToLiquidate, bytes memory swapPath) = abi.decode(params, (address, address, bytes));\r\n\r\n            //liquidate unhealthy loan\r\n            liquidateLoan(collateral, assetToLiquidiate, userToLiquidate, amount, false);\r\n\r\n            //swap collateral from liquidate back to asset from flashloan to pay it off\r\n            if (collateral != assetToLiquidiate) {\r\n                // Unwrap sDAI if it's the collateral - there is no paths for sDAI in DEXes\r\n                if (collateral == address(sdai)) {\r\n                    sdai.redeem(sdai.balanceOf(address(this)), address(this), address(this));\r\n                    collateral = address(dai);\r\n                }\r\n\r\n                // Unwrap wstETH and swap to WETH\r\n                if (collateral == address(wstETH)) {\r\n                    uint256 received = wstETH.unwrap(wstETH.balanceOf(address(this)));\r\n                    received = stETHCurvePool.exchange(1, 0, received, 0);\r\n                    weth.deposit{value:received}();\r\n                    collateral = address(weth);\r\n                }\r\n\r\n                // Perform Uniswap swaps\r\n                if (swapPath.length > 0) swapToBorrowedAsset(collateral, swapPath);\r\n\r\n                // Swap WETH to stETH and wrap to wstETH\r\n                if (assetToLiquidiate == address(wstETH)) {\r\n                    uint256 bal = weth.balanceOf(address(this));\r\n                    weth.withdraw(bal);\r\n                    stETHCurvePool.exchange{value:bal}(0, 1, bal, 0);\r\n                    wstETH.wrap(stETH.balanceOf(address(this)));\r\n                }\r\n\r\n                // Wrap to sDAI if it's the liquidated asset (we assume current balance is in DAI)\r\n                if (assetToLiquidiate == address(sdai)) {\r\n                    sdai.deposit(dai.balanceOf(address(this)), address(this));\r\n                }\r\n            }\r\n        }\r\n\r\n        //Pay to owner the balance after fees\r\n        uint256 earnings = IERC20(assetToLiquidiate).balanceOf(address(this));\r\n        uint256 costs = amount + fee;\r\n\r\n        require(earnings >= costs , \"No profit\");\r\n        IERC20(assetToLiquidiate).transfer(treasury, earnings - costs);\r\n    }\r\n\r\n    function liquidateLoan(address _collateral, address _liquidate_asset, address _userToLiquidate, uint256 _amount, bool _receiveaToken) public {\r\n        require(IERC20(_liquidate_asset).approve(address(lendingPool), _amount), \"Approval error\");\r\n\r\n        lendingPool.liquidationCall(_collateral, _liquidate_asset, _userToLiquidate, _amount, _receiveaToken);\r\n    }\r\n\r\n    //assumes the balance of the token is on the contract\r\n    function swapToBorrowedAsset(address asset_from, bytes memory path) public {\r\n        IERC20 asset_fromToken;\r\n        uint256 amountToTrade;\r\n\r\n        asset_fromToken = IERC20(asset_from);\r\n        amountToTrade = asset_fromToken.balanceOf(address(this));\r\n\r\n        // grant uniswap access to your token\r\n        asset_fromToken.approve(address(uniswapV3Router), amountToTrade);\r\n\r\n        // Trade 1: Execute swap from asset_from into designated ERC20 (asset_to) token on UniswapV2\r\n        uniswapV3Router.exactInput(IUniswapV3Router.ExactInputParams({\r\n            path: path,\r\n            recipient: address(this),\r\n            deadline: block.timestamp,\r\n            amountIn: amountToTrade,\r\n            amountOutMinimum: 0\r\n        }));\r\n    }\r\n\r\n    /*\r\n    * This function is manually called to commence the flash loans sequence\r\n    * to make executing a liquidation  flexible calculations are done outside of the contract and sent via parameters here\r\n    * _assetToLiquidate - the token address of the asset that will be liquidated\r\n    * _flashAmt - flash loan amount (number of tokens) which is exactly the amount that will be liquidated\r\n    * _collateral - the token address of the collateral. This is the token that will be received after liquidating loans\r\n    * _userToLiquidate - user ID of the loan that will be liquidated\r\n    * _swapPath - the path that uniswap will use to swap tokens back to original tokens\r\n    */\r\n    function executeFlashLoans(address _assetToLiquidate, uint256 _flashAmt, address _collateral, address _userToLiquidate, bytes memory _swapPath) public {\r\n        bytes memory params = abi.encode(_collateral, _userToLiquidate, _swapPath);\r\n        \r\n        if (_assetToLiquidate == address(dai)) {\r\n            // Use Maker Flash Mint Module\r\n            daiFlashLender.flashLoan(this, _assetToLiquidate, _flashAmt, params);\r\n        } else {\r\n            // Use Spark Lend Flash Loan\r\n            address[] memory assets = new address[](1);\r\n            assets[0] = _assetToLiquidate;\r\n            uint256[] memory amounts = new uint256[](1);\r\n            amounts[0] = _flashAmt;\r\n            uint256[] memory modes = new uint256[](1);\r\n            modes[0] = 0;\r\n            lendingPool.flashLoan(\r\n                address(this),\r\n                assets,\r\n                amounts,\r\n                modes,\r\n                address(this),\r\n                params,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV3Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sdai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wstETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiFlashLender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stETHCurvePool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiFlashLender\",\"outputs\":[{\"internalType\":\"contract IERC3156FlashLender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetToLiquidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_flashAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userToLiquidate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapPath\",\"type\":\"bytes\"}],\"name\":\"executeFlashLoans\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidate_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userToLiquidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_receiveaToken\",\"type\":\"bool\"}],\"name\":\"liquidateLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provider\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sdai\",\"outputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETHCurvePool\",\"outputs\":[{\"internalType\":\"contract CurvePoolLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"name\":\"swapToBorrowedAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV3Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract WETHLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wstETH\",\"outputs\":[{\"internalType\":\"contract WrappedSTETHLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "LiquidateLoan",
    "CompilerVersion": "v0.8.17+commit.8df45f5f",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "00000000000000000000000002c3ea4e34c0cbd694d2adfa2c690eecbc1793ee000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000b137e7d16564c81ae2b0c8ee6b55de81dd46ece50000000000000000000000006b175474e89094c44da98b954eedeac495271d0f00000000000000000000000083f20f44975d03b1b09e64809b757c47f942beea000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca000000000000000000000000060744434d6339a6b27d73d9eda62b6f66a0a04fa000000000000000000000000dc24316b9ae028f1497c275eb9192a3ea0f67022",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "GNU GPLv3",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://c2bcfda187e7f48bfb22f0736361e00d10c92ff41aa8759c927b4bba1e930808"
}